{"meta":{"title":"CicadaOnTheTree","subtitle":"哈喽呀","description":"我要握住一个最美的梦给未来的自己","author":"Vanessa Yao","url":"https://vanessayaoyao.github.io","root":"/"},"pages":[{"title":"tags","date":"2021-12-03T10:26:53.000Z","updated":"2021-12-03T10:27:25.448Z","comments":true,"path":"tags/index.html","permalink":"https://vanessayaoyao.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Data Structures & Algorithms Part 1-2","slug":"data-structures-algorithms-part1-2","date":"2022-02-11T07:19:31.000Z","updated":"2022-02-24T01:39:02.086Z","comments":true,"path":"2022/02/11/data-structures-algorithms-part1-2/","link":"","permalink":"https://vanessayaoyao.github.io/2022/02/11/data-structures-algorithms-part1-2/","excerpt":"","text":"hhh","categories":[],"tags":[{"name":"data structures","slug":"data-structures","permalink":"https://vanessayaoyao.github.io/tags/data-structures/"}]},{"title":"Data Structures & Algorithms Part 1-1","slug":"data-structures-algorithms-part1","date":"2022-02-03T10:48:03.000Z","updated":"2022-02-11T07:21:04.507Z","comments":true,"path":"2022/02/03/data-structures-algorithms-part1/","link":"","permalink":"https://vanessayaoyao.github.io/2022/02/03/data-structures-algorithms-part1/","excerpt":"","text":"Data Structures and algorithms for beginners. Ace your coding interview. Watch this tutorial to learn all about Big O, arrays and linked lists! [toc] Big O NatationWe use Big O to describe the performance of an algorithm. scalable how much on an algorithm slows down as the input grows larger O(1)Constant time 12345public void log(int[] numbers)&#123; // O(1) System.out.println(numbers[0]); System.out.println(numbers[0]);&#125; O(n)linear 12345public void log(int[] numbers)&#123; // O(n) n-&gt;size of the input for (int i = 0; i &lt; numbers.length; i++) System.out.println(numbers[i]);&#125; O(n^2)quadratic 12345public void log(int[] numbers)&#123; for (int first : numbers) for (int second : numbers) System.out.println(first + &quot;, &quot; + second);&#125; O(log n)logarithmic Binary search 二分法 1 million items in an array, find the target item with a maximum of 19 comparisons O(2^n)exponential Space Complexitythe additional space that we should allocate relative to the size of the input 1234567public void greet(String[] names)&#123; // O(1) space for (int i = 0; i &lt; names.length; i++) System.out.println(&quot;Hi &quot; + names[i]); // O(n) space String[] copy = new String[names.length];&#125; Arraysstrored sequentially in memory Lookup O(1) Insert O(n) Delete O(n) Exercise: Building an Array1234567891011121314151617181920212223242526272829303132333435363738394041public class Array &#123; private int[] items; private int count; public Array(int length)&#123; items = new int[length]; &#125; public void insert(int item)&#123; // If the array is full, resize it if (items.length == count)&#123; // Create a new array (twice the size) int[] newItems = new int[count * 2]; // Copy all the existing items for (int i = 0; i &lt; count; i++) newItems[i] = items[i]; // Set &quot;items&quot; to this new array items = newItems; &#125; // Add the new item at the end items[count++] = item; &#125; public void removeAt(int index) &#123; // Validate the index if (index &lt; 0 || index &gt;= count) throw new IllegalStateException(); // Shift the items to the left to fill the hole for (int i = index; i &lt; count; i++) items[i] = items[i+1]; count--; &#125; public int indexOf(int item) &#123; // If we find it, return index. Otherwise, return -1 for (int i = 0;i &lt; count; i++) if (items[i] == item) return i; return -1; &#125; public void print()&#123; for (int i = 0; i &lt; count; i++) System.out.println(items[i]); &#125;&#125; Dynamic Arrays12345678910111213&#x2F;&#x2F; java has two implementations of dynamic arrays&#x2F;&#x2F; Vector: 100% - synchronized&#x2F;&#x2F; ArrayList: 50%ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();list.add(10);list.add(20);list.add(30);list.remove(0);list.indexOf(20);list.contains(1);list.size();list.toArray();System.out.println(list); Linked Lists链表 consistd of a group of nodes in sequence Lookup by value O(n) by index O(n) Insert At the end O(1) At the beginning O(1) In the middle O(n) delete From the beginning O(1) From the end O(n) 得找到倒数第二个结点 From the middle O(n) 1234567891011LinkedList list = new LinkedList();list.addLast(10);list.addLast(20);list.addLast(30);list.addFirst(&quot;hah&quot;);list.removeLast();list.contains(10);list.indexOf(10);list.size();Object[] array = list.toArray();System.out.println(Arrays.toString(array)); Exercise: Building a Linked List123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109import java.util.NoSuchElementException;public class LinkedList &#123; private class Node &#123; private int value; private Node next; public Node(int value) &#123; this.value = value; &#125; &#125; private Node first; private Node last; private int size; public void addLast(int item) &#123; Node node = new Node(item); if (isEmpty()) first = last = node; else &#123; last.next = node; last = node; &#125; size++; &#125; public void addFirst(int item) &#123; Node node = new Node(item); if (isEmpty()) first = last = node; else &#123; node.next = first; first = node; &#125; size++; &#125; public int indexOf(int item) &#123; int index = 0; Node current = first; while (current != null)&#123; if (current.value == item) return index; current = current.next; index++; &#125; return -1; &#125; public boolean contains(int item) &#123; return indexOf(item) != -1; &#125; public void removeFirst() &#123; if(isEmpty()) throw new NoSuchElementException(); if(first == last)&#123; first = last = null; size = 0; return; &#125; Node second = first.next; first.next = null; first = second; size--; &#125; public void removeLast() &#123; Node previous = getPrevious(last); if(isEmpty()) throw new NoSuchElementException(); if(first == last)&#123; first = last = null; size = 0; return; &#125; last = previous; last.next = null; size--; &#125; private Node getPrevious(Node node)&#123; Node current = first; while (current != null) &#123; if (current.next == node) return current; current = current.next; &#125; return null; &#125; public int size() &#123; return size; &#125; public int[] toArray() &#123; int[] array = new int[size]; Node current = first; int index = 0; while (current != null)&#123; array[index++] = current.value; current = current.next; &#125; return array; &#125; private boolean isEmpty() &#123; return first == null; &#125;&#125; Arrays vs Linked ListsSPACE Static arrays have a fixed size Dynamic arrays grow by 50-100% Linked lists don’t waste memory Use arrays if you know the number of items to store new ArrayList(100) Types of Linked Lists Your transcript or degree is not a reflection of your knowledge or capabilities. Exercise: Reversing a Linked List12345678910111213141516public void reverse()&#123; // [10 20 30] // p c n if (isEmpty()) return; Node previous = first; Node current = first.next; while (current != null)&#123; Node next = current.next; current.next = previous; previous = current; current = next; &#125; last = first; last.next = null; first = previous;&#125; Exercise: Kth Node form the EndFind the Kth node from the end of a linked list in one pass. 12345678910111213141516public int getKthFromTheEnd(int k)&#123; if (isEmpty()) throw new IllegalStateException(); Node a = first; Node b = first; for (int i = 0; i &lt; k - 1; i++) &#123; b = b.next; if (b == null) throw new IllegalArgumentException(); &#125; while (b != last)&#123; a = a.next; b = b.next; &#125; return a.value;&#125;","categories":[],"tags":[{"name":"data structures","slug":"data-structures","permalink":"https://vanessayaoyao.github.io/tags/data-structures/"}]},{"title":"Java Part 3 - Advanced Topics","slug":"learning-java-3","date":"2022-01-21T15:52:29.000Z","updated":"2022-01-29T14:52:19.334Z","comments":true,"path":"2022/01/21/learning-java-3/","link":"","permalink":"https://vanessayaoyao.github.io/2022/01/21/learning-java-3/","excerpt":"","text":"[toc] Advanced Java FeaturesExceptionsthe stack trace in reverse order Types of Exceptions Checked eg.读取文件时,应该预测到文件不存在时怎么办 Unchecked or Runtime Exceptions NullPointerException 指针异常，传入空值 ArithmeticException 算术异常，除以0 IllegalArgumentException 传入非法参数 IndexOutofBoundsException 索引越界 IllegalStateException the underlying object is not in the right state Error an error external to our application 堆叠溢出 内存溢出 Exceptions Hierarchy Catching Exceptions12345678910public void show()&#123; try &#123; FileReader reader = new FileReader(&quot;file.txt&quot;); System.out.println(&quot;File opened&quot;); &#125;catch (FileNotFoundException ex)&#123; System.out.println(&quot;File does not exist.&quot;); System.out.println(ex.getMessage()); //file.txt (系统找不到指定的文件。) &#125;&#125; trick: alt+enter→Surround with try/catch Catching Multiple Types of Exceptions123456789101112try &#123; FileReader reader = new FileReader(&quot;file.txt&quot;); int value = reader.read();&#125;catch (FileNotFoundException e)&#123; System.out.println(e.getMessage());&#125;catch (IOException e)&#123; System.out.println(&quot;Could not read data.&quot;);&#125;try&#123; &#125;catch(IOException | ParseException e)&#123;&#125; The finally Block12345678910111213141516FileReader reader = null;try &#123; reader = new FileReader(&quot;file.txt&quot;); int value = reader.read();&#125;catch (IOException e)&#123; System.out.println(&quot;Could not read data.&quot;);&#125;finally &#123; //ugly if(reader!=null) &#123; try &#123; reader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; The try-with-resources Statement123456789try( FileReader reader = new FileReader(&quot;file.txt&quot;); ....//other object) &#123; int value = reader.read();&#125;catch (IOException e)&#123; System.out.println(&quot;Could not read data.&quot;);&#125;//与上面代码效果相同，不用写finally不用关文件.automatically Throwing Exceptions12345public void deposit(float value)&#123; if (value&lt;=0) throw new IllegalArgumentException(); //defensive programming&#125; 1234567891011public void deposit(float value) throws IOException&#123; if (value&lt;=0) throw new IOException();&#125;Account account = new Account();try &#123; account.deposit(1);&#125; catch (IOException e) &#123; e.printStackTrace();&#125; Re-throwing Exceptions1234567891011121314public static void main(String[] args) throws IOException &#123; Account account = new Account(); try &#123; account.deposit(1); &#125; catch (IOException e) &#123; System.out.println(&quot;Logging&quot;); throw e; &#125;&#125;try&#123; ...&#125; catch(Throwable e)&#123; System.out.println(&quot;error occcured.&quot;);&#125; Custom Exception自定义异常 12345678910111213141516//checked -&gt;Exception//unchecked(runtime) -&gt;RuntimeExceptionpublic class InsufficientFundsException extends Exception &#123; public InsufficientFundsException()&#123; System.out.println(&quot;Insufficient funds in your account&quot;); &#125; public InsufficientFundsException(String message)&#123; super(message); &#125;&#125;public void withdraw(float value) throws InsufficientFundsException &#123; if (value&gt;balance) throw new InsufficientFundsException();&#125; Chaining Exceptions12345678public void withdraw(float value) throws AccountException &#123; if (value&gt;balance)&#123; InsufficientFundsException fundsException = new InsufficientFundsException(); AccountException accountException = new AccountException(); accountException.initCause(fundsException); throw accountException; &#125;&#125; 1234567891011public class AccountException extends Exception&#123; public AccountException(Exception cause)&#123; super(cause); &#125;&#125;public void withdraw(float value) throws AccountException &#123; if (value&gt;balance)&#123; AccountException accountException = new AccountException(new InsufficientFundsException()); throw accountException; &#125;&#125; Generics泛型 1234public class List&#123; private Object[] items = new Objects[10]; //Object class is the parent of all reference types&#125; Generic Classes1234567891011121314public class GenericList&lt;T&gt; &#123; private T[] items = (T[]) new Object[10]; private int count; public void add(T item)&#123; items[count++] = item; &#125; public T get(int index)&#123; return items[index]; &#125;&#125;GenericList&lt;Integer&gt; list = new GenericList&lt;&gt;();list.add(1); Generics and Primitive Typesint -&gt; Integer float -&gt; Float boolean -&gt; Boolean 123GenericList&lt;Integer&gt; numbers = new GenericList&lt;&gt;();numbers.add(1); //Boxingint number = numbers.get(0); //Unboxing Constraints123456public class GenericList&lt;T extends Number&gt; &#123; // wrapper class of Interger Float Short...&#125;public class GenericList&lt;T extends Comparable &amp; Cloneable&gt; &#123; &#125; Type Erasure类型消除 Java compiler erases these type parameters and replaces them with a class or an interface depending on the constraints. The Comparable Interface12345678910111213141516public class User implements Comparable&lt;User&gt;&#123; private int points; public User(int points) &#123; this.points = points; &#125; @Override public int compareTo(User other) &#123; // this &lt; other -&gt; -1 // this == other -&gt; 0 // this &gt;other -&gt; 1 return points - other.points; &#125;&#125;user1.compareTo(user2) // &gt;&lt; 大于号小于号只能比较数字和字符 Generic Methods12345public class Utils &#123; public static &lt;T extends Comparable&lt;T&gt;&gt; T max(T first, T second)&#123; return (first.compareTo(second) &gt; 0) ? first : second; &#125;&#125; Multiple Type Paramaters123456789public class Utils &#123; public static &lt;K, V&gt; void print(K key, V value)&#123; System.out.println(key + &quot;=&quot; + value); &#125;&#125;public class KeyValuePair&lt;K, V&gt;&#123; private K key; private V value;&#125; Generic Classes and Inheritanceinstructor extends user printUsers GenericList&lt;Instructor&gt;不能调用printUsers Wildcards12345678// class CAP#1 extends User &#123;&#125;// class Instructor extends User &#123;&#125;public static void printUsers (GenericList&lt;? extends User&gt; users)&#123;//read // super add User x = users.get(0);&#125;Utils.printUsers(new GenericList&lt;Instructor&gt;()) CollectionsCollections Framework queue 队列 set无重复 The Iterables Interface we can iterate or loop over it. 123456public class GenericList&lt;T&gt; implements Iterable&lt;T&gt;&#123; @Override public Iterator&lt;T&gt; iterator() &#123; return null; //not finished yet &#125;&#125; 123456789GenericList&lt;String&gt; list = new GenericList&lt;&gt;();// Iterator iterator = list.iterator();// while(iterator.hasNext())&#123;// Object current = iterator.next();// System.out.println(current);// &#125;for(Object item: list) System.out.println(item);&#125; The Iterator Interface12345678910111213141516171819202122232425262728293031323334public class GenericList&lt;T&gt; implements Iterable&lt;T&gt;&#123; private T[] items = (T[]) new Object[10]; private int count; public void add(T item)&#123; items[count++] = item; &#125; public T get(int index)&#123; return items[index]; &#125; @Override public Iterator&lt;T&gt; iterator() &#123; return new ListIterator(this); &#125; private class ListIterator implements Iterator&lt;T&gt;&#123; private GenericList&lt;T&gt; list; private int index; public ListIterator(GenericList&lt;T&gt; list) &#123; this.list = list; &#125; @Override public boolean hasNext() &#123; return (index &lt; list.count); &#125; @Override public T next() &#123; return list.items[index++]; &#125; &#125;&#125; The Collection Interfaceadd() remove() contains() E–&gt; elements 1234567891011121314151617public class CollectionsDemo &#123; public static void show()&#123; Collection&lt;String&gt; collection = new ArrayList&lt;&gt;(); collection.add(&quot;a&quot;); collection.add(&quot;b&quot;); collection.add(&quot;c&quot;); //或者 Collections.addAll(collection, &quot;a&quot;,&quot;b&quot;,&quot;c&quot;); collection.remove(&quot;a&quot;); for(String item: collection) System.out.println(item); collection.clear(); collection.isEmpty();//true or false collection.contains(&quot;a&quot;);//true or false collection.toArray(new String[3]);//或者String[0] &#125;&#125; 1234Collection&lt;String&gt; other = new ArrayList&lt;&gt;();other.addAll(collection);collection == other; // falsecollection.equals(other); //true The List Interfacesequence 序列 index 123456789101112 List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;a&quot;);list.add(&quot;b&quot;);list.add(0,&quot;!&quot;);System.out.println(list); //[!,a,b]Collections.addAll(list,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);list.get(0);list.set(0,&quot;a+&quot;);list.remove(0);list.indexOf(&quot;a&quot;);//第一次出现的索引list.lastIndexof(&quot;a&quot;);list.subList(0,2);//[a,b] 原list不受影响 The Comparable Interfacehow to sort data 1234567891011121314151617public class Customer implements Comparable&lt;Customer&gt; &#123; private String name; public Customer(String name) &#123; this.name = name; &#125; @Override public int compareTo(Customer other) &#123; return name.compareTo(other.name); &#125; @Override public String toString() &#123; return name; &#125;&#125; 123456List&lt;Customer&gt; customers = new ArrayList&lt;&gt;();customers.add(new Customer(&quot;c&quot;));customers.add(new Customer(&quot;d&quot;));customers.add(new Customer(&quot;a&quot;));Collections.sort(customers);System.out.println(customers); //[a,c,d] The Comparator Interface12345678910111213public class EmailComparator implements Comparator&lt;Customer&gt; &#123; @Override public int compare(Customer o1, Customer o2) &#123; return o1.getEmail().compareTo(o2.getEmail()); &#125;&#125;List&lt;Customer&gt; customers = new ArrayList&lt;&gt;();customers.add(new Customer(&quot;c&quot;,&quot;e3&quot;));customers.add(new Customer(&quot;d&quot;,&quot;e2&quot;));customers.add(new Customer(&quot;a&quot;,&quot;e1&quot;));Collections.sort(customers, new EmailComparator());//[a,d,c]System.out.println(customers); The Queue Interfacecollection situation we want to process jobs based on the order we receive them 打印机 PriorityQueue ArrayDeque 123456789101112public static void main(String[] args) &#123; Queue&lt;String&gt; queue = new ArrayDeque&lt;&gt;(); queue.add(&quot;c&quot;); queue.add(&quot;a&quot;); queue.add(&quot;b&quot;); // queue.offer(&quot;d&quot;); // b-&gt;a-&gt;c String front = queue.peek(); System.out.println(front); // c queue.remove(); // c queue.poll(); // null&#125; The Set Interface唯一值 123456Set&lt;String&gt; set = new HashSet&lt;&gt;();set.add(&quot;sky&quot;);set.add(&quot;sky&quot;);set.add(&quot;is&quot;);set.add(&quot;bule&quot;);System.out.println(set); // [sky, bule, is] 去重 1234Collection&lt;String&gt; collection = new ArrayList&lt;&gt;();Collections.addAll(collection,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;);Set&lt;String&gt; set = new HashSet&lt;&gt;(collection);System.out.println(set); // [a,b] 12345678Set&lt;String&gt; set1 = new HashSet&lt;&gt;(Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;));Set&lt;String&gt; set2 = new HashSet&lt;&gt;(Arrays.asList(&quot;b&quot;,&quot;c&quot;,&quot;d&quot;));// Unionset1.addAll(set2); // set1 [a,b,c,d]//Intersectionset1.retainAll(set2); // [b,c]// Differenceset1.removeAll(set2); // [a] Hash TablesJava: Maps C#: Dictionary Python: Dictionary JavaScript: Objects The Map Interface123456789101112131415161718192021Customer c1 = new Customer(&quot;a&quot;, &quot;e1&quot;);Customer c2 = new Customer(&quot;b&quot;, &quot;e2&quot;);Map&lt;String, Customer&gt; map = new HashMap&lt;&gt;(); // not iterablemap.put(c1.getEmail(),c1);map.put(c2.getEmail(),c2);Customer customer = map.get(&quot;e1&quot;);System.out.println(customer); // a nullCustomer unknown = new Customer(&quot;Unknown&quot;,&quot;&quot;);map.getOrDefault(&quot;e10&quot;, unknown);Boolean exists = map.containsKey(&quot;e10&quot;);map.replace(&quot;e1&quot;, new Customer(&quot;a++&quot;,&quot;e1&quot;));for (String key: map.keySet())&#123; System.out.println(key);&#125;for (Map.Entry&lt;String, Customer&gt; key: map.entrySet())&#123; System.out.println(key); // e1=a e2=b // key.getValue()&#125;//map.values() Lambda Expressions and Functional InterfacesFunctional Interfaces An interface with a single abstract method 123456789101112131415161718public interface Printer &#123; void print(String message);&#125;public class ConsolePrinter implements Printer&#123; @Override public void print(String message) &#123; System.out.println(message); &#125;&#125;public class LambdasDemo &#123; public static void show()&#123; greet(new ConsolePrinter()); &#125; public static void greet(Printer printer)&#123; printer.print(&quot;Hello World&quot;); &#125;&#125; Anonymous Inner Class匿名内部类 12345678public static void show()&#123; greet(new Printer() &#123; @Override public void print(String message) &#123; System.out.println(message); &#125; &#125;);&#125; Lambda Expressions123456789public static void show()&#123; greet(( String message) -&gt;&#123; System.out.println(message); &#125;); // or in a more clear way greet(message -&gt; System.out.println(message));&#125;Printer printer = message -&gt; System.out.println(message); // an objectPrinter printer = new ConsolePrinter(); Variable Capture1234public static void show()&#123; String prefix = &quot;-&quot;; greet(message -&gt; System.out.println( prefix+message));&#125; Method References1234greet(message -&gt; System.out.println(message));//Class/Object::methodgreet(System.out::println);//equal 123456789101112public static void print(String message)&#123;&#125;public static void show()&#123; greet(message -&gt; print(message)); greet(LambdasDemo::print);&#125;public void print(String message)&#123;&#125;public static void show()&#123; LambdasDemo demo = new LambdasDemo(); greet(message -&gt; demo.print(message)); greet(demo::print);&#125; 12345public LambdasDemo(String message) &#123;&#125;public static void show()&#123; greet(message -&gt; new LambdasDemo(message)); greet(LambdasDemo::new);&#125; Build-in Functional Interfacesfour types of functional interfaces Consumer void consume(obj) Supplier obj supply() Function obj map(obj) Predicate bool test(condition) The Consumer Interface123456789public static void show()&#123; List&lt;Integer&gt; list = Arrays.asList(1,2,3); // Imperative Programming(for, if/else, switch/case) for(int item: list)&#123; System.out.println(item); &#125; //Declarative Programming list.forEach(System.out::println);&#125; Chaining Consumers1234567public static void show()&#123; List&lt;String&gt; list = Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;); Consumer&lt;String&gt; print = System.out::println; Consumer&lt;String&gt; printUpperCase = item -&gt; System.out.println(item.toUpperCase()); list.forEach(print.andThen(printUpperCase)); // a A b B c C&#125; The Supplier Interface12345public static void show()&#123; Supplier&lt;Double&gt; getRandom = Math::random; // () -&gt; Math.random(); double random = getRandom.get(); System.out.println(random);&#125; The Function Interface12345public static void show()&#123; Function&lt;String, Integer&gt; map = str -&gt; str.length(); int length = map.apply(&quot;Sky&quot;); System.out.println(length);&#125; Composing Function12345678910111213public static void show()&#123; // &quot;key: value&quot; // first: &quot;key=value&quot; // second: &quot;&#123;key=value&#125;&quot; Function&lt;String, String&gt; replaceColon = str -&gt; str.replace(&quot;:&quot;,&quot;=&quot;); Function&lt;String, String&gt; addBraces = str -&gt; &quot;&#123;&quot; + str + &quot;&#125;&quot;; //Declarative Programming String result = replaceColon .andThen(addBraces) .apply(&quot;key:value&quot;); result = addBraces.compose(replaceColon).apply(&quot;key:value&quot;); System.out.println(result);&#125; The Predicate Interface12345public static void show()&#123; Predicate&lt;String&gt; isLongerThan5 = str -&gt; str.length() &gt; 5; boolean result = isLongerThan5.test(&quot;sky&quot;); System.out.println(result);&#125; Combining Predicates123456public static void show()&#123; Predicate&lt;String&gt; hasLeftBrace = str -&gt; str.startsWith(&quot;&#123;&quot;); Predicate&lt;String&gt; hasRightBrace = str -&gt; str.endsWith(&quot;&#125;&quot;); // and() or() negate() Predicate&lt;String&gt; hasLeftAndRightBraces = hasLeftBrace.and(hasRightBrace); &#125; The BinaryOperator Interface12345public static void show()&#123; BinaryOperator&lt;Integer&gt; add = (a,b) -&gt;a+b; Function&lt;Integer,Integer&gt; square = a -&gt; a * a; int result = add.andThen(square).apply(1,2);&#125; The UniaryOperator Interface12345public static void show()&#123; UnaryOperator&lt;Integer&gt; square = n -&gt; n * n; UnaryOperator&lt;Integer&gt; increment = n -&gt; n + 1; int result = increment.andThen(square).apply(1);&#125; Streams To process a collection of data in a declarative way // functional programming Imperative vs Functional Programming Imperative Declarative How What SQL select * from movies where genre = 1 order by name A sream is a sequence of objects but it’s not like a collection it doesn’t store data. It’s just a way to get data out of a collection. 1234567// Imperative Programming howint count = 0;for(Movie movie : movies) if (movie.getLikes() &gt; 10) count++;// Declarative (Functional) Programming long count2 = movies.stream().filter(movie -&gt; movie.getLikes() &gt; 10).count(); Creating a Stream From collections Collection&lt;Integer&gt; x; From arrays var list = new ArrayList&lt;&gt;(); int [] numbers = {1,2,3}; Arrays.stream(numbers).forEach(n -&gt; System.out.println(n)) **From an arbitrary number of objects ** Stream.of(1,2,3,4) 123456public static void show()&#123; Stream stream = Stream.generate(()-&gt;Math.random()); //lazy evaluation stream.limit(3).forEach(n -&gt; System.out.println(n)); // terminates this streams&#125; Infinite/finite streams 1Stream.iterate(1, n -&gt; n+1).limit(10).forEach(n -&gt; System.out.println(n)); Mapping Elements map() flatMap() Stream&lt;List&lt;x&gt;&gt; -&gt; Stream&lt;x&gt; 12movies.stream().map(movie -&gt; movie.getTitle()) .forEach(name-&gt; System.out.println(name)); 123Stream stream = Stream.of(List.of(1,2,3),List.of(4,5,6));stream.forEach(list -&gt; System.out.println(list)); // [1,2,3] [4,5,6] stream.flatMap(list -&gt; list.stream()).forEach(n -&gt; System.out.println(n)); //1 2 3 4 5 6 Filtering Elements Intermediate Terminal map() filter() limit()/skip() sorted() distinct() peek() forEach() Reducers Slicing a Stream“a” “b” “c” limit(n) limit(2) a b skip(n) skip(2) c 1000 movies 10 movies per page 3rd page skip(20) = skip((page-1) * pageSize) limit(10) = limit(pageSize) takeWhile(predicate) takeWhile(m-&gt;m.getLikes() &lt;30) 遇到即停止 dropWhile(predicate) Sorting Streams12345movies.stream() .sorted((a,b) -&gt; a.getTitle().compareTo(b.getTitle())) .sorted(Comparator.comparing(m-&gt;m.getTitle()).reversed())//逆序 //Movie::getTitle .forEach(m-&gt;System.out.println(m)); Getting Distinct Elements1234movies.stream() .map(Movie::getLikes) .distinct() .forEach(System.out::println); Peeking Elements123456movies.stream() .filter(m-&gt;m.getLikes()&gt;10) .peek(m-&gt;System.out.println(&quot;filtered:&quot;+m.getTitle())) .map(Movie::getTitle) .peek(t-&gt;System.out.println(&quot;mapped:&quot;+t)) .forEach(System.out::println); Simple Reducers count(n) anyMatch(predicate) .anyMatch(m-&gt;m.getLikes()&gt;20) true or false allMatch(predicate) noneMatch(predicate) findFrist() return Optional&lt;Movie&gt; findAny() max(comparator) .max(Comparator.comparing(Movie::getLikes)).get() min(comparator) Reducing a Stream12345Optional&lt;Integer&gt; sum = movies.stream() .map(m-&gt;m.getLikes()) //[10,20,30] .reduce((a+b)-&gt;a+b); // [30,30] -&gt; [60] // .reduce(Integer::sum)sum.orElse(0); //60 Collectorscollect the result of a stream into data structure 1234567List&lt;Movie&gt; result = movies.stream() .filter(m-&gt;m.getLikes(&gt;10)) .collect(Collectors.toList()); //.toSet() //.toMap(Movie::getTitle, Movie::getLikes) &#123;b=20,c=30&#125; //.toMap(Movie::getTitle, Function.identity( )) //.summingInt(Movie::getLikes) //.summarizingInt(Movie::getLikes ) statistics 123movies.stream() .map(Movie::getTitle) .collect(Collectors.joining(&quot;,&quot;)); // a,b,c Grouping Elements123456789101112131415public enum Genre &#123; COMEDY, ACTION, THRILLER&#125;List&lt;Movie&gt; movies = Arrays.asList( new Movie(&quot;a&quot;,1, Genre.THRILLER ), new Movie(&quot;b&quot;,2, Genre.ACTION), new Movie(&quot;c&quot;,3, Genre.ACTION));Map&lt;Genre,List&lt;Movie&gt;&gt; result = movies.stream(). collect(Collectors.groupingBy(Movie::getGenre)); // (, Collectors.counting()) &#123;THRILLER=1, ACTION=2&#125;System.out.println(result);// &#123;ACTION=[com.company.streams.Movie@5b480cf9, com.company.streams.Movie@6f496d9f], THRILLER=[com.company.streams.Movie@723279cf]&#125; Partitioning Elements分区 12345Map&lt;Boolean, String&gt; result = movies.stream() .collect(Collectors.partitioningBy( movie -&gt; movie.getLikes()&gt;20, Collectors.mapping(Movie::getTitle, Collectors.joining(&quot;,&quot;)) )); // &#123;false=a, b, true=c&#125; Primitive Type Streams IntStream .rangeClosed(1,5) 1,2,3,4,5 .range(1,5) 1,2,3,4 LongStream DoubleStream Concurrency and Muti-threadingProcesses and Threads进程和线程 A process is an instance of a program or an applocation. When you launch an application like your code editor or music player, your operating system loads that application inside a process, so a process contains an image of the application code. It has some memory and a bunch of other resources. A thread is a sequence of instructions, actually that thing that executes your code Each process has at least one thread called the main thread. 1234System.out.println(Thread.activeCount()); // 2 One is the mian thread running the main method, the other is a background thread that runs the garbage collectorSystem.out.println(Runtime.getRuntime().availableProcessors());// 8 4核8线程 Starting a Thread123456public class DownloadFileTask implements Runnable&#123; @Override public void run() &#123; System.out.println(&quot;Downloading a file: &quot;+Thread.currentThread().getName()); &#125;&#125; 1234567public static void show()&#123; System.out.println(Thread.currentThread().getName()); Thread thread = new Thread(new DownloadFileTask()); thread.start();&#125;// main// Downloading a file: Thread-0 1234for(int i=0; i&lt;10;i++) &#123; Thread thread = new Thread(new DownloadFileTask()); thread.start();&#125; Downloading a file: Thread-2Downloading a file: Thread-3Downloading a file: Thread-0Downloading a file: Thread-1Downloading a file: Thread-4Downloading a file: Thread-5Downloading a file: Thread-6Downloading a file: Thread-7Downloading a file: Thread-9Downloading a file: Thread-8 at same time parallel Pausing a Thread123456789101112public class DownloadFileTask implements Runnable&#123; @Override public void run() &#123; System.out.println(&quot;Downloading a file: &quot;+Thread.currentThread().getName()); try &#123; Thread.sleep(5000); //暂停5秒 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;Download complete: &quot; + Thread.currentThread().getName()); &#125;&#125; Joining Threads下载完文件后，启动另一个线程来扫描下载文件的病毒。 123456789101112public static void show()&#123; System.out.println(Thread.currentThread().getName()); Thread thread = new Thread(new DownloadFileTask()); thread.start(); try &#123; thread.join(); //使用join tell the current thread to wait for the complection for another thread. &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;File is ready to be scanned.&quot;);&#125; Interrupting a Thread取消功能 1234567891011thread.interrupt();// 发送中断请求，不会强制中断public void run() &#123; System.out.println(&quot;Downloading a file: &quot;+Thread.currentThread().getName()); for(int i=0;i&lt;Integer.MAX_VALUE;i++)&#123; // 判断是否被中断 if(Thread.currentThread().isInterrupted()) return; System.out.println(&quot;Downloading byte &quot;+i); &#125; System.out.println(&quot;Download complete: &quot; + Thread.currentThread().getName());&#125; Concurrency IssuesIf multiple threads try to change the same data If changes are not visibe to other threads Thread-safe Code Race Conditions12345678910public class DownloadStatus &#123; private int totalBytes; public int getTotalBytes() &#123; return totalBytes; &#125; public void incrementTotalBytes()&#123; totalBytes++; // non-atomic operation &#125;&#125; 12345678910111213141516171819public static void show()&#123; DownloadStatus status = new DownloadStatus(); List&lt;Thread&gt; threads = new ArrayList&lt;&gt;(); // 十个下载任务 一个下载一万byte -&gt; 100_000 for(int i = 0; i&lt;10; i++)&#123; Thread thread = new Thread(new DownloadFileTask(status)); thread.start(); threads.add(thread); &#125; for (Thread thread : threads) &#123; try &#123; thread.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(status.getTotalBytes()); // but just 89384 会change &#125; Strategies for Thread Safety Confinement 约束 Immutability 不变 Synchronization 同步 lock wait for each other: deadlock Atomic objects 原子类 Partitioning Confinement每条Thread都有Status not modify a shared object 1234private DownloadStatus status;public DownloadFileTask() &#123; this.status = new DownloadStatus();&#125; 12345678910111213141516171819202122public static void show()&#123; List&lt;Thread&gt; threads = new ArrayList&lt;&gt;(); List&lt;DownloadFileTask&gt; tasks = new ArrayList&lt;&gt;(); for(int i = 0; i&lt;10; i++)&#123; DownloadFileTask task = new DownloadFileTask(); tasks.add(task); Thread thread = new Thread(task); thread.start(); threads.add(thread); &#125; for (Thread thread : threads) &#123; try &#123; thread.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; Optional&lt;Integer&gt; result = tasks.stream().map(t -&gt; t.getStatus().getTotalBytes()) .reduce(Integer::sum); System.out.println(result); //100_000 &#125; Locks12345678910111213141516public class DownloadStatus &#123; private int totalBytes; private Lock lock = new ReentrantLock(); public int getTotalBytes() &#123; return totalBytes; &#125; public void incrementTotalBytes()&#123; lock.lock(); //上锁 try&#123; totalBytes++; &#125;finally &#123; lock.unlock(); //解锁 &#125; &#125;&#125; The Synchronished Keyword1234567891011121314151617public class DownloadStatus &#123; private int totalBytes; private int totalFiles; private Object totalBytesLock = new Object(); private Object totalFilesLock = new Object(); public void incrementTotalBytes()&#123; synchronized (totalBytesLock) &#123; totalBytes++; &#125; &#125; public void incrementTotalFiles()&#123; // 也可以使用 synchronized modifier 但不建议 synchronized (totalFilesLock)&#123; // 也可以使用 this 但不建议 totalFiles++; &#125; &#125;&#125; The Volatile Keyword 1private volatile boolean isDone; //unstable read it form the main memory change will be immediately written to the main memory change is visible across threads Thread Signalling12345678910111213// while loopsynchronized(status)&#123; try&#123; status.wait(); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125;&#125;status.done();synchronized(status)&#123; status.notifyAll();&#125; Atomic Objects123456789private AtomicInteger totalBytes = new AtomicInteger();public int getTotalBytes() &#123; return totalBytes.get();&#125;public void incrementTotalBytes()&#123; synchronized (totalBytesLock) &#123; totalBytes.incrementAndGet(); //a++ &#125;&#125; compare and swap Adders123456789private LongAdder totalBytes = new LongAdder();public int getTotalBytes() &#123; return totalBytes.intValue(); // sum()&#125;public void incrementTotalBytes()&#123; synchronized (totalBytesLock) &#123; totalBytes.increment(); //a++ &#125;&#125; Synchronized Collections12345678910111213141516171819public static void shoe()&#123; Collection&lt;Integer&gt; collection = Collections.synchronizedCollection(new ArrayList&lt;&gt;()); Thread thread1 = new Thread(()-&gt;&#123; collection.addAll(Arrays.asList(1,2,3)); &#125;); Thread thread2 = new Thread(()-&gt;&#123; collection.addAll(Arrays.asList(4,5,6)); &#125;); thread1.start(); thread2.start(); // 存在竞争 try &#123; thread1.join(); thread2.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(collection);//[4,5,6,1,2,3]&#125; Concurrent Collections1Map&lt;Integer, String&gt; map = new ConcurrentHashMap&lt;&gt;(); The Executive FrameworkThread Manipulation Availability limited Cost Thread Pool -&gt; reuse Executors123456789101112public static void show()&#123; ExecutorService executor = Executors.newFixedThreadPool(2); // try for (int i = 0; i &lt; 10; i++ )&#123; executor.submit(() -&gt;&#123; System.out.println(Thread.currentThread().getName()); // pool-1-thread-2 pool-1-thread-1 ... &#125;); &#125; // finally executor.shutdown();&#125; Callables and Futures123456789public class LongTask &#123; public static void simulate()&#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 12345678910111213141516171819public static void show()&#123; ExecutorService executor = Executors.newFixedThreadPool(2); try &#123; Future&lt;Integer&gt; future = executor.submit(() -&gt; &#123; LongTask.simulate(); return 1; &#125;); System.out.println(&quot;Do more work&quot;); // immediately try &#123; Integer result = future.get(); System.out.println(result); // 3 sec later &#125; catch (InterruptedException | ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; finally &#123; executor.shutdown(); &#125;&#125; Asynchronous ProgrammingAsynchronous = Non-blocking Creating a Completable Futures12345678910public static void show()&#123; Supplier&lt;Integer&gt; task = ()-&gt; 1; CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(task); try &#123; Integer result = future.get(); System.out.println(result); // 1 &#125; catch (InterruptedException | ExecutionException e) &#123; e.printStackTrace(); &#125;&#125; Implementing an Asynchronous API1234567891011121314151617public class MailService &#123; public void send()&#123; LongTask.simulate(); System.out.println(&quot;Mail was sent.&quot;); // &#125; public CompletableFuture&lt;Void&gt; sendAsync()&#123; return CompletableFuture.runAsync(() -&gt; send()); &#125;&#125;MailService.send();print(&quot;Hello World&quot;);// 3秒后 &quot;Mail was sent.&quot; then &quot;Hello World&quot;MailService.send();print(&quot;Hello World&quot;);Thread.sleep(5000);// Immediately &quot;Hello World&quot; 3秒后 &quot;Mail was sent.&quot; Running Code on Completion12345678910111213public static void show()&#123; CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(()-&gt;1); future.thenRunAsync(() -&gt; &#123; System.out.println(Thread.currentThread().getName()); // ForkJoinPool.commonPool-worker-1 .theRun -&gt; main System.out.println(&quot;Done&quot;); &#125;); future.thenAccept(result -&gt; &#123; System.out.println(Thread.currentThread().getName()); System.out.println(result); &#125;);&#125; Handing Exceptions1234567891011public static void show()&#123; CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(()-&gt;&#123; System.out.println(&quot;Getting the current weather&quot;); throw new IllegalStateException(); &#125;); try &#123; future.exceptionally(ex -&gt; 1).get(); &#125; catch (InterruptedException | ExecutionException e) &#123; e.printStackTrace(); &#125;&#125; Transforming Results12345public static void show()&#123; CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(()-&gt;20); future.thenApply(celsius -&gt; (celsius * 1.8) +32) .thenAccept(f -&gt; System.out.println(f));&#125; Composing Complete Futures12345public static void show()&#123; CompletableFuture.supplyAsync(() -&gt; &quot;email&quot;) .thenCompose(email -&gt; CompletableFuture.supplyAsync(() -&gt; &quot;playlist&quot;)) .thenAccept(playlist -&gt; System.out.println(playlist));&#125; Combining Completable Futures12345678910public static void show()&#123; CompletableFuture&lt;Integer&gt; first = CompletableFuture.supplyAsync(() -&gt; &quot;20USD&quot;) .thenApply(str-&gt;&#123; String price = str.replace(&quot;USD&quot;, &quot;&quot;); return Integer.parseInt(price); &#125;); CompletableFuture&lt;Double&gt; second = CompletableFuture.supplyAsync(() -&gt; 0.9); first.thenCombine(second, (price, exchangeRate) -&gt; price* exchangeRate) .thenAccept(result -&gt; System.out.println(result));&#125; Waiting for Many Tasks123456789101112131415161718public static void show()&#123; CompletableFuture&lt;Integer&gt; first = CompletableFuture.supplyAsync(() -&gt; 1 ); CompletableFuture&lt;Integer&gt; second = CompletableFuture.supplyAsync(() -&gt; 2); CompletableFuture&lt;Integer&gt; third = CompletableFuture.supplyAsync(() -&gt; 3); CompletableFuture&lt;Void&gt; all = CompletableFuture.allOf(first,second,third); all.thenRun(() -&gt; &#123; try &#123; Integer firstResult = first.get(); System.out.println(firstResult); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;All tasks completed successfully&quot;); &#125;);&#125; Waiting for the First Task123456789public static void show()&#123; CompletableFuture&lt;Integer&gt; first = CompletableFuture.supplyAsync(() -&gt;&#123; LongTask.simulate(); return 20; &#125;); CompletableFuture&lt;Integer&gt; second = CompletableFuture.supplyAsync(() -&gt; 20); CompletableFuture.anyOf(first,second) .thenAccept(temp -&gt; System.out.println(temp));&#125; Handing Timeoutsfuture.completeOnTimeout(1,1,TimeUnit.SECONDS) Project。。。 完结撒花，但是还远远没有结束。。。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://vanessayaoyao.github.io/tags/java/"}]},{"title":"git 入门","slug":"learn-git","date":"2022-01-07T08:35:36.000Z","updated":"2022-01-19T02:53:31.988Z","comments":true,"path":"2022/01/07/learn-git/","link":"","permalink":"https://vanessayaoyao.github.io/2022/01/07/learn-git/","excerpt":"","text":"虽然之前在GitHub传过几个项目，但那都是用Pycharm的插件传的，我对git可以说是只见其声不见其人，根本不会用。 Git is officially defined as a distributed version control system (VCS). Learn GitInitializing a repository12$ git initInitialized empty Git repository in D:/helloworld/OtherProjects/Snake/.git/ 我这里有一个用原生JavaScript写的贪吃蛇小游戏（比着人家的视频写的） Checking the status1234567891011$ git statusOn branch masterNo commits yetUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) game.js index.htmlnothing added to commit but untracked files present (use &quot;git add&quot; to track) Staging files1$ git add game.js index.html 或者 1$ git add . 再次查看状态 123456789$ git statusOn branch masterNo commits yetChanges to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) new file: game.js new file: index.html Making commits12345$ git commit -m &quot;this is my first commit&quot;[master (root-commit) 1637404] this is my first commit 2 files changed, 196 insertions(+) create mode 100644 game.js create mode 100644 index.html 123$ git statusOn branch masternothing to commit, working tree clean Commit history1234567$ git logcommit 1637404a766dad9bb1bc5c7995261131c688f747 (HEAD -&gt; master)Author: VanessaYaoyao &lt;929228571@qq.com&gt;Date: Fri Jan 7 17:00:11 2022 +0800 this is my first commit go back to a previous state of your project code that you committed, you can use the following command: 1$ git checkout &lt;commit-hash&gt; go back to the latest commit (the newest version of our project code), you can type this command: 1$ git checkout master Creating a new branch1$ git branch &lt;new-branch-name&gt; Changing branches1$ git checkout &lt;branch-name&gt; Learn GitHubCreating a new GitHub repository点击左上角头像旁边的加号 Pushing our code to the GitHub repository1234567891011$ git remote add origin https://github.com/VanessaYaoyao/JavaScript-Snake.git$ git push -u origin masterEnumerating objects: 4, done.Counting objects: 100% (4/4), done.Delta compression using up to 8 threadsCompressing objects: 100% (4/4), done.Writing objects: 100% (4/4), 2.15 KiB | 735.00 KiB/s, done.Total 4 (delta 0), reused 0 (delta 0), pack-reused 0To https://github.com/VanessaYaoyao/JavaScript-Snake.git * [new branch] master -&gt; masterBranch &#x27;master&#x27; set up to track remote branch &#x27;master&#x27; from &#x27;origin&#x27;. Making changes to the GitHub repository1$ git push origin master Cloning an existing GitHub repository1$ git clone &lt;github-repo-link&gt; 现在估计就够我用的了。其他的用法以后用到的时候在学。 附：GitHub Quick setup","categories":[],"tags":[{"name":"code","slug":"code","permalink":"https://vanessayaoyao.github.io/tags/code/"}]},{"title":"Java Part 2 - OOP","slug":"learning-java-2","date":"2021-12-28T04:54:53.000Z","updated":"2022-01-22T12:28:41.704Z","comments":true,"path":"2021/12/28/learning-java-2/","link":"","permalink":"https://vanessayaoyao.github.io/2021/12/28/learning-java-2/","excerpt":"","text":"[toc] Object-oriented ProgrammingUltimate Java Part 2 - Object-oriented Programming | Code with Mosh The four principles of object-oriented programming are: Encapsulation : bundling the data and operations on the data inside a single unit (class). Abstraction : reducing complexity by hiding unnecessary details (metaphor: the implementation detail of a remote control is hidden from us. We only work with its public interface.) Inheritance : a mechanism for reusing code. Polymorphism : a mechanism that allows an object to take many forms and behave differently. This will help us build extensible applications. Getting StartedProgramming Paradigms ways or styles of writing code 编程范式 Precedural Functional Object-oriented Event-driven Logic Aspect-oriented Problem Solving Process of defining a problem, identifying and comparing different solutions, and picking the one that best solves that problem with respect to the context and constraints. Depends on the problem, context and budget. Benefits of OOP Reduced Complexity Easier Maintenance Code Reuse Faster Development ClassesClass and ObjectClass: A blueprint for creating objects Object: An instance of a class. UML: unified modeling language 123456789101112package com.company;public class TextBox &#123; //设置初始值，不设置则为null, very dangerous public String text = &quot;&quot;; //Field public void setText(String text)&#123; this.text = text; &#125; public void clear()&#123; text = &quot;&quot;; &#125;&#125; 1234567public class Main &#123; public static void main(String[] args) &#123; TextBox textBox1 = new TextBox(); //jdk10以上可用var, like js textBox1.setText(&quot;Box 1&quot;); System.out.println(textBox1.text);//Box 1 &#125;&#125; Memory Allocation内存分配 heap:堆 stack:栈 1234TextBox textBox1 = new TextBox();TextBOx textBox2 = textBox1;textBox2.setText(&quot;Hello World&quot;);System.out.println(textBox1.text);//Hello World What is the difference between stack and heap memory? How are they managed? Stack is used for storing primitive types (numbers, boolean and character) and variables that store references to objects in the heap. Variables stored in the stack are immediately cleared when they go out of scope (eg when a method finishes execution). Objects stored in the heap get removed later on when they’re no longer references. This is done by Java’s garbage collector. Garbage collection: automatically remove unused objects on the heap. Encapsulation Bundle the data and methods that operate on the data in a single unit.封装 Procedural Programming过程化编程 spaghetti code What are the problems of procedural code? How does object-oriented programming help solve these problems? Big classes with several unrelated methods focusing on different concerns and responsibilities. These methods often have several parameters. You often see the same group of parameters repeated across these methods. All you see is procedures calling each other passing arguments around. By applying object-oriented programming techniques, we extract these repetitive parameters and declare them as fields in our classes. Our classes will then encapsulate both the data and the operations on the data (methods). As a result, our methods will have fewer parameters and our code will be cleaner and more reusable. 1234567public class Employee &#123; public int baseSalary; public int hourlyRate; public int calculateWage(int extraHours)&#123; return baseSalary + (hourlyRate*extraHours); &#125;&#125; 12345678910public class Main &#123; public static void main(String[] args) &#123; Employee employee = new Employee(); employee.baseSalary = 50_000; //如果输入一个负数呢? 可以在主函数里写if else,but it&#x27;s not good. employee.hourlyRate = 20; int wage = employee.calculateWage(10); System.out.println(wage); &#125;&#125; Getters and Setters Why should we declare fields as private? How we store data in an object is considered an implementation detail. We may change how we store the data internally. Plus, we don’t want our objects to go into a bad state (hold bad data). That’s why we should declare fields as private and provide getters and or setters only if required. These setters can ensure our objects don’t go into a bad state by validating the values that are passed to them. 1234567891011public class Employee &#123; private int baseSalary; public void setBaseSalary(int baseSalary)&#123; if (baseSalary&lt;=0) throw new IllegalArgumentException(&quot;can&#x27;t be 0 or less.&quot;); this.baseSalary = baseSalary; &#125; public int getBaseSalary()&#123; return baseSalary; &#125;&#125; A trick: ask intellij to do it for us. press Alt+Enter apply Abstraction Reduce complexity by hiding unnecessary details. 抽象 给你一个遥控器，我们只需要知道如何换台，不需要知道按钮之下的电路如何运作。 As a metaphor, think of the remote control of your TV. All the complexity inside the remote control is hidden from you. It’s abstracted away. You just work with a simple interface to control your TV. We want our objects to be like our remote controls. Coupling The level of dependency between classes. 耦合 The more our classes are dependent on each other, the harder it is to change them. Changing one class may result in several cascading and breaking changes. Reducing coupling 123456789101112131415public class Browser &#123; //其他类只调用navigate这个函数 public void navigate(String address)&#123; String ip = findIpAddress(address); String html = sendHttpRequest(ip); System.out.println(html); &#125; //其他函数隐藏，即private private String sendHttpRequest(String ip) &#123; return &quot;&lt;html&gt;&lt;/html&gt;&quot;; &#125; private String findIpAddress(String address) &#123; return &quot;127.0.0.1&quot;; &#125;&#125; How does the abstraction principle help reduce coupling? By hiding the implementation details, we prevent other classes from getting affected when we change these details. For example, if the logic board and transistors inside a remote control change from one model to another, we’re not affected. We still use the same interface to work with our TV. Also, reducing these details and exposing fewer methods makes our classes easier to use. For example, remote controls with fewer buttons are easier to use. Constructors Constructors are called when we instantiate our class. We use them to initialize our objects. Initialization means putting an object into an early or initial state (eg giving it initial values). 12345678910public class Employee &#123; private int baseSalary; private int hourlyRate; //构造器，没有返回类型，名字与类名一致 public Employee(int baseSalary, int hourlyRate)&#123; setBaseSalary(baseSalary); setHourlyRate(hourlyRate); &#125; ...&#125; if we don’t create a constructor, the java compiler will automatically create one for us(the default constructor). Method Overloading Method overloading means declaring a method with the same name but with different signatures. The number, type and order of its parameters will be different. creating different implementations of it with different parameters. trick: ctrl+D to duplicate 123456public int calculateWage(int extraHours)&#123; return baseSalary + (getHourlyRate() *extraHours);&#125;public int calculateWage()&#123; return calculateWage(0) ;&#125; be aware of it, but don’t overuse it. Constructor Overloading1234567public Employee(int baseSalary)&#123; this(baseSalary,0);&#125;public Employee(int baseSalary, int hourlyRate)&#123; setBaseSalary(baseSalary); setHourlyRate(hourlyRate);&#125; Static Members Static methods are accessible via classes, not objects. 1234567891011public class Employee()&#123; public static int numberOfEmployees; public static void printNumberOfEmployees&#123; //在里面调用其他函数，必须先创建实例 ... &#125; ...&#125;Employee.numberOfEmployees;//不用创实例，直接调用类System.out.print();//这就是调用的 static methodInteger.parseInt();//这也是 Refactoring to an Object-oriented Design重构代码 trick 1: ask intellij to refactor for us 鼠标点击函数名后，选择上方工具栏的Refactor→Refactor this→Move trick 2: ask intellij to generate something for us, such as a constructor 选择上方工具栏的Code→Genreate→Constructor 右击类名，find usages Inheritance 123456public class UIControl&#123; ...&#125;public class TextBox extends UIControl &#123; ...&#125; The Object Class12345TextBox box1 = new TextBox();TextBox box2 = new TextBox();System.out.println(box1.hashCode()); //356573597 relted to address//box1.equal(box2) false hashcode differentSystem.out.println(box1.toString()); //com,codewithmosh.TextBox@1540e19d package@hashcode(hexodecimal十六进制) Constructors and Inheritance12345678910111213//父类public UIcontrol(boolean isEnabled) &#123; this.isEnabled = isEnabled; System.out.println(&quot;UIControl&quot;);&#125;//子类public TextBox() &#123; super(true);//需要放在第一条 System.out.println(&quot;TextBox&quot;);&#125;TextBox box1 = new TextBox();//先输出UIControl后输出TextBox The super keyword is a reference to the base or parent class. We can use it to access the members (fields and methods) or call the constructors of the base class. In contrast, the this keyword returns a reference to the current object. Access Modifiers访问修饰符 public private protected How accessible is a field or method if it’s declared without an access modifier? If we omit the access modifier, the member will have the defaultaccess modifier which makes that member public in package. In otherwords, that member will be public in the package but private outside ofthe package. private fields and methods are not inherited by subclasses and they are not accessible outside of a class. protected: public in package and accessible by child classes in different packages hard to maintain the application Overriding MethodsMethod overriding means changing the implementation of an inherited method in a subclass. For example, we can override the equals() or hashCode() methods of the Object class. Method overloading means declaring a method with different signatures (different number, type and order of parameters). 1234@Override //an annotation telling java compilerpublic String toString()&#123; return text;&#125; What is the benefit of applying the @Override annotation when overriding a method? It signals the Java compiler that we’re overriding a method in the base class and this helps the compiler check our code for correctness. It will ensure the signature of the method in the subclass matches the on declared in the base class. Also, if we remove this method from the base class, the compiler will let us know and we can remove the method in the subclass as well. Upcasting and Downcasting123TextBox box = new TextBox();UIcontrol control = new UIcontrol(true);show(box1); //upcasting empty downcasting helloworld 12345678910public static void show(UIcontrol control)&#123; System.out.println(control);&#125;public static void show(UIcontrol control)&#123; if (control instanceof TextBox)&#123; var textBox = (TextBox)control; textBox.setText(&quot;Hello World&quot;); &#125; System.out.println(control);&#125; Comparing Objects1234var point1 = new Point(1,2);var point2 = new Point(1,2);point1 == point2 //falsepoint1.euqal(point2) //false 123456789@Overridepublic boolean equals(Object obj) &#123; if(this == obj) return true; if( !(obj instanceof Point)) return false; Point other = (Point)obj; return other.x == x &amp;&amp; other.y == y;&#125; trick: ask intellij to do it for us. PolymorphismEncapsulation Abstraction Inheritance Polymorphism 123456789101112//UIcontrolpublic void render()&#123;&#125; //empty//CheckBox@Overridepublic void render() &#123; System.out.println(&quot;render checkbox&quot;);&#125;//TextBox@Overridepublic void render() &#123; System.out.println(&quot;render textbox&quot;);&#125; 1234UIcontrol[] controls = &#123; new TextBox(), new CheckBox()&#125;;for( UIcontrol control:controls)&#123; control.render();&#125; Abstract Classes and Methods When do we use abstract classes? An abstract class is a partially-implemented (half-cooked) class. We cannot instantiate them. But we use them to share some common code across their subclasses. we cannot instantiate abstract class but only extend it. 123public abstract class UIcontrol &#123; public abstract void render();&#125; Class ‘CheckBox’ must either be declared abstract or implement abstract method ‘render()’ in ‘UIcontrol’. Can we have an abstract class without any abstract methods? Yes! An abstract class does not need abstract methods. But if we mark a method as abstract, we should mark the class as abstract as well. Final Classes and Methods When do we use final classes? Final classes cannot be inherited. We use them when we’ve made certain assumptions about a class and we want to prevent other classes extending our class and break those assumptions. we cannot extend final classes and we cannot override final methods. Deep Inheritance and HierarchiesDon’t create deep inheritance hierarchies. What is the diamond problem? The diamond problem happens in languages that support multiple inheritance. If two classes (B, C) derive from A and are also the parents of another class (D), we see a diamond. If the top class (A) declares a method (eg toString) and its children (B and C) override this method, it’s not clear which implementation will be inherited by D. Multiple Inheritancea class can have multiple parents Java does not support this feature. simple and robust. Interfaces We use interfaces to build loosely-coupled, extensible and testable applications. What is tightly-coupled code? Tightly-coupled code is code that is hard to change because there is a strong dependency between the entities (eg classes) in the code. Changing one class may result in several cascading, breaking changes in the code. Creating an Interface123public interface TaxCalculator &#123; double calculateTax();&#125; 123456789101112public class TaxCalculator2022 implements TaxCalculator&#123; private double taxableIncome; public TaxCalculator2022(double taxableIncome) &#123; this.taxableIncome = taxableIncome; &#125; @Override public double calculateTax()&#123; return taxableIncome * 0.3; &#125;&#125; Dependency Injection Dependency injection refers to passing or injecting dependencies of a class. Our classes should not instantiate their dependencies. 依赖注入 The separation of concerns: We need to separate creating an object and using it. Constructor Injection Setter Injection Method Injection Constructor Injection1234567public class TaxReport &#123; private TaxCalculator calculator; public TaxReport(TaxCalculator calculator)&#123; //only working with an interface this.calculator = calculator; &#125;&#125; progromming against interfaces 123456public class Main &#123; public static void main(String[] args) &#123; TaxCalculator2022 calculator2022 = new TaxCalculator2022(100_000); TaxReport report = new TaxReport(calculator2022); //pass or inject this calculator object &#125;&#125; dependency injection framework: pass these dependencies to our classes. Spring is one of the popular ones. Setter Injection123456public class TaxReport &#123; private TaxCalculator calculator; public void setCalculator(TaxCalculator calculator) &#123; this.calculator = calculator; &#125;&#125; 12345678910public class Main &#123; public static void main(String[] args) &#123; TaxCalculator2022 calculator2022 = new TaxCalculator2022(100_000); TaxReport report = new TaxReport(calculator2022); report.show(); //30000.0 report.setCalculator(new TaxCalculator2023()); report.show(); //0.0 &#125;&#125; Method Injection123456public class TaxReport &#123; public void show(TaxCalculator calculator)&#123; double tax = calculator.calculateTax(); System.out.println(tax); &#125;&#125; 1234TaxCalculator2022 calculator2022 = new TaxCalculator2022(100_000);TaxReport report = new TaxReport();report.show(calculator2022);report.show(new TaxCalculator2023()); Interface Segregation Principle The Interface Segregation Principle (ISP) suggests that we should segregate or divide big, fat interfaces into smaller ones, each focusing on a single responsibility or capability. Smaller interfaces are less likely to change. Changes to one capability, will only affect a single interface and fewer classes that depend on that interface. divide big interfaces into smaller ones UIWidget Deaggable Resizable A interface can have multiple parents Why shouldn’t we declare fields, static or private methods in interfaces? Fields, static and private methods are all about implementation. Interfaces are contracts and should not have any implementation. Interface and Abstract Classes What are the similarities and differences between interfaces and abstract classes? Both are abstract concepts and we cannot instantiate them. Interfaces are contracts and should only have method declarations. Abstract classes are partially-implemented classes. We use them to share some common code across their derivates. The new features in Java allow writing code and logic in interfaces but this is a bad practice and should be avoided. When to use Interfaces Should we extract an interface from every class? Why? Blindly extracting interfaces doesn’t solve any problems nor is it considered a best practice. If you extract an interface from every single class, you’ll end up with an explosion of interfaces that don’t necessarily add any values. You should use interfaces in situations where you want to decouple a class from its dependencies so you can swap these dependencies. This allows building applications that are extensible and testable","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://vanessayaoyao.github.io/tags/java/"}]},{"title":"Java Part 1 - Fundamentals","slug":"learning-java","date":"2021-12-25T06:44:55.000Z","updated":"2022-01-22T11:05:00.393Z","comments":true,"path":"2021/12/25/learning-java/","link":"","permalink":"https://vanessayaoyao.github.io/2021/12/25/learning-java/","excerpt":"","text":"Java还是要学的 Fundamentals视频链接：Learning Java with Mosh Part One Anatomy of java program function 1234567891011ReturnType Name()&#123; ...&#125;void sendEmail()&#123; ...&#125;public class Main&#123; public void main()&#123; ... &#125;&#125; class: A container for related functions PascalNamingConvention→Classes camelNamingConvention→Methods How Java Code Gets Executed compilation→javac Main.class excution→java Mian Intellij hides that for us. TypesVariables primitive for storing simple values reference for storing complex objects 1234long viewsCount = 3_123_456_789L;float price = 10.99F;char letter = &#x27;A&#x27;;boolean isEligible = false; 1234567 byte x = 1; byte y = x;//改变x值y值不变Point point1 = new Point(1,1);Point point2 = point1;point1.x = 2;//point2的值也改变 Strings1234String message = &quot;Hello world&quot; + &quot;!!&quot;;message.length();//.出后看方法message.replace(&quot;target&quot;,&quot;replacement&quot;)message.trim()//去除前后空白（就像Python里的strip? In Java, Strings are immutable. return a new string Escape Sequences12345// Hello &quot;world&quot;String message = &quot;Hello \\&quot;world\\&quot;&quot;;// c:\\Windows\\..String message = &quot;c:\\\\windows\\\\..&quot;;//常用的还有\\n 和\\t Arrays1234567891011int[] numbers = new int[5];numbers[0] = 1;numbers[1] = 2;System.out.println(Arrays.toString(numbers));//[1,2,0,0,0]int[] numbers = &#123;2,3,4,1,4&#125;;System.out.println(numbers.length);//5Arrays.sort(numbers);System.out.println(Arrays.toString(numbers));//[1,2,3,4,4] In Java, arrays have a fixed size. Muti-dimensional Arrays123456int[][] numbers = new int[2][3];numbers[0][0]=1;System.out.println(Arrays.deepToString(numbers));//[[1, 0, 0], [0, 0, 0]]int[][] numbers = &#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;;//[[1, 2, 3], [4, 5, 6]] Constants1final float PI = 3.14F; Arithmetic Expressions1234567891011int result = 10/3;//3double result = (double)10/(double)3;//3.333333int x = 1;int y = x++;//x=2;y=1int x = 1;int y = ++x;//x=2,y=2x +=2; Casting1234567891011// Implicit casting// byte &gt; short &gt; int &gt; long &gt; float &gt; doubleshort x = 1;int y = x + 2;double x = 1.1;double y = x + 2;//2.0 // Explicit castingint y = (int)x + 2;String x = &quot;1&quot;;int y = Integer.parseInt(x) + 2; //3//Short.parseShort() Float.parseFloat()... The Math Class12345int result = Math.round(1.1F) //1int result = (int)Math.ceil(1.1F) //2int result = (int)Math.floor(1.1F) //1int result = Math.max(1,2) //2int result = (int)Math.round(Math.random()*100);//0-100随机数 Formatting Numbers123456NumberFormat currency = NumberFormat.getCurrencyInstance();String result = currency.format(1234567.891);//￥1,234,567.89NumberFormat percent = NumberFormat.getPercentInstance();String result = percent.format(0.1);//10% Reading Input123456789Scanner scanner = new Scanner(System.in);System.out.print(&quot;Age: &quot;);byte age = scanner.nextByte();//.nextFloat() .nextDouble()System.out.println(&quot;You are &quot;+age);String name = scanner.next();//Name: Vanessa Yao//You are Vanessa (空格后的词被丢失)String name = scanner.nextLine().trim();//You are Vanessa Yao Control FlowLogical Operators123456Scanner scanner = new Scanner(System.in);byte temperature = scanner.nextByte();boolean isWarm = (temperature &gt; 20) &amp;&amp; (temperature &lt; 30);// and(&amp;&amp;)第一个表达式为false时，java will ignore others.// or(||)第一个表达式为true时, java will ignore others.// not(!) If Statements12345678int temp &#x3D; 32;if(temp&gt;30)&#123; System.out.println(&quot;It&#39;s a hot day&quot;);&#125;else if(temp&gt;20)&#123;&#125;else&#123;&#125; simplifying if statement 12int income = 120_000;boolean hasHighIncome = (income &gt; 100_000); The Ternary Operator12int income = 120_000;String className = income &gt; 100_000 ? &quot;First&quot; : &quot;Economy&quot; Switch Statements1234567891011String role = &quot;admin&quot;;switch(role)&#123; case &quot;admin&quot;: System.out.println(&quot;You are an admin&quot;); break; case &quot;moderator&quot;: System.out.println(&quot;You are a moderator&quot;); break; default: System.out.println(&quot;You are a guest&quot;);&#125; For Loops123for(int i = 0; i&lt;5; i++)&#123; System.out.println(&quot;Hello world&quot;);&#125; While Loopsdon’t know how many times 1234567String input = &quot;&quot;;Scanner = scanner = new Scanner(System.in)while(!input.equals(&quot;quit&quot;))&#123; //不能用==，比较的是地址 System.out.print(&quot;Input: &quot;); input = scanner.next().toLowerCase(); System.out.println(input);&#125; Do…While Loopsat least once Break and Continue1234while(true)&#123; if(input.equals(&quot;quit&quot;)) break;&#125; For-Each Loop12345String[] fruits = &#123;&quot;Apple&quot;,&quot;Mango&quot;,&quot;Orange&quot;&#125;;for(String fruit : fruits)&#123; System.out.println(fruit);&#125;//只能从头到尾，not index 第一部分在油管上免费，讲的确实不错。第二部分和第三部分要收钱了。 哦吼，B站有人搬运，白嫖使我快乐。https://www.bilibili.com/video/BV19J411t7dD Object-oriented ProgrammingUltimate Java Part 2 - Object-oriented Programming | Code with Mosh Classes Refactoring Towards an Object-oriented Design Inheritance Interfaces Advanced TopicsUltimate Java Part 3: Advanced Topics | Code with Mosh Exceptions Generics泛型 Collections Lambda Expressions and Functional Interfaces Streams Concurrency and Multi-threading The Executive Framework","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://vanessayaoyao.github.io/tags/java/"}]},{"title":"Ajax初识","slug":"ajax","date":"2021-12-23T04:33:25.000Z","updated":"2021-12-29T00:15:46.908Z","comments":true,"path":"2021/12/23/ajax/","link":"","permalink":"https://vanessayaoyao.github.io/2021/12/23/ajax/","excerpt":"","text":"是啥AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML） AJAX 是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 我理解的就是前端用AJAX来请求接口 实例 一个小例子，点击按钮获得3条动物信息。 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JSON and AJAX&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;header&gt; &lt;h1&gt;JSON and AJAX&lt;/h1&gt; &lt;button id=&#x27;btn&#x27;&gt;Fetch Info for 3 New Animals&lt;/button&gt; &lt;/header&gt; &lt;div id=&#x27;animal-info&#x27;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&#x27;main.js&#x27;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031var pageCounter = 1;var animalContainer = document.getElementById(&quot;animal-info&quot;)var btn = document.getElementById(&quot;btn&quot;);//监听事件，当btn被点击时调用该匿名函数btn.addEventListener(&quot;click&quot;, function()&#123; //新建对象 var ourRequest = new XMLHttpRequest(); //用GET请求URL ourRequest.open(&quot;GET&quot;,&quot;https://learnwebcode.github.io/json-example/animals-&quot;+pageCounter+&quot;.json&quot;) //onload意为全部加载完后 ourRequest.onload = function()&#123; //转为JSON对象 var ourData = JSON.parse(ourRequest.responseText) renderHTML(ourData); &#125;; ourRequest.send() pageCounter++; if (pageCounter&gt;3) &#123; btn.classList.add(&quot;hide-me&quot;);//这里是点击三次后隐藏按钮，但我这好像不太管用 &#125;&#125;)function renderHTML(data)&#123; var htmlString = &#x27;&#x27;; for(var i=0;i&lt;data.length;i++)&#123; //数据展示 htmlString += &quot;&lt;p&gt;&quot;+data[i].name+&quot; is a &quot;+data[i].species +&quot;.&lt;/p&gt;&quot; &#125; animalContainer.insertAdjacentHTML(&quot;beforeend&quot;,htmlString)&#125; 到这里还和我看到别人用的ajax不太一样。我看的用法好像是$ajax(…)什么什么的，这好像是jquary的用法？ 未完待续。 2021/12/29 更新 VanillaJS是史上最轻量跨平台前端框架 ，我们能够使用它构建强大的JS应用。从过去到以后他都是最轻量的框架。因为vanillaJS的广受欢迎，所有的浏览器都已经内置这个框架了！ jQuery也是一个框架。 Vanilla JS 1234567var r = new XMLHttpRequest();r.open(&quot;POST&quot;, &quot;path/to/api&quot;, true);r.onreadystatechange = function () &#123; if (r.readyState != 4 || r.status != 200) return; alert(&quot;Success: &quot; + r.responseText);&#125;;r.send(&quot;banana=yellow&quot;); jQuery 1234567891011&lt;script src=&quot;//ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;$.ajax(&#123; type: &#x27;POST&#x27;, url: &quot;path/to/api&quot;, data: &quot;banana=yellow&quot;, success: function (data) &#123; alert(&quot;Success: &quot; + data); &#125;,&#125;);&lt;/script&gt;","categories":[],"tags":[{"name":"code","slug":"code","permalink":"https://vanessayaoyao.github.io/tags/code/"}]},{"title":"Redis初识","slug":"meet-redis","date":"2021-12-18T05:30:10.000Z","updated":"2021-12-18T06:51:06.166Z","comments":true,"path":"2021/12/18/meet-redis/","link":"","permalink":"https://vanessayaoyao.github.io/2021/12/18/meet-redis/","excerpt":"","text":"程序部有一回课是讲缓存的，但那天我睡过头了没上成。就对redis不怎么了解，也没具体应用过。 此事警醒我们不要睡过头！ 什么是Redis？Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 MySQL VS RedisMySQL是关系型数据库,主要用于存放持久化数据,将数据存储在硬盘中,读取速度较慢. Redis是NOSQL,即非关系型数据库,也是缓存数据库,即将数据存储在缓存中,缓存的读取速度快,能够大大的提高运行效率,但是保存时间有限. 缓存的必要网站访问的特点和现实世界的财富分配一样遵循二八定律：80% 的业务访问集中在20% 的数据上。既然大部分业务访问集中在一小部分数据上，那么如果把这一小部分数据缓存在内存中，就可以减少数据库的访问压力，提高整个网站的数据访问速度，改善数据库的写入性能了。 Redis 在django的使用下载首先要先下载Redis, 参考步骤：click this 1pip install django-redis redis 和 django-redis的区别，就像mysql和mysqlclient的区别。 我以前还以为下载django-redis就完事了呢，😓 settings.py里的配置复制一下github上官方文档的配置 123456789CACHES = &#123; &quot;default&quot;: &#123; &quot;BACKEND&quot;: &quot;django_redis.cache.RedisCache&quot;, &quot;LOCATION&quot;: &quot;redis://127.0.0.1:6379/1&quot;, &quot;OPTIONS&quot;: &#123; &quot;CLIENT_CLASS&quot;: &quot;django_redis.client.DefaultClient&quot;, &#125; &#125;&#125; 简单使用我有这么简简单单一张表 12345# models.pyclass Blog(models.Model): title = models.CharField(max_length=128) author = models.CharField(max_length=128) content = models.TextField() 我想实现：当用户访问一篇博客时，第一次访问从数据库里拿出来，放在缓存里。当用户再次访问时，不再进行数据库查询，使用缓存数据。 123456789101112131415161718192021#views.pyfrom django.core.cache import cachedef blog(request,id): dic = &#123;&#125; if request.method == &quot;GET&quot;: if cache.get(id): dic[&#x27;code&#x27;] = 200 dic[&#x27;msg&#x27;] = &quot;hit the cache&quot; dic[&#x27;data&#x27;] = BlogSerializer(cache.get(id)).data # cache.delete(id) else: dic[&#x27;code&#x27;] = 201 dic[&#x27;msg&#x27;] = &quot;hit the database&quot; blog = Blog.objects.get(id=id) cache.set(id, blog) #id为键，blog为值 dic[&#x27;data&#x27;] = BlogSerializer(blog).data else: dic[&#x27;code&#x27;] = 400 dic[&#x27;msg&#x27;] = &quot;wrong method&quot; return JsonResponse(dic) 第一次访问 再次访问 更多操作（如设置过期时间）可参考：django-redis","categories":[],"tags":[{"name":"code","slug":"code","permalink":"https://vanessayaoyao.github.io/tags/code/"}]},{"title":"英语、计算机与我","slug":"about-me","date":"2021-12-12T04:59:55.000Z","updated":"2022-01-19T03:34:50.950Z","comments":true,"path":"2021/12/12/about-me/","link":"","permalink":"https://vanessayaoyao.github.io/2021/12/12/about-me/","excerpt":"","text":"Thanks for your watching. Early Years我来自一个十八线小县城，上初中前没接触过英语，上大学前没接触过编程。 小学就在我们村里上的，上午上数学，下午上语文，体育课就是老师领着我们去操场上转两圈。没有英语课，更别说什么音乐课手工课的。对于小时候的我来说，日子过得平淡又快乐，没有什么糟心事，没有什么成绩排名，放学了就背着书包走着回家。这时还不知道能用双脚丈量的距离有多珍贵。可能偶尔烦恼就是，和我家在一个胡同的发小，她有好多好看的发卡，常常戴满了头发，而我没有，有时会嫉妒她哈哈。 上了初中就开始每周回一次家了，发小她之后对我说上了初中之后，她的童年就结束了，其实想想我也是。上小学的时候从来没有什么成绩排名，脑海里根本没有这个意识。上了初中就开始排名排名排名，但日子还算轻松。初一的时候认识的很多朋友，现在平时虽然不怎么联络，但在我心里她们已经是家人般的存在。下课的时候看看言情小说，和朋友打打闹闹，偶尔关心一下成绩排名，还早恋过，时间过得很快。有时会突然地恍惚，不知道现在是哪年哪月哪天，已经过去好久的事情仿佛就是昨天。 上了高中，曾经要好的朋友散落各地，也没有精力去结交新的朋友，我逐渐适应了一个人生活。一个人跑着去吃饭，很多时候都沉默寡言，没有话说，也没有什么表情。其实也没有什么很大的变化，我一直如此，懒得很，一个人的时间反而让我很自在。高中几乎都是学习了，学习学习学习，考上一个好大学。两周回家一次到最后一个月回家一次，一次在家的时间不超过二十四小时，一切照搬衡水中学的模式。 Why English忘记上高中的时候还是上初中的时候了，我有一段时间特别喜欢去校门口的书摊那买书，周一就把所有的零花钱就花光了。书摊上有许多三毛的书，我买来读过后，很是羡慕她。感觉三毛洒脱又自由，我也想这样。于是我就把北京十月出版社的三毛系列全买来读了一遍。三毛会好几种语言，西班牙语经常出现在她的书里，估计这就是我想读语言的由来吧，那时候一直给同学说我上大学要读西班牙语。现在这股读书的劲头早已消散，书买来也就是摆着。 恰巧高中的时候我英语的成绩还不错，一般考试成绩都在一百三以上，有次还上了一百四，不自觉便飘飘然，认为自己有学语言的天赋，自己就是学语言的天选之女，现在想想也是挺好笑的。那时候我还想着自己将来会去外交部，会穿着优雅知性的西装套裙站在国家领导人的背后，为他们翻译。谁还没有点梦想呢。哦不，是空想。在所有的课里，我最喜欢上的就是英语，感觉上的最轻松的也是英语，哪一次英语没有考好还会暗自神伤。但其实想想，我其实是被自己所营造的假象所欺骗了，我一直暗示自己，我的英语很好，我的英语很好，如此这般。 高考完后选专业，可想而知，我把所有学校的语言专业选了个遍，非语言专业不读。现在的我知道选语言专业不是一个好的决定，你所有的热情会被消磨殆尽，你会甚至讨厌英语，会不断怀疑自己。但对于当时的我来说，我也没有什么其他的选择，父母学识有限，给不了我很好的建议。所有的选择权都在我自己，其实完全是瞎选的，去知乎看了几篇帖子，草草地就结束了。我现在只能庆幸当时没有把北京第二外国语学院放在第一志愿，冲着海大985的名头选了海大。人呐，有时候还是要追名逐利一点的好（doge。 当时在知乎看了很多关于英语专业的问题，在B站也看了很多关于英语专业的视频分享，幻想着自己也能像他们这样，一口流利英语，结交各国好友，从此走上人生巅峰。但有个东西叫，幸存者偏差。我不自觉地忽视了一切不同的声音，只想看到自己看到的东西。哦对了，当时我还认为语言专业大三的时候都能出国交换的。那些出来分享的当然是过得还不错的，还有他们是北外或者上外的，沉默的大多数是没有话语权的。 进入大学，我给自己营造出的“我英语很好”的假象开始一点点瓦解。老师在专业课上指出我读音有问题；词汇量差的一批还不喜欢背单词；进入英表班，被非英语专业的同学吊打。人和人的差距真大呀。而且学英语的话还是要家境殷实一点的好，没有家庭支撑你想出去留学的话那等于胡闹。有钱啥时候都好啊，至少有选择的余地，有从头再来的底气。 英语当作兴趣那是极好的，但选英语专业我只能说是完全不必要的。英语这种专业啥样的大学都有，我不理解，除了北外上外的语言专业，其他学校的语言专业能不能不要开了。语言只是工具。没有其他技能的加持，真的很慌，真的没有底气。我一直很抵触说自己是英语专业的，感觉很难受或者说难为情。英语专业的英语不好哈哈。如果抱着当老师的想法那另当别论。至于我，我不想当老师，我当不好。 With code我和编程的起源，是我在大一下的时候选了一门课叫Python程序设计。那时候也不知道天高地厚，完全不知道Python是个什么东西，从来没接触过编程，但就是选了这门课。可以说这门课真的影响我很大吧。那时候还是疫情在家上网课，我就从什么都不会，不知道在哪输入字符。到慢慢有点思路，一耗两三个小时就是为了把一个练习题做出来。甚至还在班级群里回答其他同学的问题，虽然是用匿名。每成功一步都让我欣喜若狂、欢呼雀跃。这种心情是我上英语专业以来从未体会过的，真的从未体会到过。上了英语专业我就自动把自己归了底层一类，就忘记了自己也曾想当一个闪闪发光的人。 在大一下学期快结束的时候，我好像就在突然之间萌生了转到计算机专业的想法，这种想法只一瞬，但就像一粒种子，在我心中生了根发了芽，没过多久就长成了参天大树，无法动摇。想来人生也真是挺奇妙的，这样的事情最近又在我的人生中上演。人人都考研，但不考研的想法就不知何时飘进了我的脑中，这种想法愈演愈烈，让我做出了自己的决定。我不知道像这样的想法会将我的人生带向何处，但我知道它们已经改变了我的人生，我也期待着前方的路。 大二前的那个小学期我就没有选英语专业的课了，大二上学期的课完全照着计算机专业培养方案选的，兴高采烈等着加课。那天应该是一个星期一，我在院办值班，看到群里有人说加课结果出来了，我就打开看看自己的结果，结果为未通过。开始慌了。我早早下班了。出了外院门，我就给信院的教秘打电话。下午的课也直接翘掉了，直接去信院找教秘，教秘不管，又给系主任打电话。说是不给大二才转的加课。其实从看到结果的时候，我就知道再去找谁也不会改变什么了。现在想起来那天的经历还会觉得鼻头酸酸。在一个下午的时间里，我挣扎过，又很快接受了我不能改变的现状，马上去教务处加上了英语专业的课。只想毕业就好。 可能不能系统地学习计算机课程会有一点遗憾。有遗憾。但我现在也想开了。转过去的话，要补一年的课，每次选课都提心吊胆，还要面临延毕的焦虑，没有认识的朋友，估计也会很难熬。有时候会感觉老天在指引我的人生。之前的时候都能加课的，现在好像也能加课，就好巧没给我加课。我并没有“被安排”的感觉，要质问什么的，我只是觉得很奇妙。来到海大，大一下学了Python，就此产生转专业的想法，大二上凭着Python进了爱特程序部，到现在决定不考研毕业直接去找工作。一环扣一环，时间错开一点，我的人生估计又会有很大的不同。 Sophomore year and later转专业失败后，就回去继续上英语专业的课。上课就是等着下课，数着时间一点点过去。很长一段时间，我感觉我像被绑在一根绳上，两端都被紧紧拉着，没办法左移也没法右移，我也没法喘气。我想在课余时间里从“英语专业”里抽离出来去学点计算机相关的东西，但那些作业和数不清的展示又把我绑了回去。我又怂得很，不敢翘课，不敢不交作业，没有摆烂的勇气。躺平这个词还可以，我就任凭别人卷我，再卷我也不为所动，对很多事情也不太关心了。 比较幸运的事就是进入了爱特工作室，爱特是我唯一可以接触代码的地方。虽然我一直觉得自己像这个社团的“局外人”，我不是信院的，不爱玩游戏没什么共同话题，对技术的热爱也谈不上，但我一直很留恋在社团的时间，也从来没想过退出。爱特给了我一个平台，让我看到真正优秀的计算机大佬是什么样子的。写项目的过程，从什么都不会一个简单的东西查半天，到现在回望自己之前写的代码感觉像shit，我没学到了很多，但也确实是学到了很多。 爱特给了我成长，也给了我很多伤感emo的瞬间。我不记得我有多少个星期日的晚上，是垂头丧气回宿舍的。在看到别人的优秀后，我不知道我要怎么样才能追赶他们的脚步，我太垃圾了，太菜了。要学的东西太多了，会的东西太少了，和别人的差距太大了。现在我也时时会焦虑，但我已经学会和自己和解，不要和别人比，要和昨天的自己比。”无论人生上到哪一层台阶，阶下有人在仰望你，阶上亦有人在俯视你。你抬头自卑，低头自得。唯有平视，才能看见真正的自己。” 现在大三上学期即将结束，还有好几篇论文没写完，明天就是新的一年。下学期有更多自己可以支配的时间了，多学点，大四可能去实习。毕业后就去北京找工作了。不知道还会经历多少社会的毒打，就期待自己能获得自由吧。人生有什么意义呢？越去想人生有什么意义，我越觉得人生无意义。专注当下吧，想太多都是闲得，赶快去学习，反而能得到快乐和满足。 感谢豆瓣，感谢所有TV。 to be continued…","categories":[],"tags":[{"name":"life","slug":"life","permalink":"https://vanessayaoyao.github.io/tags/life/"}]},{"title":"JWT在Django中的具体实现","slug":"JWT在Django中的具体实现","date":"2021-12-03T09:10:25.000Z","updated":"2021-12-03T10:47:04.618Z","comments":true,"path":"2021/12/03/JWT在Django中的具体实现/","link":"","permalink":"https://vanessayaoyao.github.io/2021/12/03/JWT%E5%9C%A8Django%E4%B8%AD%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"记录一下，加深自己的理解。 什么是JWT？JWT是Json Web Token的缩写，可去官网查看更多。 简单说来，它和session干着一样的活，即身份认证。它保存在客户端，本质是一长串字符串，由header, payload和signature组成。 Why JWT not session? 使用session 存在CSRF攻击 session存在服务器端，无法适用分布式站点。 在Django中使用首先安装PyJWT 1pip install PyJWT models.py里建一张用户表，有用户名、密码等字段。 in views.py 1234567891011121314151617181920212223242526from .models import Userimport jwt, datetime, simplejson #导入def login(request): if request.method == &quot;POST&quot;: #接收json数据 username = simplejson.loads(request.body)[&#x27;username&#x27;] password = simplejson.loads(request.body)[&#x27;password&#x27;] #这里验证密码是否正确什么的我就先不写了 user = User.objects.filter(username=username).first() payload = &#123; #将该用户的id或username加入payload中 &quot;id&quot;: user.id, #过期时间，我这里写的是60分钟后过期 &quot;exp&quot;: datetime.datetime.utcnow() + datetime.timedelta(minutes=60), #生效时间，我这里写的是即刻生效 &quot;iat&quot;: datetime.datetime.utcnow() &#125; #将payload加密，我的密钥是&quot;secret&quot;(可以随便写) token = jwt.encode(payload, &quot;secret&quot;, algorithm=&#x27;HS256&#x27;).decode(&#x27;utf-8&#x27;) #将token返回 return JsonResponse(&#123;&#x27;jwt&#x27;: token, &#x27;msg&#x27;:&#x27;success&#x27;&#125;) else: return JsonResponse(&#123;&#x27;msg&#x27;: &#x27;wrong http method&#x27;&#125;) 123456789101112131415161718192021def user_info(request): if request.method == &quot;GET&quot;: #接收前端小伙伴放在HTTP头部的token #这样也避免了CSRF攻击 token = request.META.get(&#x27;HTTP_AUTHORIZATION&#x27;) if not token: msg = &#x27;not get token&#x27; try: #使用相同的密钥解密 payload = jwt.decode(token, &#x27;secret&#x27;, algorithms=[&#x27;HS256&#x27;]) #拿到用户id，从而完成用户认证 user = User.objects.get(id=payload[&#x27;id&#x27;]) msg = &#x27;get token, and I know you are &#x27; + user.username #也会存在异常 except jwt.ExpiredSignatureError: #如这里是token过期 msg = &#x27;token expired&#x27; except Exception as e: #还有其他过期类型，就不展开写了 msg = &quot;token invalid&quot; return JsonResponse(&#123;&#x27;token&#x27;: token, &#x27;msg&#x27;: msg&#125;) else: return JsonResponse(&#123;&#x27;msg&#x27;: &#x27;wrong http method&#x27;&#125;) 接口测试可用Postman， apifox等。 这只是一个小demo，实际运用中不可能每个需要身份认证的地方都写一遍（这么干也不是不行），所以考虑封装成装饰器。 这里我自我检讨一下，其实我装饰器并没有学会，只会照抄别人的代码。 改天再写一篇关于装饰器的博客。（立flag了） See you.","categories":[],"tags":[{"name":"code","slug":"code","permalink":"https://vanessayaoyao.github.io/tags/code/"}]},{"title":"怎么说呢，说就是不想考研了","slug":"怎么说呢，说就是不想考研了","date":"2021-10-11T00:23:28.000Z","updated":"2022-02-24T01:43:17.558Z","comments":true,"path":"2021/10/11/怎么说呢，说就是不想考研了/","link":"","permalink":"https://vanessayaoyao.github.io/2021/10/11/%E6%80%8E%E4%B9%88%E8%AF%B4%E5%91%A2%EF%BC%8C%E8%AF%B4%E5%B0%B1%E6%98%AF%E4%B8%8D%E6%83%B3%E8%80%83%E7%A0%94%E4%BA%86/","excerpt":"","text":"我虽无意逐鹿，却知苍生苦楚。 我头铁，要去撞南墙了。 2022/2/24更新之父母安心版 告诉了父母不考研的决定，他们虽然还是想让我继续学业，家里也不是供不起，但也是不强求，让我自己作主。三个多月前的有点像一时起意的想法，已经在我心底坐实，现在也是时候捋顺一下，算是一个交代吧。 摆在眼前有这么几条可以走的路吧，老师或者考公体制内算一种，考研算一种，互联网算一种。体制内可以直接pass了，教资我也考过，兼职的老师我也当过，我当老师和我当学生的心态完全一样，当学生想着如何撑到下课，当老师想的也是如何能苟到下课。考研其实不算一条真正的路吧，算是延期，倒时候还是要做选择。互联网挑战多机遇也多吧。 我发现我已经逐渐丧失了坐在课堂里听老师讲课学习的能力，可能是因为我上的课大多是水课，好久没有“学到知识”的体会了，我已经习惯了在课堂上玩手机。英语专业大多课都如此，平时水过去，全靠期末突击，得个还过得去的成绩，分高了还沾沾自喜一下。也有需要平时努力的课，当你作业认真完成，课堂展示和结课论文想得头秃，最后得的分数还不如随便水水的一门课时，你就应该知道分数根本代表不了什么。 最近考研成绩也陆续出来了，不免听到什么考了380，390分没学上的消息，我不知道是不是我又陷入了信息茧房中，但考研人数每年都是再创新高，越来越卷是事实。可能是我害怕我努力不够达不到目标，我卷不过，但选择另一条路也可以算是勇敢吧。考研的话，肯定是考计算机，英一数一408再加上政治，跨考难度飞起了吧。 考研的目的对我来说就是一个学历上的提升，而学历的提升也就是方便找工作。我对研究生的生活没什么向往，我也打听过研究生的生活是什么样的，基本就是要发文章，上课基本不怎么上，每周开会说说自己看了什么文献。可能如果我没参加过SRDP的话，还不会对看文献产生这么大的抵触心理。看文献发文章就算了，不是那块料，力不从心硬着头皮看，那真是煎熬。 工作的话，就算是本科，海大985的牌子还是有点用处的，我也不是非大厂不去，能去大厂当然很好，去不了就慢慢来嘛。我对技术也谈不上热爱吧，反正是不讨厌。我也不打算给自己一个具体的职业规划，我也规划不出来，三年前高三的我肯定没有想到现在的我在做什么打算，现在的我也预测不到未来的我。会遇到什么机遇吗？会惨兮兮地在出租房掉眼泪吗？会一直坚持做技术吗？会35岁失业吗哈哈哈哈。趁着年轻多去闯闯吧。 而且我已经期待完全的独立好久了。 ps. 这学期选了游泳课，一定要学会游泳！","categories":[],"tags":[{"name":"life","slug":"life","permalink":"https://vanessayaoyao.github.io/tags/life/"}]},{"title":"寒假日常","slug":"寒假日常","date":"2021-02-07T16:23:46.000Z","updated":"2021-06-20T08:34:20.627Z","comments":true,"path":"2021/02/08/寒假日常/","link":"","permalink":"https://vanessayaoyao.github.io/2021/02/08/%E5%AF%92%E5%81%87%E6%97%A5%E5%B8%B8/","excerpt":"","text":"第一天 刷手机 第二天 刷手机 第三天 刷手机 第四天 刷手机 第五天 刷手机 第六天 tmd, 烦死了。老子要学习！ 第七天 刷手机。。。","categories":[],"tags":[]},{"title":"hello world!","slug":"hello-world-1","date":"2021-01-31T07:17:39.000Z","updated":"2021-01-31T07:29:06.899Z","comments":true,"path":"2021/01/31/hello-world-1/","link":"","permalink":"https://vanessayaoyao.github.io/2021/01/31/hello-world-1/","excerpt":"","text":"Hi. This is my first blog. I’m very excited.","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"data structures","slug":"data-structures","permalink":"https://vanessayaoyao.github.io/tags/data-structures/"},{"name":"java","slug":"java","permalink":"https://vanessayaoyao.github.io/tags/java/"},{"name":"code","slug":"code","permalink":"https://vanessayaoyao.github.io/tags/code/"},{"name":"life","slug":"life","permalink":"https://vanessayaoyao.github.io/tags/life/"}]}