{"meta":{"title":"CicadaOnTheTree","subtitle":"哈喽呀","description":"我要握住一个最美的梦给未来的自己","author":"Vanessa Yao","url":"https://vanessayaoyao.github.io","root":"/"},"pages":[{"title":"categories","date":"2022-03-01T04:39:50.000Z","updated":"2022-03-01T04:41:54.562Z","comments":true,"path":"categories/index.html","permalink":"https://vanessayaoyao.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-12-03T10:26:53.000Z","updated":"2021-12-03T10:27:25.448Z","comments":true,"path":"tags/index.html","permalink":"https://vanessayaoyao.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"第一次笔试题","slug":"mst","date":"2022-05-27T05:37:19.000Z","updated":"2022-05-28T05:54:47.856Z","comments":true,"path":"2022/05/27/mst/","link":"","permalink":"https://vanessayaoyao.github.io/2022/05/27/mst/","excerpt":"","text":"啥也没准备就直接去面试了，到那了之后觉得工作环境还是不错的。在走廊的小桌子那坐了一会，人事给了我两张纸让我填，一张是基本信息啥的，另一张是笔试题。瞥了一眼，一个题都不会做哈哈哈哈。 1.设计模式的六大原则有哪些？ 单一职责原则（Single Responsibility Principle） 开闭原则(Open-Closed Principle, OCP) 里氏代换原则(Liskov Substitution Principle, LSP) 依赖倒置原则（Dependence Inversion Principle，DIP） 接口隔离原则(Interface Segregation Principle, ISP) 迪米特法则(Law of Demeter, LoD) 这东西背下来也没有什么意义，正好清空霞光的新番出了设计模式，大约一个小时，去看看去。 2.如何实现反射调用方法？（1）通过 Class 类的 getMethod 方法取的 Method 对象，并设置调用方法时需要的参数类型。 （2）使用 Method 方法调用 invoke 方法，并向该方法传递参数，其参数通常是一个类的对象。 3.数据库隔离级别数据库事务的隔离级别有4种，由低到高分别为Read uncommitted、Read committed 、Repeatable read 、Serializable 。 4.HashMap的数据结构（1.7与1.8的区别）HashMap底层实现JDK&lt;=1.7数组+链表，JDK&gt;=1.8数组+链表+红黑树；HashMap这一个类型底层涉及到3中数据类型，数组、链表、红黑树，其中查询速度最快的是数组，时间复杂度是O(1),链表数据量少的时候还行，数据量过大性能就一般了，它的时间复杂度是O(N)，红黑树在数据量打的时候性能会比链表要好，他的时间复杂度是O(logn),这里在链表和红黑树这里性能对比其实在HashMap的扩容时，已经体现出来了，Hash值产生碰撞后，链表长度&gt;8时会由链表转换为红黑树，而当红黑树的节点&lt;6时，会由红黑树转换为链表，这就是二者的性能临界点。 5.JAVA1.8有哪些新的特性？ Lambda表达式：Lambda允许把函数作为一个方法的参数（函数作为参数传递到方法中）。 方法引用：方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。 默认方法：默认方法就是一个在接口里面有了一个实现的方法。 新工具：新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。 Stream API：新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。 Date Time API：加强对日期与时间的处理。 Optional类：Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。 Nashorn，JavaScript引擎：JDK1.8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。 6.以下or查询有什么问题？该如何优化？1select * from t where num = 10 or num = 20; 应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描。可以改为： 123select id from t where num=10union allselect id from t where num=20 https://blog.csdn.net/qq_43842093/article/details/124548764 7.StringBuffer与StringBuilder的区别 String: 不可变字符串； StringBuffer: 可变字符串、效率低、线程安全； StringBuilder: 可变字符序列、效率高、线程不安全； 8.线程池的种类有以及线程的生命周期有哪些？1、newCachedThreadPool 2、newFixedThreadPool 3、newSingleThreadExecutor 4、newScheduleThreadPool 5、newSingleThreadScheduledExecutor 线程的生命周期会经历以下几个状态： 新建：new创建线程对象时 就绪：调用 **start()**方法时 运行：调用 **run()**方法时 阻塞： 多种原因可导致阻塞 死亡：多种原因 9.Spring中都使用了哪些设计模式？Spring 框架中使用到了大量的设计模式，下面列举了比较有代表性的： 1、代理模式：在 AOP 和 remoting 中被用的比较多。 2、单例模式：在 spring 配置文件中定义的 bean 默认为单例模式。 3、模板模式：用来解决代码重复的问题。 比如. RestTemplate, JmsTemplate, JpaTemplate。 4、委派模式：Spring 提供了 DispatcherServlet 来对请求进行分发。 5、工厂模式：BeanFactory 用来创建对象的实例，贯穿于 BeanFactory / ApplicationContext 接口的核心理念。 6、代理模式：AOP 思想的底层实现技术，Spring 中采用 JDK Proxy 和 CgLib 类库。 10.Mysql的锁类型有哪些？按锁粒度分类：行级锁&amp;表级锁&amp;页级锁 锁级别分类：共享锁 &amp; 排他锁 &amp; 意向锁 有重复数字的升序数组的二分查找 Java基础太差了，线程完全不懂，mysql只会基础语句，随便问问都不会，设计模式也没去学过，还有数据结构也没去学，leetcode只写过十几道。。。快点学习。。。我真的会谢。。。","categories":[{"name":"Web相关","slug":"Web相关","permalink":"https://vanessayaoyao.github.io/categories/Web%E7%9B%B8%E5%85%B3/"}],"tags":[]},{"title":"Nginx","slug":"nginx","date":"2022-05-13T12:16:31.000Z","updated":"2022-05-14T13:37:50.650Z","comments":true,"path":"2022/05/13/nginx/","link":"","permalink":"https://vanessayaoyao.github.io/2022/05/13/nginx/","excerpt":"","text":"Nginx概述Nginx介绍Nginx是一款轻量级的Web服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx的网站有：百度、京东、新浪、网易、腾讯、淘宝等。 Nginx下载和安装https://nginx.org/en/download.html 安装过程：1.安装依赖包 yum -y install gcc pcre-devel zlib-devel openssl openssl-devel2.下载Nginx安装包 wget https://nginx.org/download/nginx-1.16.1tar.gz3.解压tar -zxvf nginx-1.16.1.tar.gz4.cd nginx-1.16.15../configure ==prefix=/usr/local/nginx6.make &amp;&amp; make install Nginx目录重点目录/文件： conf/nginx.conf nginx配置文件 html 存访静态文件（html css js等） logs 日志目录，存放日志文件 sbin/nginx 二进制文件，用于启动、停止Nginx服务 Nginx命令查看版本在sbin目录下 1.&#x2F;nginx -v 检查配置文件正确性123root@iZuf67ss8kqoyvili0eqo2Z:&#x2F;usr&#x2F;sbin# .&#x2F;nginx -tnginx: the configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf syntax is oknginx: configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf test is successful 启动和停止启动Nginx服务 1.&#x2F;nginx 停止Nginx服务 1.&#x2F;nginx -s stop 启动完成后可以查看Nginx进程 1ps -ef|grep nginx 重新加载配置文件1.&#x2F;nginx -s reload Nginx配置文件结构 全局块 和Nginx运行相关的全局配置 events块 和网络连接相关的配置 http块 代理、缓存、日志记录、虚拟主机配置 http全局块 server块 server全局块 location块 注意：http块中可以配置多个server块，每个server块中可以配置多个location块。 Nginx具体应用部署静态资源Nginx可以作为静态Web服务器来部署静态资源。静态资源指在服务端真实存在并且能够直接展示的一些文件，比如常见的html页面，css文件，js文件，图片、视频等资源。 相对于Tomcat，Nginx处理静态资源的能力更加高效，所以在生产环境下，一般都会将静态资源部署到Nginx中。将静态资源部署到Nginx非常简单，只需要将文件复制到Nginx安装目录下的html目录中即可。 12345678server&#123; listen 80; # 箭头端口 server_name localhost; # 服务器名称 location &#x2F;&#123; # 匹配客户端请求url root html; # 指定静态资源根目录 index index.html # 指定默认首页 &#125;&#125; Spring Boot项目 12345678910111213server &#123; listen 8899; server_name 47.102.215.61; add_header Access-Control-Allow-Origin *; location &#x2F; &#123; root &#x2F;home&#x2F;test&#x2F;static; charset utf-8; add_header &#39;Access-Control-Allow-Origin&#39; &#39;*&#39;; add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;; add_header &#39;Access-Control-Allow-Methods&#39; &#39;*&#39;; add_header &#39;Access-Control-Allow-Headers&#39; &#39;Content-Type,*&#39;; &#125; &#125; Django项目 123456789101112131415161718server &#123; listen 8888; server_name 47.102.215.61; root &#x2F;home&#x2F;Haixun; index index.html index.htm index.nginx-debian.html; location &#x2F; &#123; include uwsgi_params; uwsgi_pass 127.0.0.1:8002; uwsgi_send_timeout 120s; uwsgi_read_timeout 120s; &#125; location &#x2F;static &#123; alias &#x2F;home&#x2F;Haixun&#x2F;static; &#125; location &#x2F;media &#123; alias &#x2F;home&#x2F;Haixun&#x2F;media; &#125;&#125; 反向代理正向代理正向代理是一个位于客户端和原始服务器（origin server）之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标（原始服务器），然后代理向原始服务器转交请求并将获得的内容返回给客户端。 正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。（梯子）正向代理一般是在客户端设置代理服务器，通过代理服务器转发请求，最终访问到目标服务器。 反向代理反向代理服务器位于用户与目标服务器之间，但是对于用户而言，反向代理服务器就相当于目标服务器，即用户直接访问反向代理服务器就可以获得目标服务器的资源，反向代理服务器负责将请求转发给目标服务器。 用户不需要知道目标服务器的地址，也无须再用户端作任何设定。 配置反向代理1234567server&#123; listen 82; servername 192.168.138.100; location &#x2F; &#123; proxy_pass http:&#x2F;&#x2F;192.168.138.101:8080; # 反向代理配置，将请求转发到指定服务 &#125;&#125; 负载均衡早期的网络流量和业务功能都比较简单，单台服务器就可以满足基本需求，但是随着互联网的发展，业务流量越来越大并且业务逻辑也越来越复杂，单台服务器的性能及单点故障问题就凸显出来了，因此需要多台服务器组成应用集群，进行性能的水平扩展以及避免单点故障出现。 应用集群：将同一应用部署到多台机器上，组成应用集群，接收负载均衡器分发的请求，进行业务处理并返回响应数据 负载均衡器：将用户请求根据对应的负载均衡算法分发到应用集群中的一台服务器进行处理 配置负载均衡1234567891011upstream targetserver &#123; server 192.168.138.101:8080; server 192.168.138.101:8081;&#125;server &#123; listen 8080; server_name 192.168.138.100; location &#x2F; &#123; proxy_pass http:&#x2F;&#x2F;targetserver; &#125;&#125; 负载均衡策略 轮询：默认方式 weight：权重方式 ip_hash：根据ip分配方式 least_conn：根据最少连接方式 url_hash：根据url分配方式 fair：根据响应时间方式","categories":[{"name":"Web相关","slug":"Web相关","permalink":"https://vanessayaoyao.github.io/categories/Web%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://vanessayaoyao.github.io/tags/nginx/"}]},{"title":"Mybatis-Plus之Lambda条件构造器","slug":"querywrapper","date":"2022-05-10T10:23:26.000Z","updated":"2022-05-10T10:42:51.012Z","comments":true,"path":"2022/05/10/querywrapper/","link":"","permalink":"https://vanessayaoyao.github.io/2022/05/10/querywrapper/","excerpt":"","text":"LambdaQueryWrapper&lt;T&gt;创建LambdaQueryWrapper&lt;T&gt;实例的三种方法： 1234LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = new LambdaQueryWrapper();LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper1 = new QueryWrapper&lt;User&gt;().lambda(); // 官方建议下面这种方法LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper2 = Wrappers.lambdaQuery(); 简单用法 12345LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = new LambdaQueryWrapper();lambdaQueryWrapper.like(User::getUsername , &quot;k&quot;).lt(User::getAge , 30);List&lt;User&gt; userList = userMapper.selectList(lambdaQueryWrapper);userList.forEach(System.out::println);lambdaQueryWrapper.eq(User::getUsername, username); LambdaQueryChainWrapper&lt;T&gt;123List&lt;User&gt; userList = new LambdaQueryChainWrapper&lt;User&gt;(userMapper) .like(User::getUsername , &quot;k&quot;).lt(User::getAge , 30).list();userList.forEach(System.out::println);","categories":[{"name":"Web相关","slug":"Web相关","permalink":"https://vanessayaoyao.github.io/categories/Web%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"mybatis-plus","slug":"mybatis-plus","permalink":"https://vanessayaoyao.github.io/tags/mybatis-plus/"}]},{"title":"RequestBody、RequestParam、PathVariable注解以及不加注解接收参数的区别","slug":"request","date":"2022-05-10T10:08:39.000Z","updated":"2022-05-10T10:46:59.155Z","comments":true,"path":"2022/05/10/request/","link":"","permalink":"https://vanessayaoyao.github.io/2022/05/10/request/","excerpt":"","text":"@RequestParam主要用来接收GET请求拼接在URL后的参数，或者是POST传递，且Content-type为x-www-form-urlencoded方式。格式为xxx?username=123&amp;password=456。 因为不管是GET方式还是用x-www-form-urlencoded方式传递，参数都是以键值对方式拼接的，然后经过URLencoded编码，传递给服务端。@RequestParam只能接收简单参数类型，复杂的参数类型要用@RequestBody来接收，或者不加注解来接收。 @RequestBody主要用来接收前端传递给后端的 json字符串中的数据(请求体中的数据) 使用@RequestBody该注解，前端请求只能为POST，因为该注解是从请求体中获得对象的。且请求头中的Content-type一般为application/json方式。所以使用该注解能够接收JSON格式的数据，并且能把接收到的JSON数据绑定到JAVA对象中 @PathVariable接收请求路径中占位符的值，”/{id}” 什么也不写当请求content_type为：application/x-www-form-urlencoded类型的或multipart/form-data时，数据格式为aaa=111&amp;bbb=222。","categories":[{"name":"Web相关","slug":"Web相关","permalink":"https://vanessayaoyao.github.io/categories/Web%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"springmvc","slug":"springmvc","permalink":"https://vanessayaoyao.github.io/tags/springmvc/"}]},{"title":"SpringBoot项目部署到服务器","slug":"springboot-on-linux","date":"2022-04-13T00:42:12.000Z","updated":"2022-04-16T02:48:10.756Z","comments":true,"path":"2022/04/13/springboot-on-linux/","link":"","permalink":"https://vanessayaoyao.github.io/2022/04/13/springboot-on-linux/","excerpt":"","text":"这是一个简单的前后端分离的SpringBoot项目。登录、注册、登出。涉及到发邮件、用redis做缓存，SpringSecurity拦截，跨域解决，开发环境和生产环境的切换。 环境安装安装JDK1sudo apt install openjdk-8-jdk 测试 1234root@iZuf67ss8kqoyvili0eqo2Z:~# java -versionopenjdk version &quot;1.8.0_292&quot;OpenJDK Runtime Environment (build 1.8.0_292-8u292-b10-0ubuntu1~16.04.1-b10)OpenJDK 64-Bit Server VM (build 25.292-b10, mixed mode) 安装Redis1sudo apt install redis-server 测试 123root@iZuf67ss8kqoyvili0eqo2Z:~# redis-cli127.0.0.1:6379&gt; pingPONG 安装MySql1sudo apt install mysql-server-8.0 在root权限下，可以直接登录服务器，不用输密码。 1mysql -u root -p 创建项目的数据库 1create database springboot; 常用的命令查看端口占用 lsof(list open files)是一个列出当前系统打开文件的工具。 1laof -i:端口号 1netstat -tunlp | grep 端口号 -t (tcp) 仅显示tcp相关选项 -u (udp)仅显示udp相关选项 -n 拒绝显示别名，能显示数字的全部转化为数字 -l 仅列出在Listen(监听)的服务状态 -p 显示建立相关链接的程序名 查看服务的进程号 1ps -ef|grep nginx 杀掉对应进程 1kill -9 PID 1 (HUP)：重新加载进程。 9 (KILL)：杀死一个进程。 15 (TERM)：正常停止一个进程。 nginx启动、停止、重启 1sudo service nginx start &#x2F; stop &#x2F; status &#x2F; restart 1sudo systemctl restart nginx.service uwsgi启动、停止 1uwsgi --ini uwsgi.ini 1sudo killall -9 uwsgi 尝试启动在阿里云把项目生产环境的启动端口打开 1java -jar springboot-project-0.0.1-SNAPSHOT.jar 意想不到的，非常流畅的就启动了，虽然后面还是遇到了一些问题，但最起码可以看到页面了。回想一开始部署Django的时候，那真是废了老鼻子劲了，各种各样的Bug，寸步难行，快给人整崩溃了。 遇到的问题发送邮件换端口阿里云25端口是被封了的，听说是处于安全的考虑，可以换成465端口。 123456789101112131415spring: mail: host: smtp.163.com username: password: port: 465 properties: mail: smtp: ssl: enable: true imap: ssl: socketFactory: fallback: false 后台运行jar把xshell叉了，项目就停了，这不行啊。怎么让它可以一直挂着？ 1nohup java -jar love-0.0.1-SNAPSHOT.jar &amp; no hangup。此时程序控制台输出会被转移到 nohup.out 文件中。 分离了？嘿，我给你合上！这是一个比较神奇的问题，我把静态文件从springboot里拿了出来，放在了和jar包同一个目录下。咱们就是一个前后端大分离的动作。按说这时候的springboot的项目就纯纯的提供接口了，没有html页面了，但是我启动还是可以访问到index.html。我clean了好几次，再打包，结果还是可以访问到index.html。我就试着把那个jar包在本地启动，是没有html页面的，放在服务器上就有了。把服务器上的static文件夹删了才访问不到了，这是什么情况！难道nginx可以自动反向代理？我配置什么都没写啊？神奇！ 这里或许是springboot项目在起作用。。 Nginx反向代理Nginx非常强大，它能够通提供非常方便的反向代理服务，并且支持负载均衡。 啥是反向代理，听起来好高大上，我现在的理解就是，把静态资源交给nginx管，这样访问速度能快点。 12cd &#x2F;etc&#x2F;nginxsudo vim nginx.conf 12345678910111213server &#123; listen 80; server_name 192.168.10.4; add_header Access-Control-Allow-Origin *; location &#x2F; &#123; root &#x2F;home&#x2F;test&#x2F;static; charset utf-8; add_header &#39;Access-Control-Allow-Origin&#39; &#39;*&#39;; add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;; add_header &#39;Access-Control-Allow-Methods&#39; &#39;*&#39;; add_header &#39;Access-Control-Allow-Headers&#39; &#39;Content-Type,*&#39;; &#125; &#125; 通过另一个端口访问静态资源，好像是快了那么一点点。但我登不进去主页了？？info接口没有获得用户信息？？？ tell me why!!!!","categories":[{"name":"Web相关","slug":"Web相关","permalink":"https://vanessayaoyao.github.io/categories/Web%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://vanessayaoyao.github.io/tags/springboot/"}]},{"title":"自定义SpringBoot启动Banner","slug":"edit-springboot-banner","date":"2022-04-02T09:11:56.000Z","updated":"2022-04-02T09:21:13.776Z","comments":true,"path":"2022/04/02/edit-springboot-banner/","link":"","permalink":"https://vanessayaoyao.github.io/2022/04/02/edit-springboot-banner/","excerpt":"","text":"SpringBoot项目启动时会在控制台打印banner, be like: 1234567 . ____ _ __ _ _ &#x2F;\\\\ &#x2F; ___&#39;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | &#39;_ | &#39;_| | &#39;_ \\&#x2F; _&#96; | \\ \\ \\ \\ \\\\&#x2F; ___)| |_)| | | | | || (_| | ) ) ) ) &#39; |____| .__|_| |_|_| |_\\__, | &#x2F; &#x2F; &#x2F; &#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|_|&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|___&#x2F;&#x3D;&#x2F;_&#x2F;_&#x2F;_&#x2F; :: Spring Boot :: (v2.6.5) 想修改其实很容易，只需要在resources文件夹下加上一个banner.txt文件即可 可以使用在线生成网站进行生成自己的个性Banner：https://www.bootschool.net/ascii 12345678 ██ ██ ██ ██ ██ ██ ██ ██░██ ░██ ░██ ░██ ░██ ░██ ░██ ░██░██ ░██ █████ ░██ ░██ ██████ ░██ █ ░██ ██████ ██████ ░██ ░██░██████████ ██░░░██ ░██ ░██ ██░░░░██ ░██ ███ ░██ ██░░░░██░░██░░█ ░██ ██████░██░░░░░░██░███████ ░██ ░██░██ ░██ ░██ ██░██░██░██ ░██ ░██ ░ ░██ ██░░░██░██ ░██░██░░░░ ░██ ░██░██ ░██ ░████ ░░████░██ ░██ ░██ ░██░██ ░██░██ ░██░░██████ ███ ███░░██████ ░██░ ░░░██░░██████ ░███ ███░░██████░░ ░░ ░░░░░░ ░░░ ░░░ ░░░░░░ ░░ ░░ ░░░░░░ ░░░ ░░░ ░░░░░░ 内容随便改，甚至可以这样 1234567891011121314151617181920&#x2F;&#x2F; _ooOoo_ &#x2F;&#x2F;&#x2F;&#x2F; o8888888o &#x2F;&#x2F;&#x2F;&#x2F; 88&quot; . &quot;88 &#x2F;&#x2F;&#x2F;&#x2F; (| ^_^ |) &#x2F;&#x2F;&#x2F;&#x2F; O\\ &#x3D; &#x2F;O &#x2F;&#x2F;&#x2F;&#x2F; ____&#x2F;&#96;---&#39;\\____ &#x2F;&#x2F;&#x2F;&#x2F; .&#39; \\\\| |&#x2F;&#x2F; &#96;. &#x2F;&#x2F;&#x2F;&#x2F; &#x2F; \\\\||| : |||&#x2F;&#x2F; \\ &#x2F;&#x2F;&#x2F;&#x2F; &#x2F; _||||| -:- |||||- \\ &#x2F;&#x2F;&#x2F;&#x2F; | | \\\\\\ - &#x2F;&#x2F;&#x2F; | | &#x2F;&#x2F;&#x2F;&#x2F; | \\_| &#39;&#39;\\---&#x2F;&#39;&#39; | | &#x2F;&#x2F;&#x2F;&#x2F; \\ .-\\__ &#96;-&#96; ___&#x2F;-. &#x2F; &#x2F;&#x2F;&#x2F;&#x2F; ___&#96;. .&#39; &#x2F;--.--\\ &#96;. . ___ &#x2F;&#x2F;&#x2F;&#x2F; .&quot;&quot; &#39;&lt; &#96;.___\\_&lt;|&gt;_&#x2F;___.&#39; &gt;&#39;&quot;&quot;. &#x2F;&#x2F;&#x2F;&#x2F; | | : &#96;- \\&#96;.;&#96;\\ _ &#x2F;&#96;;.&#96;&#x2F; - &#96; : | | &#x2F;&#x2F;&#x2F;&#x2F; \\ \\ &#96;-. \\_ __\\ &#x2F;__ _&#x2F; .-&#96; &#x2F; &#x2F; &#x2F;&#x2F;&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#96;-.____&#96;-.___\\_____&#x2F;___.-&#96;____.-&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x2F;&#x2F;&#x2F;&#x2F; &#96;&#x3D;---&#x3D;&#39; &#x2F;&#x2F;&#x2F;&#x2F; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ &#x2F;&#x2F;&#x2F;&#x2F; 佛祖保佑 永无BUG 永不修改 &#x2F;&#x2F; 哈哈哈哈，太搞了。 这样技术含量并不太高的小trick, 却让我觉得眼前一亮！","categories":[],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://vanessayaoyao.github.io/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"tomcat9中文乱码","slug":"tomcat-encoding","date":"2022-03-29T14:22:24.000Z","updated":"2022-04-02T09:10:03.468Z","comments":true,"path":"2022/03/29/tomcat-encoding/","link":"","permalink":"https://vanessayaoyao.github.io/2022/03/29/tomcat-encoding/","excerpt":"","text":"HTML页面一直乱码，很搞心态啊，明明up主没乱码，到我这就乱码了，如封面一样。tomcat10也没乱码，9就乱码。我一开始打算干脆一句中文不写，我全写英文，我看你还怎么乱码。但是到后面我看视频看得烦了，改前端页面改的人麻了，不想跟着一句一句写了。我就直接下载了源码，想着跑起来就行了吧，但中文全是乱码的，把中文改成英文也挺烦的。可见，有些bug不改不行啊。 成功操作在诸多尝试后，我发现只要一句话就能解决我的问题。 编辑tomcat启动项，在Environment Variables加上 Name Value JAVA_OPTS -Dfile.encoding=UTF-8 其实不用红框的那句，只有上一句就可以。重要的是一定要先点Apply，再点OK. 未起作用尝试下面的这些操作可以一试，只是并没有解决我的问题。 Thymeleaf这地方还是要写的 123456789//我们需要使用ThymeleafViewResolver作为视图解析器，并解析我们的HTML页面@Beanpublic ThymeleafViewResolver thymeleafViewResolver(@Autowired SpringTemplateEngine springTemplateEngine)&#123; ThymeleafViewResolver resolver = new ThymeleafViewResolver(); resolver.setOrder(1); resolver.setCharacterEncoding(&quot;UTF-8&quot;); resolver.setTemplateEngine(springTemplateEngine); return resolver;&#125; Spring Security这里也要写，要不然传进数据库里乱码 12345@Overrideprotected void beforeSpringSecurityFilterChain(ServletContext servletContext) &#123; servletContext.addFilter(&quot;characterEncodingFilter&quot;, new CharacterEncodingFilter(&quot;UTF-8&quot;, true)) .addMappingForUrlPatterns(null, false, &quot;/*&quot;);&#125; server.xml12345&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;connectionTimeout=&quot;20000&quot;redirectPort=&quot;8443&quot; URIEncoding=&quot;UTF-8&quot; /&gt;&lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; URIEncoding=&quot;UTF-8&quot;/&gt; catalina.bat12set &quot;JAVA_OPTS=%JAVA_OPTS% %JSSE_OPTS%&quot;-Dfile.encoding=UTF8 -Dsun.jnu.encoding=UTF8 按说这个应该成功的，和上面改的一样，但是并没有成功。 web.xml1234567891011121314151617&lt;servlet&gt;&lt;servlet-name&gt;default&lt;/servlet-name&gt;&lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt;&lt;init-param&gt;&lt;param-name&gt;debug&lt;/param-name&gt;&lt;param-value&gt;0&lt;/param-value&gt;&lt;/init-param&gt;&lt;init-param&gt;&lt;param-name&gt;fileEncoding&lt;/param-name&gt;&lt;param-value&gt;UTF-8&lt;/param-value&gt;&lt;/init-param&gt;&lt;init-param&gt;&lt;param-name&gt;listings&lt;/param-name&gt;&lt;param-value&gt;false&lt;/param-value&gt;&lt;/init-param&gt;&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; 回馈反思maybe 我要去学习整理一下编码方式,ascii,unicode,utf-8….啥的。 flag~","categories":[{"name":"Bug调试","slug":"Bug调试","permalink":"https://vanessayaoyao.github.io/categories/Bug%E8%B0%83%E8%AF%95/"}],"tags":[]},{"title":"IoC和AOP","slug":"AOP","date":"2022-03-25T02:18:30.000Z","updated":"2022-03-26T13:54:58.117Z","comments":true,"path":"2022/03/25/AOP/","link":"","permalink":"https://vanessayaoyao.github.io/2022/03/25/AOP/","excerpt":"","text":"Spring为了简化开发而生，它是轻量级的IoC和AOP的容器框架，主要是针对JavaBean的生命周期进行管理的轻量级容器，并且它的生态已经发展得极为庞大。 JavaBean和普通类差不多，它的所有属性都是private，所有的属性都可以通过get/set方法进行访问，同时还需要有一个无参构造（默认就有）。 IoC控制反转在采用面向对象方法设计的软件系统中，它的底层实现都是由N个对象组成的，所有的对象通过彼此的合作，最终实现系统的业务逻辑。对象之间耦合度过高的系统，必然会出现牵一发而动全身的情形。 IoC（Inverse of Control:控制反转） 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。 将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。 在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置太繁琐，于是SpringBoot 注解配置就慢慢开始流行起来。 IoC和DIIoC是一种设计思想或者说是某种模式。IoC 最常见以及最合理的实现方式叫做依赖注入（Dependency Injection，简称 DI）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递(注入)给它。 每个文本输入框有一个文本检查器，每次初始化一个文本选择框都需要一个检查器。 123456789101112public class TextInput &#123; private SpellCheck spellCheck; public TextInput() &#123; spellCheck=new SpellCheck(); &#125;&#125;public class TextInput &#123; private SpellCheck spellCheck; public TextInput(SpellCheck spellCheck) &#123; this.spellCheck=spellCheck; &#125;&#125; 观察以上两段不同的代码我们可以发现他们本质的区别是 SpellCheck对象创建的时间以及地点不同，在后面代码中文本检查器作为一个文本框的构造方法中的一个形参传入文本框内部。即可以了解为将spellCheck对象注入TextInput类。通过这个例子大概就可以了解上面提出的问题，什么是依赖，什么是注入了吧，文本框依赖检查器 ，将依赖的类作为形参放入依赖的类中就成为依赖注入。 AOP面向切面编程AOP(Aspect-Oriented Programming:面向切面编程)，又是一个听起来很高大上的名词，AOP思想实际上就是：在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。也就是说，我们可以使用AOP来帮助我们在方法执行前或执行之后，做一些额外的操作，实际上，就是代理！ 我感觉和python中的装饰器有点像。。 通过AOP我们可以在保证原有业务不变的情况下，添加额外的动作，比如我们的某些方法执行完成之后，需要打印日志，那么这个时候，我们就可以使用AOP来帮助我们完成，它可以批量地为这些方法添加动作。可以说，它相当于将我们原有的方法，在不改变源代码的基础上进行了增强处理。 相当于我们的整个业务流程，被直接斩断，并在断掉的位置添加了一个额外的操作，再连接起来，也就是在一个切点位置插入内容。它的原理实际上就是通过动态代理机制实现的。不过Spring底层并不是使用的JDK提供的动态代理，而是使用的第三方库实现，它能够以父类的形式代理，而不是接口。 https://juejin.cn/post/6844904071657160717https://juejin.cn/post/6844903973715968007https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#spring-ioc-aop","categories":[{"name":"Web相关","slug":"Web相关","permalink":"https://vanessayaoyao.github.io/categories/Web%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"AOP Ioc","slug":"AOP-Ioc","permalink":"https://vanessayaoyao.github.io/tags/AOP-Ioc/"}]},{"title":"不是吧, 阿Sir","slug":"i-hate-gitee","date":"2022-03-24T12:39:01.000Z","updated":"2022-03-26T13:49:36.103Z","comments":true,"path":"2022/03/24/i-hate-gitee/","link":"","permalink":"https://vanessayaoyao.github.io/2022/03/24/i-hate-gitee/","excerpt":"","text":"我的图啊。。。额滴亲娘。。。 无语了。。。 最近日常 看框架，也不知道学进去了多少。算法也算没开始吧。自己现在真的是啥都不行啊，拿什么找工作啊！！！！ 最近发现两部脑洞大开的动画片，好看！ 《瑞克和莫蒂》 《希尔达》 2022/3/26更新 今天星期六，网页一组发了他们的播放器。。 无力吐槽。。放眼一看，全是bug。。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://vanessayaoyao.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[]},{"title":"查缺补漏之反射","slug":"reflection","date":"2022-03-23T00:59:47.000Z","updated":"2022-03-24T12:19:38.347Z","comments":true,"path":"2022/03/23/reflection/","link":"","permalink":"https://vanessayaoyao.github.io/2022/03/23/reflection/","excerpt":"","text":"感觉在mosh的那个课里没有说到反射。最近在看框架方面的视频，up主提到好几次反射，现在来看看吧。 什么是反射？反射 (Reflection) 是 Java 的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。 Java反射就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；并且能改变它的属性。 程序中一般的对象的类型都是在编译期就确定下来的，而 Java 反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。 反射的核心是 JVM 在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。 反射的主要用途我们知道反射机制允许程序在运行时取得任何一个已知名称的class的内部信息，包括包括其modifiers(修饰符)，fields(属性)，methods(方法)等，并可于运行时改变fields内容或调用methods。那么我们便可以更灵活的编写代码，代码可以在运行时装配，无需在组件之间进行源代码链接，降低代码的耦合度；还有动态代理的实现等等；但是需要注意的是反射使用不当会造成很高的资源消耗！ 反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 Bean），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射，运行时动态加载需要加载的对象。 反射的基本用法Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类： Field ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段； Method ：可以使用 invoke() 方法调用与 Method 对象关联的方法； Constructor ：可以用 Constructor 的 newInstance() 创建新的对象。 12345678910111213141516171819// 一个Person类package com.ys.reflex;public class Person &#123; //私有属性 private String name = &quot;Tom&quot;; //公有属性 public int age = 18; //构造方法 public Person() &#123; &#125; //私有方法 private void say()&#123; System.out.println(&quot;private say()...&quot;); &#125; //公有方法 public void work()&#123; System.out.println(&quot;public work()...&quot;); &#125;&#125; ①、得到 Class 的三种方式 123456789101112//1、通过对象调用 getClass() 方法来获取,通常应用在：比如你传过来一个 Object// 类型的对象，而我不知道你具体是什么类，用这种方法 Person p1 = new Person(); Class c1 = p1.getClass();//2、直接通过 类名.class 的方式得到,该方法最为安全可靠，程序性能更高// 这说明任何一个类都有一个隐含的静态成员变量 class Class c2 = Person.class;//3、通过 Class 对象的 forName() 静态方法来获取，用的最多，// 但可能抛出 ClassNotFoundException 异常 Class c3 = Class.forName(&quot;com.ys.reflex.Person&quot;); 需要注意的是：一个类在 JVM 中只会有一个 Class 实例，即我们对上面获取的 c1,c2,c3进行 equals 比较，发现都是true。 ②、通过 Class 类获取成员变量、成员方法、接口、超类、构造方法等 查阅 API 可以看到 Class 有很多方法： getName()：获得类的完整名字。 getFields()：获得类的public类型的属性。 getDeclaredFields()：获得类的所有属性。包括private 声明的和继承类 getMethods()：获得类的public类型的方法。 getDeclaredMethods()：获得类的所有方法。包括private 声明的和继承类 getMethod(String name, Class[] parameterTypes)：获得类的特定方法，name参数指定方法的名字，parameterTypes 参数指定方法的参数类型。 getConstructors()：获得类的public类型的构造方法。 getConstructor(Class[] parameterTypes)：获得类的特定构造方法，parameterTypes 参数指定构造方法的参数类型。 newInstance()：通过类的不带参数的构造方法创建这个类的一个对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//获得类完整的名字String className = c2.getName();System.out.println(className);//输出com.ys.reflex.Person//获得类的public类型的属性。Field[] fields = c2.getFields();for(Field field : fields)&#123; System.out.println(field.getName());//age&#125;//获得类的所有属性。包括私有的Field [] allFields = c2.getDeclaredFields();for(Field field : allFields)&#123; System.out.println(field.getName());//name age&#125;//获得类的public类型的方法。这里包括 Object 类的一些方法Method [] methods = c2.getMethods();for(Method method : methods)&#123; System.out.println(method.getName());//work waid equls toString hashCode等&#125;//获得类的所有方法。Method [] allMethods = c2.getDeclaredMethods();for(Method method : allMethods)&#123; System.out.println(method.getName());//work say&#125;//获得指定的属性Field f1 = c2.getField(&quot;age&quot;);System.out.println(f1);//获得指定的私有属性Field f2 = c2.getDeclaredField(&quot;name&quot;);//启用和禁用访问安全检查的开关，值为 true，则表示反射的对象在使用时应该取消 java 语言的访问检查；反之不取消f2.setAccessible(true);System.out.println(f2);//创建这个类的一个对象Object p2 = c2.newInstance();//将 p2 对象的 f2 属性赋值为 Bob，f2 属性即为 私有属性 namef2.set(p2,&quot;Bob&quot;);//使用反射机制可以打破封装性，导致了java对象的属性不安全。System.out.println(f2.get(p2)); //Bob//获取构造方法Constructor [] constructors = c2.getConstructors();for(Constructor constructor : constructors)&#123; System.out.println(constructor.toString());//public com.ys.reflex.Person()&#125; 反射机制与动态加载类 new创建对象的方式称作为静态加载，而使用Class.forName(“XXX”)称作为动态加载，它们俩本质的区别在于静态加载的类的源程序在编译时期加载（必须存在），而动态加载的类在编译时期可以缺席（源程序不必存在）。 123456789101112// 静态加载类 public class StaticClass &#123; public static void main(String[] args) &#123; if(&quot;teacher&quot;.equals(args[0])) &#123; Teacher t = new Teacher(); // 使用new关键字 t.getAvgAge(); &#125;else if(&quot;student&quot;.equals(args[0])) &#123; Student s = new Student(); s.getAvgAge(); &#125; &#125;&#125; 上面的代码中的前提是Teacher和Student还没有编译，此代码在javac的编译阶段就会报错。因为使用new关键字来实例对象时，此时就是静态加载类，编译时会查看类用到的所有类是否都可以找到。而此类在实际的生产环境中如果这样实现，不仅仅给内存提高了要求，也有了很多的限制。如果项目目前只需要Teacher就可以满足需求了，而迫于代码的原因，不得不把Student也实现了才可以使用。 程序代码中的工具类往往都会存在类似的问题，此时通过动态加载类的方式就可以很好的解决此问题：分别创建DynamicClass类、People接口类、Student类、Teacher类，其中Student和Teacher实现People接口，为了能够面向接口编程，减少依赖，降低耦合度。 12345678public class DynamicClass &#123; public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException &#123; Class ct = Class.forName(args[0]); //面向接口编程 People tea = (People) ct.newInstance(); tea.getAvgAge(); &#125;&#125; 通过使用动态类加载技术，在工具类中，不再需要进行大量的判断。通过输入的参数，动态加载需要使用的类即可，在获取类的实例化对象时，也不再向上转型为具体的实现类，而是面向接口，提高了应用的扩展性，在People的类别增加或者变化上，不需要修改工具类，均可以获得相应类别的平均年龄。 https://www.cnblogs.com/ysocean/p/6516248.html https://www.sczyh30.com/posts/Java/java-reflection-1/https://blog.csdn.net/itxiaohei323/article/details/87808306","categories":[{"name":"Java SE","slug":"Java-SE","permalink":"https://vanessayaoyao.github.io/categories/Java-SE/"}],"tags":[{"name":"reflection","slug":"reflection","permalink":"https://vanessayaoyao.github.io/tags/reflection/"}]},{"title":"二叉树的构建与遍历","slug":"binary-tree","date":"2022-03-16T01:16:42.000Z","updated":"2022-03-24T12:35:20.895Z","comments":true,"path":"2022/03/16/binary-tree/","link":"","permalink":"https://vanessayaoyao.github.io/2022/03/16/binary-tree/","excerpt":"","text":"二叉树的存储结构顺序存储结构 完全二叉树和满二叉树采用顺序存储比较合适。对于比较稀疏的二叉树，空间利用率较低。 链式存储结构 二叉链表至少包含3个域：数据域data，左指针域lchild，右指针域rchild。 123456789101112131415161718192021222324// 二叉树节点private static class TreeNode&#123; int data; TreeNode leftChild; TreeNode rightChild; public TreeNode(int data) &#123; this.data = data; &#125;&#125;//构建二叉树public static TreeNode createBinaryTree(LinkedList&lt;Integer&gt; inputList)&#123; TreeNode node = null; if (inputList == null || inputList.isEmpty())&#123; return null; &#125; Integer data = inputList.removeFirst(); if (data != null)&#123; node = new TreeNode(data); node.leftChild = createBinaryTree(inputList); node.rightChild = createBinaryTree(inputList); &#125; return node;&#125; 二叉树的构建方法有很多，这里把一个线性的链表转化成非线性的二叉树，链表节点的顺序恰恰是二叉树前序遍历的顺序。链表中的空值，代表二叉树节点的左孩子或右孩子为空的情况。 深度优先搜索深度优先搜索（DFS, depth-first search），它的思想是从一个顶点开始，沿着一条路一直走到底，如果发现不能到达目标解，那就返回到上一个节点，然后从另一条路开始走到底。 前序遍历输出顺序是：根节点、左子树、右子树。 123456789// 前序遍历public static void preOrderTraversal(TreeNode node)&#123; if (node == null)&#123; return; &#125; System.out.println(node.data); preOrderTraversal(node.leftChild); preOrderTraversal(node.rightChild);&#125; 中序遍历输出顺序是左子树、根节点、右子树。 123456789// 中序遍历public static void inOrderTraversal(TreeNode node)&#123; if (node == null)&#123; return; &#125; inOrderTraversal(node.leftChild); System.out.println(node.data); inOrderTraversal(node.rightChild);&#125; 后序遍历输出顺序是左子树、右子树、根节点。 123456789// 后序遍历public static void postOrderTraversal(TreeNode node)&#123; if (node == null)&#123; return; &#125; postOrderTraversal(node.leftChild); postOrderTraversal(node.rightChild); System.out.println(node.data);&#125; 测试 {3,2,9,null,null,10,null,null,8,null,4} 12345678910public static void main(String[] args) &#123; LinkedList&lt;Integer&gt; inputList = new LinkedList&lt;&gt;(Arrays.asList(new Integer[]&#123;3,2,9,null,null,10,null,null,8,null,4&#125;)); TreeNode treeNode = createBinaryTree(inputList); System.out.println(&quot;前序遍历&quot;); preOrderTraversal(treeNode); // 3，2，9，10，8，4 System.out.println(&quot;中序遍历&quot;); inOrderTraversal(treeNode); // 9，2，10，3，8，4 System.out.println(&quot;后序遍历&quot;); postOrderTraversal(treeNode); // 9，10，2，4，8，3&#125; 非递归遍历绝大多数可以用递归解决的问题，其实都可以用另一种数据结构来解决，这种数据结构就是栈 。因为递归和栈都有回溯的特性。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 非递归前序遍历public static void preOrderTraversalWithStack(TreeNode node)&#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while (node != null || !stack.isEmpty())&#123; // 迭代访问节点的左孩子，并入栈 while (node != null)&#123; System.out.println(node.data); stack.push(node); node = node.leftChild; &#125; // 如果节点没有左孩子，则弹出栈顶节点，访问节点右孩子 if (!stack.isEmpty())&#123; node = stack.pop(); node = node.rightChild; &#125; &#125;&#125;// 非递归中序遍历public static void inOrderTraversalWithStack(TreeNode node)&#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while(node != null || !stack.empty()) &#123; while (node != null) &#123; stack.push(node); node = node.leftChild; &#125; if(!stack.empty()) &#123; node = stack.pop(); System.out.println(node.data); node = node.rightChild; &#125; &#125;&#125;// 非递归后序遍历public static void postOrderTraversalWithStack(TreeNode node)&#123; Stack&lt;TreeNode&gt; stack1 = new Stack&lt;&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;&gt;(); int i = 1; while(node != null || !stack1.empty()) &#123; while (node != null) &#123; stack1.push(node); stack2.push(0); node = node.leftChild; &#125; while(!stack1.empty() &amp;&amp; stack2.peek() == i) &#123; stack2.pop(); System.out.println(stack1.pop().data); &#125; if(!stack1.empty()) &#123; stack2.pop(); stack2.push(1); node = stack1.peek(); node = node.rightChild; &#125; &#125;&#125; https://www.cnblogs.com/liuyang0/p/6271331.html 广度优先搜索广度优先搜索（BFS, breadth-first search），它的思想是从一个顶点开始，辐射状地优先遍历其周围较广的区域。 层序遍历层序遍历，顾名思义，就是二叉树按照从根节点到叶子节点的层次关系，一层一层横向遍历各个节点。 二叉树同一层次的节点之间是没有直接关联的。实现层序遍历，需要借助队列这种数据结构。 123456789101112131415// 二叉树层序遍历public static void levelOrderTraversal(TreeNode root)&#123; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty())&#123; TreeNode node = queue.poll(); System.out.println(node.data); if (node.leftChild != null)&#123; queue.offer(node.leftChild); &#125; if (node.rightChild != null)&#123; queue.offer(node.rightChild); &#125; &#125;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://vanessayaoyao.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"tree","slug":"tree","permalink":"https://vanessayaoyao.github.io/tags/tree/"}]},{"title":"哈希是什么神奇东东？","slug":"hash","date":"2022-03-12T12:17:12.000Z","updated":"2022-03-12T13:16:16.019Z","comments":true,"path":"2022/03/12/hash/","link":"","permalink":"https://vanessayaoyao.github.io/2022/03/12/hash/","excerpt":"","text":"最早听说哈希应该是哪位学长说过数据库密码要加密，最好是什么哈希加密。从此哈希一词就在我脑海中留下了高深莫测的印象。 什么是hash查查百度 Hash，一般翻译做散列、杂凑，或音译为哈希，是把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。 什么鬼。。能说点人话吗。。 刚才在看《漫画算法小灰的算法之旅》，突然感觉懂了，以下是正文。 再如我们需要统计一本英文书里某些单词出现的频率，就需要遍历整本书的内容，把这些单词出现的次数记录在内存中。因为这些需求，一个重要的数据结构诞生了，这个数据结构叫作散列表 。 散列表也叫作哈希表 （hash table），这种数据结构提供了键（Key） 和值（Value） 的映射关系。只要给出一个Key，就可以高效查找到它 所匹配的Value，时间复杂度接近于O(1) 。 以下是小灰（菜鸟）和大黄（大佬）的对话 那么，散列表是如何根据Key来快速找到它所匹配的Value呢？ 这就是我下面要讲的散列表的基本原理。 小灰，在咱们之前学过的几个数据结构中，谁的查询效率最高？ 当然是数组喽，数组可以根据下标，进行元素的随机访问。 说得没错，散列表在本质上也是一个数组。 可是数组只能根据下标，像a[0]、a[1]、 a[2]、a[3]、a[4]这样来访问，而散列表的Key则是以字符串类型为主的。 例如以学生的学号作为Key，输入 002123，查询到李四；或者以单词为Key，输入by，查询到数字 46…… 所以我们需要一个“中转站”，通过某 种方式，把Key和数组下标进行转换。这个中转站就叫作哈希函数。 这个所谓的哈希函数是怎么实现的呢？ 在不同的语言中，哈希函数的实现方式是不一样的。这里以Java的常用 集合HashMap为例，来看一看哈希函数在Java中的实现。 在Java及大多数面向对象的语言中，每一个对象都有属于自己的 hashcode，这个hashcode是区分不同对象的重要标识。无论对象自身的类型是什么，它们的hashcode都是一个整型变量。 既然都是整型变量，想要转化成数组的下标也就不难实现了。最简单的 转化方式是什么呢？是按照数组长度进行取模运算。 index = HashCode (Key) % Array.length 实际上，JDK（Java Development Kit，Java语言的软件开发工具包）中 的哈希函数并没有直接采用取模运算，而是利用了位运算的方式来优化 性能。不过在这里可以姑且简单理解成取模操作。 通过哈希函数，我们可以把字符串或其他类型的Key，转化成数组的下标index。 如给出一个长度为8的数组，则当key=001121时，index = HashCode (“001121”) % Array.length = 1420036703 % 8 = 7 而当key=this时， index = HashCode (“this”) % Array.length = 3559070 % 8 = 6 它其实就是一个算法，最简单的算法就是加减乘除，比方，我设计个数字算法，输入+7=输出，比如我输入1，输出为8；输入2，输出为9。 哈希算法不过是一个更为复杂的运算，它的输入可以是字符串，可以是数据，可以是任何文件，经过哈希运算后，变成一个固定长度的输出，该输出就是哈希值。但是哈希算法有一个很大的特点，就是你不能从结果推算出输入,所以又称为不可逆的算法。 常见 Hash 算法有 MD5 和 SHA 系列，目前 MD5 和 SHA1 已经被破解，一般推荐至少使用 SHA2-256 算法。 哈希特性 不可逆：在具备编码功能的同时，哈希算法也作为一种加密算法存在。即，你无法通过分析哈希值计算出源文件的样子，换句话说：你不可能通过观察香肠的纹理推测出猪原来的样子。 计算极快：20G高清电影和一个5K文本文件复杂度相同，计算量都极小，可以在0.1秒内得出结果。也就是说，不管猪有多肥，骨头多硬，做成香肠都只要眨眨眼的时间。 哈希的用途哈希算法的不可逆特性使其在以下领域使用广泛： 1、密码，我们日常使用的各种电子密码本质上都是基于hash的，你不用担心支付宝的工作人员会把你的密码泄漏给第三方，因为你的登录密码是先经过 hash+各种复杂算法得出密文后 再存进支付宝的数据库里的。 2、文件完整性校验，通过对文件进行hash，得出一段hash值 ，这样文件内容以后被修改了，hash值就会变。 MD5 Hash算法的”数字指纹”特性，使它成为应用最广泛的一种文件完整性校验和(Checksum)算法，不少Unix系统有提供计算md5 checksum的命令。 3、数字签名，数字签名技术是将摘要信息用发送者的私钥加密，与原文一起传送给接收者。接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与解密的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。 此外，hash算法在区块链领域也使用广泛。 基于hash的数据结构有哪些？python中有字典dict和集合set","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://vanessayaoyao.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"data structures","slug":"data-structures","permalink":"https://vanessayaoyao.github.io/tags/data-structures/"}]},{"title":"Python中的装饰器","slug":"decorator","date":"2022-03-02T13:02:03.000Z","updated":"2022-03-24T12:28:01.830Z","comments":true,"path":"2022/03/02/decorator/","link":"","permalink":"https://vanessayaoyao.github.io/2022/03/02/decorator/","excerpt":"","text":"Python中的装饰器 (Decorator)无参数无返回值12345678910111213141516171819202122import time# 判断是否为质数def is_prime(num): if num &lt; 2: return False elif num == 2: return True else: for i in range(2, num): if num % i == 0: return False return True# 输出1-10000的质数，并输出运行时间def prime_nums(): t1 = time.time() for i in range(2, 10000): if is_prime(i): print(i) t2 = time.time() print(t2 - t1)# 计时与逻辑并存，可读性低prime_nums() 123456789101112131415def display_time(func): # 函数套函数 def wrapper(): t1 = time.time() func() # 函数放这 t2 = time.time() print(t2 - t1) return wrapper@display_timedef prime_nums(): for i in range(2, 10000): if is_prime(i): print(i)prime_nums() # 这时运行prime_nums()，实际运行的是display_time 有返回值12345678910@display_timedef count_prime_nums(): count = 0 for i in range(2, 10000): if is_prime(i): count += 1 return count# 不修改装饰器的话count = count_prime_nums()print(count) # 返回值为None 12345678def display_time(func): def wrapper(): t1 = time.time() result = func() # 接收返回值 t2 = time.time() print(&quot;Total time: &#123;:.4&#125; s&quot;.format(t2 - t1)) return result # 返回该值 return wrapper 有参数12345678910111213141516171819def display_time(func): def wrapper(*args): # *args代表有参数，不知道几个，有几个你给我传几个 t1 = time.time() result = func(*args) # 这里同样是 *args t2 = time.time() print(&quot;Total time: &#123;:.4&#125; s&quot;.format(t2 - t1)) return result return wrapper @display_timedef count_prime_nums(maxnum): count = 0 for i in range(1, maxnum): if is_prime(i): count = count + 1 return count count = count_prime_nums(10000)print(count) Java 中的注解 (Annotation) 看到那个@就感觉挺像的。一快看看吧。 注解可以被标注在任意地方，包括方法上、类名上、参数上、成员属性上、注解定义上等，就像注释一样，它相当于我们对某样东西的一个标记。而与注释不同的是，注解可以通过反射在运行时获取，注解也可以选择是否保留到运行时。 额。。反射。。又是不会的东西。。基础不牢，地动山摇。暂时没有迫切想要了解的心，一时半会也用不到，就先这样吧。","categories":[{"name":"Web相关","slug":"Web相关","permalink":"https://vanessayaoyao.github.io/categories/Web%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"decorator","slug":"decorator","permalink":"https://vanessayaoyao.github.io/tags/decorator/"}]},{"title":"什么是跨域？","slug":"cross-domain","date":"2022-02-28T08:05:10.000Z","updated":"2022-03-01T05:00:06.288Z","comments":true,"path":"2022/02/28/cross-domain/","link":"","permalink":"https://vanessayaoyao.github.io/2022/02/28/cross-domain/","excerpt":"","text":"什么是跨域？ 跨域请求这个词听说过，但是我其实并没有真正了解过，也没有遇到过。因为出bug不是出在我这边😂，可以的话还是去学学vue吧。之前和web组合作的时候，跨域也是前端去解决的。现在社团新学期项目也开始了，昨天开会的时候，提到这个跨域问题，说是让后端解决。我也来学学吧。 跨域：指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对javascript施加的安全限制。 浏览器的同源策略同源策略：是指协议，域名，端口都要相同，其中有一个不同都会产生跨域。同源策略是为了保证用户信息的安全，防止恶意的网站窃取数据。浏览器中的大部分内容都是受同源策略限制的，但对于像 img、iframe、script 等标签的 src 属性是特例，它们是可以访问非同源网站的资源的。 现在想想后端算一个项目，前端算一个项目，分两拨人写肯定不是协议域名端口都相同。后端先部署一部分接口在服务器上，vue在本地127.0.0.1上去调接口肯定是跨域了。就算是只有一个人去写前后端分离的项目，前端工程和后端工程都在127.0.0.1下，两个项目端口号肯定不能一样，这样也是跨域了。 如何解决跨域问题？CORS跨域资源分享CORS是跨域资源分享的缩写，能够彻底解决Ajax的跨域问题，同时允许任意类型的请求。需要服务器响应头中增加下面一种或几种 1234567891011//*表示允许任意源的访问，也可以指定特定的源1.Access-Control-Allow-Origin：* //表示跨域访问时带上cookie，需同时在ajax请求中设置`withCredentials: true`，2.Access-Control-Allow-Credentials: true//预检请求后响应的必须字段，返回所有支持的方法，而不单是浏览器请求的那个方//法。这是为了避免多次&quot;预检&quot;请求3.Access-Control-Allow-Methods: GET, POST, PUT//预检请求后响应的必须字段，放入预检请求时请求所带的头4.Access-Control-Allow-Headers：Content-Type//允许浏览器在指定时间内，无需再发送预检请求进行协商，直接用本次协商结果即可5.Access-Control-Max-Age: 1728000 当一个资源(origin)通过脚本向另一个资源(host)发起请求，而被请求的资源(host)和请求源(origin)是不同的源时(协议、域名、端口不全部相同)，浏览器就会发起一个 跨域 HTTP 请求，并且浏览器会自动将当前资源的域添加在请求头中一个叫 Origin 的 Header 中。通过在响应报文中设置额外的 HTTP 响应头来告诉浏览器，运行在某个 origin 上的 Web 应用被准许访问来自不同源服务器上的资源，此时浏览器就不会将该响应拦截掉了。 CORS请求分为简单请求(HEAD、GET、POST)和非简单请求(PUT或DELETE或Content-Type为application) 非简单请求会向发一个预检请求(preflight)，请求类型为OPTION，收到预检请求的响应后再发送真正的请求，这个时候的请求与简单请求无异。 简单地说下CORS请求会携带的头信息 123456//必要请求头，表示当前源，相应的预检响应需要返回Access-Control-Allow-Origin1.Origin//预检时会带上的头，表示真正请求的方法，相应的预检响应需要返回Access-Control-Allow-Method2.Access-Control-Request-Method//预检时会带上的头，表示真正请求会额外发送的头信息，相应的预检响应需要返回Access-Control-Allow-Headers3.Access-Control-Request-Headers 怎样实现CORS通过JSONP只支持GET 前端去搞的 利用反向代理服务器如果是服务器向服务器请求就无需遵循同源策略。 所以通过反向代理服务器可以有效的解决跨域问题，代理服务器需要做以下几个步骤： 1.接受客户端的请求 2.将请求转发给实际的服务器 3.将服务器的响应结果返回给客户端 Nginx就是类似的反向代理服务器，可以通过配置Nginx代理来解决跨域问题。 nginx不太熟，只配置过。抽空学学。 服务端支持CORS, 以Django为例最安全的还是服务端来设置允许哪些来源的请求，即服务端在接收到请求之后，对允许的请求源设置Access-Control-Allow-Origin 的响应头。 1pip install django-cors-headers settings.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344INSTALLED_APPS = [ ... &#x27;corsheaders&#x27;， ... ] MIDDLEWARE = [ &#x27;django.middleware.security.SecurityMiddleware&#x27;, &#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;, &#x27;corsheaders.middleware.CorsMiddleware&#x27;, #注意顺序，必须放在这儿 &#x27;django.middleware.common.CommonMiddleware&#x27;, ... ]# 跨域增加忽略CORS_ALLOW_CREDENTIALS = TrueCORS_ORIGIN_ALLOW_ALL = TrueCORS_ORIGIN_WHITELIST = ( &#x27;*&#x27;)CORS_ALLOW_METHODS = ( &#x27;DELETE&#x27;, &#x27;GET&#x27;, &#x27;OPTIONS&#x27;, &#x27;PATCH&#x27;, &#x27;POST&#x27;, &#x27;PUT&#x27;, &#x27;VIEW&#x27;,)CORS_ALLOW_HEADERS = ( &#x27;XMLHttpRequest&#x27;, &#x27;X_FILENAME&#x27;, &#x27;accept-encoding&#x27;, &#x27;authorization&#x27;, &#x27;content-type&#x27;, &#x27;dnt&#x27;, &#x27;origin&#x27;, &#x27;user-agent&#x27;, &#x27;x-csrftoken&#x27;, &#x27;x-requested-with&#x27;, &#x27;Pragma&#x27;,) 仍需继续学习! 参考链接： https://zhuanlan.zhihu.com/p/145837536 https://www.jianshu.com/p/f4fc1ce49956","categories":[{"name":"Web相关","slug":"Web相关","permalink":"https://vanessayaoyao.github.io/categories/Web%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"CROS","slug":"CROS","permalink":"https://vanessayaoyao.github.io/tags/CROS/"}]},{"title":"Data Structures & Algorithms Part 1-2","slug":"data-structures-algorithms-part1-2","date":"2022-02-11T07:19:31.000Z","updated":"2022-03-24T12:24:34.383Z","comments":true,"path":"2022/02/11/data-structures-algorithms-part1-2/","link":"","permalink":"https://vanessayaoyao.github.io/2022/02/11/data-structures-algorithms-part1-2/","excerpt":"","text":"救。。。快点学习。。。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://vanessayaoyao.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"data structures","slug":"data-structures","permalink":"https://vanessayaoyao.github.io/tags/data-structures/"}]},{"title":"Data Structures & Algorithms Part 1-1","slug":"data-structures-algorithms-part1","date":"2022-02-03T10:48:03.000Z","updated":"2022-03-24T12:27:56.057Z","comments":true,"path":"2022/02/03/data-structures-algorithms-part1/","link":"","permalink":"https://vanessayaoyao.github.io/2022/02/03/data-structures-algorithms-part1/","excerpt":"","text":"Data Structures and algorithms for beginners. Ace your coding interview. Watch this tutorial to learn all about Big O, arrays and linked lists! Big O NatationWe use Big O to describe the performance of an algorithm. scalable how much on an algorithm slows down as the input grows larger O(1)Constant time 12345public void log(int[] numbers)&#123; // O(1) System.out.println(numbers[0]); System.out.println(numbers[0]);&#125; O(n)linear 12345public void log(int[] numbers)&#123; // O(n) n-&gt;size of the input for (int i = 0; i &lt; numbers.length; i++) System.out.println(numbers[i]);&#125; O(n^2)quadratic 12345public void log(int[] numbers)&#123; for (int first : numbers) for (int second : numbers) System.out.println(first + &quot;, &quot; + second);&#125; O(log n)logarithmic Binary search 二分法 1 million items in an array, find the target item with a maximum of 19 comparisons O(2^n)exponential Space Complexitythe additional space that we should allocate relative to the size of the input 1234567public void greet(String[] names)&#123; // O(1) space for (int i = 0; i &lt; names.length; i++) System.out.println(&quot;Hi &quot; + names[i]); // O(n) space String[] copy = new String[names.length];&#125; Arraysstrored sequentially in memory Lookup O(1) Insert O(n) Delete O(n) Exercise: Building an Array1234567891011121314151617181920212223242526272829303132333435363738394041public class Array &#123; private int[] items; private int count; public Array(int length)&#123; items = new int[length]; &#125; public void insert(int item)&#123; // If the array is full, resize it if (items.length == count)&#123; // Create a new array (twice the size) int[] newItems = new int[count * 2]; // Copy all the existing items for (int i = 0; i &lt; count; i++) newItems[i] = items[i]; // Set &quot;items&quot; to this new array items = newItems; &#125; // Add the new item at the end items[count++] = item; &#125; public void removeAt(int index) &#123; // Validate the index if (index &lt; 0 || index &gt;= count) throw new IllegalStateException(); // Shift the items to the left to fill the hole for (int i = index; i &lt; count; i++) items[i] = items[i+1]; count--; &#125; public int indexOf(int item) &#123; // If we find it, return index. Otherwise, return -1 for (int i = 0;i &lt; count; i++) if (items[i] == item) return i; return -1; &#125; public void print()&#123; for (int i = 0; i &lt; count; i++) System.out.println(items[i]); &#125;&#125; Dynamic Arrays12345678910111213&#x2F;&#x2F; java has two implementations of dynamic arrays&#x2F;&#x2F; Vector: 100% - synchronized&#x2F;&#x2F; ArrayList: 50%ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();list.add(10);list.add(20);list.add(30);list.remove(0);list.indexOf(20);list.contains(1);list.size();list.toArray();System.out.println(list); Linked Lists链表 consistd of a group of nodes in sequence Lookup by value O(n) by index O(n) Insert At the end O(1) At the beginning O(1) In the middle O(n) delete From the beginning O(1) From the end O(n) 得找到倒数第二个结点 From the middle O(n) 1234567891011LinkedList list = new LinkedList();list.addLast(10);list.addLast(20);list.addLast(30);list.addFirst(&quot;hah&quot;);list.removeLast();list.contains(10);list.indexOf(10);list.size();Object[] array = list.toArray();System.out.println(Arrays.toString(array)); Exercise: Building a Linked List123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109import java.util.NoSuchElementException;public class LinkedList &#123; private class Node &#123; private int value; private Node next; public Node(int value) &#123; this.value = value; &#125; &#125; private Node first; private Node last; private int size; public void addLast(int item) &#123; Node node = new Node(item); if (isEmpty()) first = last = node; else &#123; last.next = node; last = node; &#125; size++; &#125; public void addFirst(int item) &#123; Node node = new Node(item); if (isEmpty()) first = last = node; else &#123; node.next = first; first = node; &#125; size++; &#125; public int indexOf(int item) &#123; int index = 0; Node current = first; while (current != null)&#123; if (current.value == item) return index; current = current.next; index++; &#125; return -1; &#125; public boolean contains(int item) &#123; return indexOf(item) != -1; &#125; public void removeFirst() &#123; if(isEmpty()) throw new NoSuchElementException(); if(first == last)&#123; first = last = null; size = 0; return; &#125; Node second = first.next; first.next = null; first = second; size--; &#125; public void removeLast() &#123; Node previous = getPrevious(last); if(isEmpty()) throw new NoSuchElementException(); if(first == last)&#123; first = last = null; size = 0; return; &#125; last = previous; last.next = null; size--; &#125; private Node getPrevious(Node node)&#123; Node current = first; while (current != null) &#123; if (current.next == node) return current; current = current.next; &#125; return null; &#125; public int size() &#123; return size; &#125; public int[] toArray() &#123; int[] array = new int[size]; Node current = first; int index = 0; while (current != null)&#123; array[index++] = current.value; current = current.next; &#125; return array; &#125; private boolean isEmpty() &#123; return first == null; &#125;&#125; Arrays vs Linked ListsSPACE Static arrays have a fixed size Dynamic arrays grow by 50-100% Linked lists don’t waste memory Use arrays if you know the number of items to store new ArrayList(100) Types of Linked Lists Your transcript or degree is not a reflection of your knowledge or capabilities. Exercise: Reversing a Linked List12345678910111213141516public void reverse()&#123; // [10 20 30] // p c n if (isEmpty()) return; Node previous = first; Node current = first.next; while (current != null)&#123; Node next = current.next; current.next = previous; previous = current; current = next; &#125; last = first; last.next = null; first = previous;&#125; Exercise: Kth Node form the EndFind the Kth node from the end of a linked list in one pass. 12345678910111213141516public int getKthFromTheEnd(int k)&#123; if (isEmpty()) throw new IllegalStateException(); Node a = first; Node b = first; for (int i = 0; i &lt; k - 1; i++) &#123; b = b.next; if (b == null) throw new IllegalArgumentException(); &#125; while (b != last)&#123; a = a.next; b = b.next; &#125; return a.value;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://vanessayaoyao.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"data structures","slug":"data-structures","permalink":"https://vanessayaoyao.github.io/tags/data-structures/"}]},{"title":"Java Part 3 - Advanced Topics","slug":"learning-java-3","date":"2022-01-21T15:52:29.000Z","updated":"2022-03-24T12:24:08.026Z","comments":true,"path":"2022/01/21/learning-java-3/","link":"","permalink":"https://vanessayaoyao.github.io/2022/01/21/learning-java-3/","excerpt":"","text":"Advanced Java FeaturesExceptionsthe stack trace in reverse order Types of Exceptions Checked eg.读取文件时,应该预测到文件不存在时怎么办 Unchecked or Runtime Exceptions NullPointerException 指针异常，传入空值 ArithmeticException 算术异常，除以0 IllegalArgumentException 传入非法参数 IndexOutofBoundsException 索引越界 IllegalStateException the underlying object is not in the right state Error an error external to our application 堆叠溢出 内存溢出 Exceptions Hierarchy Catching Exceptions12345678910public void show()&#123; try &#123; FileReader reader = new FileReader(&quot;file.txt&quot;); System.out.println(&quot;File opened&quot;); &#125;catch (FileNotFoundException ex)&#123; System.out.println(&quot;File does not exist.&quot;); System.out.println(ex.getMessage()); //file.txt (系统找不到指定的文件。) &#125;&#125; trick: alt+enter→Surround with try/catch Catching Multiple Types of Exceptions123456789101112try &#123; FileReader reader = new FileReader(&quot;file.txt&quot;); int value = reader.read();&#125;catch (FileNotFoundException e)&#123; System.out.println(e.getMessage());&#125;catch (IOException e)&#123; System.out.println(&quot;Could not read data.&quot;);&#125;try&#123; &#125;catch(IOException | ParseException e)&#123;&#125; The finally Block12345678910111213141516FileReader reader = null;try &#123; reader = new FileReader(&quot;file.txt&quot;); int value = reader.read();&#125;catch (IOException e)&#123; System.out.println(&quot;Could not read data.&quot;);&#125;finally &#123; //ugly if(reader!=null) &#123; try &#123; reader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; The try-with-resources Statement123456789try( FileReader reader = new FileReader(&quot;file.txt&quot;); ....//other object) &#123; int value = reader.read();&#125;catch (IOException e)&#123; System.out.println(&quot;Could not read data.&quot;);&#125;//与上面代码效果相同，不用写finally不用关文件.automatically Throwing Exceptions12345public void deposit(float value)&#123; if (value&lt;=0) throw new IllegalArgumentException(); //defensive programming&#125; 1234567891011public void deposit(float value) throws IOException&#123; if (value&lt;=0) throw new IOException();&#125;Account account = new Account();try &#123; account.deposit(1);&#125; catch (IOException e) &#123; e.printStackTrace();&#125; Re-throwing Exceptions1234567891011121314public static void main(String[] args) throws IOException &#123; Account account = new Account(); try &#123; account.deposit(1); &#125; catch (IOException e) &#123; System.out.println(&quot;Logging&quot;); throw e; &#125;&#125;try&#123; ...&#125; catch(Throwable e)&#123; System.out.println(&quot;error occcured.&quot;);&#125; Custom Exception自定义异常 12345678910111213141516//checked -&gt;Exception//unchecked(runtime) -&gt;RuntimeExceptionpublic class InsufficientFundsException extends Exception &#123; public InsufficientFundsException()&#123; System.out.println(&quot;Insufficient funds in your account&quot;); &#125; public InsufficientFundsException(String message)&#123; super(message); &#125;&#125;public void withdraw(float value) throws InsufficientFundsException &#123; if (value&gt;balance) throw new InsufficientFundsException();&#125; Chaining Exceptions12345678public void withdraw(float value) throws AccountException &#123; if (value&gt;balance)&#123; InsufficientFundsException fundsException = new InsufficientFundsException(); AccountException accountException = new AccountException(); accountException.initCause(fundsException); throw accountException; &#125;&#125; 1234567891011public class AccountException extends Exception&#123; public AccountException(Exception cause)&#123; super(cause); &#125;&#125;public void withdraw(float value) throws AccountException &#123; if (value&gt;balance)&#123; AccountException accountException = new AccountException(new InsufficientFundsException()); throw accountException; &#125;&#125; Generics泛型 1234public class List&#123; private Object[] items = new Objects[10]; //Object class is the parent of all reference types&#125; Generic Classes1234567891011121314public class GenericList&lt;T&gt; &#123; private T[] items = (T[]) new Object[10]; private int count; public void add(T item)&#123; items[count++] = item; &#125; public T get(int index)&#123; return items[index]; &#125;&#125;GenericList&lt;Integer&gt; list = new GenericList&lt;&gt;();list.add(1); Generics and Primitive Typesint -&gt; Integer float -&gt; Float boolean -&gt; Boolean 123GenericList&lt;Integer&gt; numbers = new GenericList&lt;&gt;();numbers.add(1); //Boxingint number = numbers.get(0); //Unboxing Constraints123456public class GenericList&lt;T extends Number&gt; &#123; // wrapper class of Interger Float Short...&#125;public class GenericList&lt;T extends Comparable &amp; Cloneable&gt; &#123; &#125; Type Erasure类型消除 Java compiler erases these type parameters and replaces them with a class or an interface depending on the constraints. The Comparable Interface12345678910111213141516public class User implements Comparable&lt;User&gt;&#123; private int points; public User(int points) &#123; this.points = points; &#125; @Override public int compareTo(User other) &#123; // this &lt; other -&gt; -1 // this == other -&gt; 0 // this &gt;other -&gt; 1 return points - other.points; &#125;&#125;user1.compareTo(user2) // &gt;&lt; 大于号小于号只能比较数字和字符 Generic Methods12345public class Utils &#123; public static &lt;T extends Comparable&lt;T&gt;&gt; T max(T first, T second)&#123; return (first.compareTo(second) &gt; 0) ? first : second; &#125;&#125; Multiple Type Paramaters123456789public class Utils &#123; public static &lt;K, V&gt; void print(K key, V value)&#123; System.out.println(key + &quot;=&quot; + value); &#125;&#125;public class KeyValuePair&lt;K, V&gt;&#123; private K key; private V value;&#125; Generic Classes and Inheritanceinstructor extends user printUsers GenericList&lt;Instructor&gt;不能调用printUsers Wildcards12345678// class CAP#1 extends User &#123;&#125;// class Instructor extends User &#123;&#125;public static void printUsers (GenericList&lt;? extends User&gt; users)&#123;//read // super add User x = users.get(0);&#125;Utils.printUsers(new GenericList&lt;Instructor&gt;()) CollectionsCollections Framework queue 队列 set无重复 The Iterables Interface we can iterate or loop over it. 123456public class GenericList&lt;T&gt; implements Iterable&lt;T&gt;&#123; @Override public Iterator&lt;T&gt; iterator() &#123; return null; //not finished yet &#125;&#125; 123456789GenericList&lt;String&gt; list = new GenericList&lt;&gt;();// Iterator iterator = list.iterator();// while(iterator.hasNext())&#123;// Object current = iterator.next();// System.out.println(current);// &#125;for(Object item: list) System.out.println(item);&#125; The Iterator Interface12345678910111213141516171819202122232425262728293031323334public class GenericList&lt;T&gt; implements Iterable&lt;T&gt;&#123; private T[] items = (T[]) new Object[10]; private int count; public void add(T item)&#123; items[count++] = item; &#125; public T get(int index)&#123; return items[index]; &#125; @Override public Iterator&lt;T&gt; iterator() &#123; return new ListIterator(this); &#125; private class ListIterator implements Iterator&lt;T&gt;&#123; private GenericList&lt;T&gt; list; private int index; public ListIterator(GenericList&lt;T&gt; list) &#123; this.list = list; &#125; @Override public boolean hasNext() &#123; return (index &lt; list.count); &#125; @Override public T next() &#123; return list.items[index++]; &#125; &#125;&#125; The Collection Interfaceadd() remove() contains() E–&gt; elements 1234567891011121314151617public class CollectionsDemo &#123; public static void show()&#123; Collection&lt;String&gt; collection = new ArrayList&lt;&gt;(); collection.add(&quot;a&quot;); collection.add(&quot;b&quot;); collection.add(&quot;c&quot;); //或者 Collections.addAll(collection, &quot;a&quot;,&quot;b&quot;,&quot;c&quot;); collection.remove(&quot;a&quot;); for(String item: collection) System.out.println(item); collection.clear(); collection.isEmpty();//true or false collection.contains(&quot;a&quot;);//true or false collection.toArray(new String[3]);//或者String[0] &#125;&#125; 1234Collection&lt;String&gt; other = new ArrayList&lt;&gt;();other.addAll(collection);collection == other; // falsecollection.equals(other); //true The List Interfacesequence 序列 index 123456789101112 List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;a&quot;);list.add(&quot;b&quot;);list.add(0,&quot;!&quot;);System.out.println(list); //[!,a,b]Collections.addAll(list,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);list.get(0);list.set(0,&quot;a+&quot;);list.remove(0);list.indexOf(&quot;a&quot;);//第一次出现的索引list.lastIndexof(&quot;a&quot;);list.subList(0,2);//[a,b] 原list不受影响 The Comparable Interfacehow to sort data 1234567891011121314151617public class Customer implements Comparable&lt;Customer&gt; &#123; private String name; public Customer(String name) &#123; this.name = name; &#125; @Override public int compareTo(Customer other) &#123; return name.compareTo(other.name); &#125; @Override public String toString() &#123; return name; &#125;&#125; 123456List&lt;Customer&gt; customers = new ArrayList&lt;&gt;();customers.add(new Customer(&quot;c&quot;));customers.add(new Customer(&quot;d&quot;));customers.add(new Customer(&quot;a&quot;));Collections.sort(customers);System.out.println(customers); //[a,c,d] The Comparator Interface12345678910111213public class EmailComparator implements Comparator&lt;Customer&gt; &#123; @Override public int compare(Customer o1, Customer o2) &#123; return o1.getEmail().compareTo(o2.getEmail()); &#125;&#125;List&lt;Customer&gt; customers = new ArrayList&lt;&gt;();customers.add(new Customer(&quot;c&quot;,&quot;e3&quot;));customers.add(new Customer(&quot;d&quot;,&quot;e2&quot;));customers.add(new Customer(&quot;a&quot;,&quot;e1&quot;));Collections.sort(customers, new EmailComparator());//[a,d,c]System.out.println(customers); The Queue Interfacecollection situation we want to process jobs based on the order we receive them 打印机 PriorityQueue ArrayDeque 123456789101112public static void main(String[] args) &#123; Queue&lt;String&gt; queue = new ArrayDeque&lt;&gt;(); queue.add(&quot;c&quot;); queue.add(&quot;a&quot;); queue.add(&quot;b&quot;); // queue.offer(&quot;d&quot;); // b-&gt;a-&gt;c String front = queue.peek(); System.out.println(front); // c queue.remove(); // c queue.poll(); // null&#125; The Set Interface唯一值 123456Set&lt;String&gt; set = new HashSet&lt;&gt;();set.add(&quot;sky&quot;);set.add(&quot;sky&quot;);set.add(&quot;is&quot;);set.add(&quot;bule&quot;);System.out.println(set); // [sky, bule, is] 去重 1234Collection&lt;String&gt; collection = new ArrayList&lt;&gt;();Collections.addAll(collection,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;);Set&lt;String&gt; set = new HashSet&lt;&gt;(collection);System.out.println(set); // [a,b] 12345678Set&lt;String&gt; set1 = new HashSet&lt;&gt;(Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;));Set&lt;String&gt; set2 = new HashSet&lt;&gt;(Arrays.asList(&quot;b&quot;,&quot;c&quot;,&quot;d&quot;));// Unionset1.addAll(set2); // set1 [a,b,c,d]//Intersectionset1.retainAll(set2); // [b,c]// Differenceset1.removeAll(set2); // [a] Hash TablesJava: Maps C#: Dictionary Python: Dictionary JavaScript: Objects The Map Interface123456789101112131415161718192021Customer c1 = new Customer(&quot;a&quot;, &quot;e1&quot;);Customer c2 = new Customer(&quot;b&quot;, &quot;e2&quot;);Map&lt;String, Customer&gt; map = new HashMap&lt;&gt;(); // not iterablemap.put(c1.getEmail(),c1);map.put(c2.getEmail(),c2);Customer customer = map.get(&quot;e1&quot;);System.out.println(customer); // a nullCustomer unknown = new Customer(&quot;Unknown&quot;,&quot;&quot;);map.getOrDefault(&quot;e10&quot;, unknown);Boolean exists = map.containsKey(&quot;e10&quot;);map.replace(&quot;e1&quot;, new Customer(&quot;a++&quot;,&quot;e1&quot;));for (String key: map.keySet())&#123; System.out.println(key);&#125;for (Map.Entry&lt;String, Customer&gt; key: map.entrySet())&#123; System.out.println(key); // e1=a e2=b // key.getValue()&#125;//map.values() Lambda Expressions and Functional InterfacesFunctional Interfaces An interface with a single abstract method 123456789101112131415161718public interface Printer &#123; void print(String message);&#125;public class ConsolePrinter implements Printer&#123; @Override public void print(String message) &#123; System.out.println(message); &#125;&#125;public class LambdasDemo &#123; public static void show()&#123; greet(new ConsolePrinter()); &#125; public static void greet(Printer printer)&#123; printer.print(&quot;Hello World&quot;); &#125;&#125; Anonymous Inner Class匿名内部类 12345678public static void show()&#123; greet(new Printer() &#123; @Override public void print(String message) &#123; System.out.println(message); &#125; &#125;);&#125; Lambda Expressions123456789public static void show()&#123; greet(( String message) -&gt;&#123; System.out.println(message); &#125;); // or in a more clear way greet(message -&gt; System.out.println(message));&#125;Printer printer = message -&gt; System.out.println(message); // an objectPrinter printer = new ConsolePrinter(); Variable Capture1234public static void show()&#123; String prefix = &quot;-&quot;; greet(message -&gt; System.out.println( prefix+message));&#125; Method References1234greet(message -&gt; System.out.println(message));//Class/Object::methodgreet(System.out::println);//equal 123456789101112public static void print(String message)&#123;&#125;public static void show()&#123; greet(message -&gt; print(message)); greet(LambdasDemo::print);&#125;public void print(String message)&#123;&#125;public static void show()&#123; LambdasDemo demo = new LambdasDemo(); greet(message -&gt; demo.print(message)); greet(demo::print);&#125; 12345public LambdasDemo(String message) &#123;&#125;public static void show()&#123; greet(message -&gt; new LambdasDemo(message)); greet(LambdasDemo::new);&#125; Build-in Functional Interfacesfour types of functional interfaces Consumer void consume(obj) Supplier obj supply() Function obj map(obj) Predicate bool test(condition) The Consumer Interface123456789public static void show()&#123; List&lt;Integer&gt; list = Arrays.asList(1,2,3); // Imperative Programming(for, if/else, switch/case) for(int item: list)&#123; System.out.println(item); &#125; //Declarative Programming list.forEach(System.out::println);&#125; Chaining Consumers1234567public static void show()&#123; List&lt;String&gt; list = Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;); Consumer&lt;String&gt; print = System.out::println; Consumer&lt;String&gt; printUpperCase = item -&gt; System.out.println(item.toUpperCase()); list.forEach(print.andThen(printUpperCase)); // a A b B c C&#125; The Supplier Interface12345public static void show()&#123; Supplier&lt;Double&gt; getRandom = Math::random; // () -&gt; Math.random(); double random = getRandom.get(); System.out.println(random);&#125; The Function Interface12345public static void show()&#123; Function&lt;String, Integer&gt; map = str -&gt; str.length(); int length = map.apply(&quot;Sky&quot;); System.out.println(length);&#125; Composing Function12345678910111213public static void show()&#123; // &quot;key: value&quot; // first: &quot;key=value&quot; // second: &quot;&#123;key=value&#125;&quot; Function&lt;String, String&gt; replaceColon = str -&gt; str.replace(&quot;:&quot;,&quot;=&quot;); Function&lt;String, String&gt; addBraces = str -&gt; &quot;&#123;&quot; + str + &quot;&#125;&quot;; //Declarative Programming String result = replaceColon .andThen(addBraces) .apply(&quot;key:value&quot;); result = addBraces.compose(replaceColon).apply(&quot;key:value&quot;); System.out.println(result);&#125; The Predicate Interface12345public static void show()&#123; Predicate&lt;String&gt; isLongerThan5 = str -&gt; str.length() &gt; 5; boolean result = isLongerThan5.test(&quot;sky&quot;); System.out.println(result);&#125; Combining Predicates123456public static void show()&#123; Predicate&lt;String&gt; hasLeftBrace = str -&gt; str.startsWith(&quot;&#123;&quot;); Predicate&lt;String&gt; hasRightBrace = str -&gt; str.endsWith(&quot;&#125;&quot;); // and() or() negate() Predicate&lt;String&gt; hasLeftAndRightBraces = hasLeftBrace.and(hasRightBrace); &#125; The BinaryOperator Interface12345public static void show()&#123; BinaryOperator&lt;Integer&gt; add = (a,b) -&gt;a+b; Function&lt;Integer,Integer&gt; square = a -&gt; a * a; int result = add.andThen(square).apply(1,2);&#125; The UniaryOperator Interface12345public static void show()&#123; UnaryOperator&lt;Integer&gt; square = n -&gt; n * n; UnaryOperator&lt;Integer&gt; increment = n -&gt; n + 1; int result = increment.andThen(square).apply(1);&#125; Streams To process a collection of data in a declarative way // functional programming Imperative vs Functional Programming Imperative Declarative How What SQL select * from movies where genre = 1 order by name A sream is a sequence of objects but it’s not like a collection it doesn’t store data. It’s just a way to get data out of a collection. 1234567// Imperative Programming howint count = 0;for(Movie movie : movies) if (movie.getLikes() &gt; 10) count++;// Declarative (Functional) Programming long count2 = movies.stream().filter(movie -&gt; movie.getLikes() &gt; 10).count(); Creating a Stream From collections Collection&lt;Integer&gt; x; From arrays var list = new ArrayList&lt;&gt;(); int [] numbers = {1,2,3}; Arrays.stream(numbers).forEach(n -&gt; System.out.println(n)) **From an arbitrary number of objects ** Stream.of(1,2,3,4) 123456public static void show()&#123; Stream stream = Stream.generate(()-&gt;Math.random()); //lazy evaluation stream.limit(3).forEach(n -&gt; System.out.println(n)); // terminates this streams&#125; Infinite/finite streams 1Stream.iterate(1, n -&gt; n+1).limit(10).forEach(n -&gt; System.out.println(n)); Mapping Elements map() flatMap() Stream&lt;List&lt;x&gt;&gt; -&gt; Stream&lt;x&gt; 12movies.stream().map(movie -&gt; movie.getTitle()) .forEach(name-&gt; System.out.println(name)); 123Stream stream = Stream.of(List.of(1,2,3),List.of(4,5,6));stream.forEach(list -&gt; System.out.println(list)); // [1,2,3] [4,5,6] stream.flatMap(list -&gt; list.stream()).forEach(n -&gt; System.out.println(n)); //1 2 3 4 5 6 Filtering Elements Intermediate Terminal map() filter() limit()/skip() sorted() distinct() peek() forEach() Reducers Slicing a Stream“a” “b” “c” limit(n) limit(2) a b skip(n) skip(2) c 1000 movies 10 movies per page 3rd page skip(20) = skip((page-1) * pageSize) limit(10) = limit(pageSize) takeWhile(predicate) takeWhile(m-&gt;m.getLikes() &lt;30) 遇到即停止 dropWhile(predicate) Sorting Streams12345movies.stream() .sorted((a,b) -&gt; a.getTitle().compareTo(b.getTitle())) .sorted(Comparator.comparing(m-&gt;m.getTitle()).reversed())//逆序 //Movie::getTitle .forEach(m-&gt;System.out.println(m)); Getting Distinct Elements1234movies.stream() .map(Movie::getLikes) .distinct() .forEach(System.out::println); Peeking Elements123456movies.stream() .filter(m-&gt;m.getLikes()&gt;10) .peek(m-&gt;System.out.println(&quot;filtered:&quot;+m.getTitle())) .map(Movie::getTitle) .peek(t-&gt;System.out.println(&quot;mapped:&quot;+t)) .forEach(System.out::println); Simple Reducers count(n) anyMatch(predicate) .anyMatch(m-&gt;m.getLikes()&gt;20) true or false allMatch(predicate) noneMatch(predicate) findFrist() return Optional&lt;Movie&gt; findAny() max(comparator) .max(Comparator.comparing(Movie::getLikes)).get() min(comparator) Reducing a Stream12345Optional&lt;Integer&gt; sum = movies.stream() .map(m-&gt;m.getLikes()) //[10,20,30] .reduce((a+b)-&gt;a+b); // [30,30] -&gt; [60] // .reduce(Integer::sum)sum.orElse(0); //60 Collectorscollect the result of a stream into data structure 1234567List&lt;Movie&gt; result = movies.stream() .filter(m-&gt;m.getLikes(&gt;10)) .collect(Collectors.toList()); //.toSet() //.toMap(Movie::getTitle, Movie::getLikes) &#123;b=20,c=30&#125; //.toMap(Movie::getTitle, Function.identity( )) //.summingInt(Movie::getLikes) //.summarizingInt(Movie::getLikes ) statistics 123movies.stream() .map(Movie::getTitle) .collect(Collectors.joining(&quot;,&quot;)); // a,b,c Grouping Elements123456789101112131415public enum Genre &#123; COMEDY, ACTION, THRILLER&#125;List&lt;Movie&gt; movies = Arrays.asList( new Movie(&quot;a&quot;,1, Genre.THRILLER ), new Movie(&quot;b&quot;,2, Genre.ACTION), new Movie(&quot;c&quot;,3, Genre.ACTION));Map&lt;Genre,List&lt;Movie&gt;&gt; result = movies.stream(). collect(Collectors.groupingBy(Movie::getGenre)); // (, Collectors.counting()) &#123;THRILLER=1, ACTION=2&#125;System.out.println(result);// &#123;ACTION=[com.company.streams.Movie@5b480cf9, com.company.streams.Movie@6f496d9f], THRILLER=[com.company.streams.Movie@723279cf]&#125; Partitioning Elements分区 12345Map&lt;Boolean, String&gt; result = movies.stream() .collect(Collectors.partitioningBy( movie -&gt; movie.getLikes()&gt;20, Collectors.mapping(Movie::getTitle, Collectors.joining(&quot;,&quot;)) )); // &#123;false=a, b, true=c&#125; Primitive Type Streams IntStream .rangeClosed(1,5) 1,2,3,4,5 .range(1,5) 1,2,3,4 LongStream DoubleStream Concurrency and Muti-threadingProcesses and Threads进程和线程 A process is an instance of a program or an applocation. When you launch an application like your code editor or music player, your operating system loads that application inside a process, so a process contains an image of the application code. It has some memory and a bunch of other resources. A thread is a sequence of instructions, actually that thing that executes your code Each process has at least one thread called the main thread. 1234System.out.println(Thread.activeCount()); // 2 One is the mian thread running the main method, the other is a background thread that runs the garbage collectorSystem.out.println(Runtime.getRuntime().availableProcessors());// 8 4核8线程 Starting a Thread123456public class DownloadFileTask implements Runnable&#123; @Override public void run() &#123; System.out.println(&quot;Downloading a file: &quot;+Thread.currentThread().getName()); &#125;&#125; 1234567public static void show()&#123; System.out.println(Thread.currentThread().getName()); Thread thread = new Thread(new DownloadFileTask()); thread.start();&#125;// main// Downloading a file: Thread-0 1234for(int i=0; i&lt;10;i++) &#123; Thread thread = new Thread(new DownloadFileTask()); thread.start();&#125; Downloading a file: Thread-2Downloading a file: Thread-3Downloading a file: Thread-0Downloading a file: Thread-1Downloading a file: Thread-4Downloading a file: Thread-5Downloading a file: Thread-6Downloading a file: Thread-7Downloading a file: Thread-9Downloading a file: Thread-8 at same time parallel Pausing a Thread123456789101112public class DownloadFileTask implements Runnable&#123; @Override public void run() &#123; System.out.println(&quot;Downloading a file: &quot;+Thread.currentThread().getName()); try &#123; Thread.sleep(5000); //暂停5秒 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;Download complete: &quot; + Thread.currentThread().getName()); &#125;&#125; Joining Threads下载完文件后，启动另一个线程来扫描下载文件的病毒。 123456789101112public static void show()&#123; System.out.println(Thread.currentThread().getName()); Thread thread = new Thread(new DownloadFileTask()); thread.start(); try &#123; thread.join(); //使用join tell the current thread to wait for the complection for another thread. &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;File is ready to be scanned.&quot;);&#125; Interrupting a Thread取消功能 1234567891011thread.interrupt();// 发送中断请求，不会强制中断public void run() &#123; System.out.println(&quot;Downloading a file: &quot;+Thread.currentThread().getName()); for(int i=0;i&lt;Integer.MAX_VALUE;i++)&#123; // 判断是否被中断 if(Thread.currentThread().isInterrupted()) return; System.out.println(&quot;Downloading byte &quot;+i); &#125; System.out.println(&quot;Download complete: &quot; + Thread.currentThread().getName());&#125; Concurrency IssuesIf multiple threads try to change the same data If changes are not visibe to other threads Thread-safe Code Race Conditions12345678910public class DownloadStatus &#123; private int totalBytes; public int getTotalBytes() &#123; return totalBytes; &#125; public void incrementTotalBytes()&#123; totalBytes++; // non-atomic operation &#125;&#125; 12345678910111213141516171819public static void show()&#123; DownloadStatus status = new DownloadStatus(); List&lt;Thread&gt; threads = new ArrayList&lt;&gt;(); // 十个下载任务 一个下载一万byte -&gt; 100_000 for(int i = 0; i&lt;10; i++)&#123; Thread thread = new Thread(new DownloadFileTask(status)); thread.start(); threads.add(thread); &#125; for (Thread thread : threads) &#123; try &#123; thread.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(status.getTotalBytes()); // but just 89384 会change &#125; Strategies for Thread Safety Confinement 约束 Immutability 不变 Synchronization 同步 lock wait for each other: deadlock Atomic objects 原子类 Partitioning Confinement每条Thread都有Status not modify a shared object 1234private DownloadStatus status;public DownloadFileTask() &#123; this.status = new DownloadStatus();&#125; 12345678910111213141516171819202122public static void show()&#123; List&lt;Thread&gt; threads = new ArrayList&lt;&gt;(); List&lt;DownloadFileTask&gt; tasks = new ArrayList&lt;&gt;(); for(int i = 0; i&lt;10; i++)&#123; DownloadFileTask task = new DownloadFileTask(); tasks.add(task); Thread thread = new Thread(task); thread.start(); threads.add(thread); &#125; for (Thread thread : threads) &#123; try &#123; thread.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; Optional&lt;Integer&gt; result = tasks.stream().map(t -&gt; t.getStatus().getTotalBytes()) .reduce(Integer::sum); System.out.println(result); //100_000 &#125; Locks12345678910111213141516public class DownloadStatus &#123; private int totalBytes; private Lock lock = new ReentrantLock(); public int getTotalBytes() &#123; return totalBytes; &#125; public void incrementTotalBytes()&#123; lock.lock(); //上锁 try&#123; totalBytes++; &#125;finally &#123; lock.unlock(); //解锁 &#125; &#125;&#125; The Synchronished Keyword1234567891011121314151617public class DownloadStatus &#123; private int totalBytes; private int totalFiles; private Object totalBytesLock = new Object(); private Object totalFilesLock = new Object(); public void incrementTotalBytes()&#123; synchronized (totalBytesLock) &#123; totalBytes++; &#125; &#125; public void incrementTotalFiles()&#123; // 也可以使用 synchronized modifier 但不建议 synchronized (totalFilesLock)&#123; // 也可以使用 this 但不建议 totalFiles++; &#125; &#125;&#125; The Volatile Keyword 1private volatile boolean isDone; //unstable read it form the main memory change will be immediately written to the main memory change is visible across threads Thread Signalling12345678910111213// while loopsynchronized(status)&#123; try&#123; status.wait(); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125;&#125;status.done();synchronized(status)&#123; status.notifyAll();&#125; Atomic Objects123456789private AtomicInteger totalBytes = new AtomicInteger();public int getTotalBytes() &#123; return totalBytes.get();&#125;public void incrementTotalBytes()&#123; synchronized (totalBytesLock) &#123; totalBytes.incrementAndGet(); //a++ &#125;&#125; compare and swap Adders123456789private LongAdder totalBytes = new LongAdder();public int getTotalBytes() &#123; return totalBytes.intValue(); // sum()&#125;public void incrementTotalBytes()&#123; synchronized (totalBytesLock) &#123; totalBytes.increment(); //a++ &#125;&#125; Synchronized Collections12345678910111213141516171819public static void shoe()&#123; Collection&lt;Integer&gt; collection = Collections.synchronizedCollection(new ArrayList&lt;&gt;()); Thread thread1 = new Thread(()-&gt;&#123; collection.addAll(Arrays.asList(1,2,3)); &#125;); Thread thread2 = new Thread(()-&gt;&#123; collection.addAll(Arrays.asList(4,5,6)); &#125;); thread1.start(); thread2.start(); // 存在竞争 try &#123; thread1.join(); thread2.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(collection);//[4,5,6,1,2,3]&#125; Concurrent Collections1Map&lt;Integer, String&gt; map = new ConcurrentHashMap&lt;&gt;(); The Executive FrameworkThread Manipulation Availability limited Cost Thread Pool -&gt; reuse Executors123456789101112public static void show()&#123; ExecutorService executor = Executors.newFixedThreadPool(2); // try for (int i = 0; i &lt; 10; i++ )&#123; executor.submit(() -&gt;&#123; System.out.println(Thread.currentThread().getName()); // pool-1-thread-2 pool-1-thread-1 ... &#125;); &#125; // finally executor.shutdown();&#125; Callables and Futures123456789public class LongTask &#123; public static void simulate()&#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 12345678910111213141516171819public static void show()&#123; ExecutorService executor = Executors.newFixedThreadPool(2); try &#123; Future&lt;Integer&gt; future = executor.submit(() -&gt; &#123; LongTask.simulate(); return 1; &#125;); System.out.println(&quot;Do more work&quot;); // immediately try &#123; Integer result = future.get(); System.out.println(result); // 3 sec later &#125; catch (InterruptedException | ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; finally &#123; executor.shutdown(); &#125;&#125; Asynchronous ProgrammingAsynchronous = Non-blocking Creating a Completable Futures12345678910public static void show()&#123; Supplier&lt;Integer&gt; task = ()-&gt; 1; CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(task); try &#123; Integer result = future.get(); System.out.println(result); // 1 &#125; catch (InterruptedException | ExecutionException e) &#123; e.printStackTrace(); &#125;&#125; Implementing an Asynchronous API1234567891011121314151617public class MailService &#123; public void send()&#123; LongTask.simulate(); System.out.println(&quot;Mail was sent.&quot;); // &#125; public CompletableFuture&lt;Void&gt; sendAsync()&#123; return CompletableFuture.runAsync(() -&gt; send()); &#125;&#125;MailService.send();print(&quot;Hello World&quot;);// 3秒后 &quot;Mail was sent.&quot; then &quot;Hello World&quot;MailService.send();print(&quot;Hello World&quot;);Thread.sleep(5000);// Immediately &quot;Hello World&quot; 3秒后 &quot;Mail was sent.&quot; Running Code on Completion12345678910111213public static void show()&#123; CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(()-&gt;1); future.thenRunAsync(() -&gt; &#123; System.out.println(Thread.currentThread().getName()); // ForkJoinPool.commonPool-worker-1 .theRun -&gt; main System.out.println(&quot;Done&quot;); &#125;); future.thenAccept(result -&gt; &#123; System.out.println(Thread.currentThread().getName()); System.out.println(result); &#125;);&#125; Handing Exceptions1234567891011public static void show()&#123; CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(()-&gt;&#123; System.out.println(&quot;Getting the current weather&quot;); throw new IllegalStateException(); &#125;); try &#123; future.exceptionally(ex -&gt; 1).get(); &#125; catch (InterruptedException | ExecutionException e) &#123; e.printStackTrace(); &#125;&#125; Transforming Results12345public static void show()&#123; CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(()-&gt;20); future.thenApply(celsius -&gt; (celsius * 1.8) +32) .thenAccept(f -&gt; System.out.println(f));&#125; Composing Complete Futures12345public static void show()&#123; CompletableFuture.supplyAsync(() -&gt; &quot;email&quot;) .thenCompose(email -&gt; CompletableFuture.supplyAsync(() -&gt; &quot;playlist&quot;)) .thenAccept(playlist -&gt; System.out.println(playlist));&#125; Combining Completable Futures12345678910public static void show()&#123; CompletableFuture&lt;Integer&gt; first = CompletableFuture.supplyAsync(() -&gt; &quot;20USD&quot;) .thenApply(str-&gt;&#123; String price = str.replace(&quot;USD&quot;, &quot;&quot;); return Integer.parseInt(price); &#125;); CompletableFuture&lt;Double&gt; second = CompletableFuture.supplyAsync(() -&gt; 0.9); first.thenCombine(second, (price, exchangeRate) -&gt; price* exchangeRate) .thenAccept(result -&gt; System.out.println(result));&#125; Waiting for Many Tasks123456789101112131415161718public static void show()&#123; CompletableFuture&lt;Integer&gt; first = CompletableFuture.supplyAsync(() -&gt; 1 ); CompletableFuture&lt;Integer&gt; second = CompletableFuture.supplyAsync(() -&gt; 2); CompletableFuture&lt;Integer&gt; third = CompletableFuture.supplyAsync(() -&gt; 3); CompletableFuture&lt;Void&gt; all = CompletableFuture.allOf(first,second,third); all.thenRun(() -&gt; &#123; try &#123; Integer firstResult = first.get(); System.out.println(firstResult); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;All tasks completed successfully&quot;); &#125;);&#125; Waiting for the First Task123456789public static void show()&#123; CompletableFuture&lt;Integer&gt; first = CompletableFuture.supplyAsync(() -&gt;&#123; LongTask.simulate(); return 20; &#125;); CompletableFuture&lt;Integer&gt; second = CompletableFuture.supplyAsync(() -&gt; 20); CompletableFuture.anyOf(first,second) .thenAccept(temp -&gt; System.out.println(temp));&#125; Handing Timeoutsfuture.completeOnTimeout(1,1,TimeUnit.SECONDS) Project。。。 完结撒花，但是还远远没有结束。。。","categories":[{"name":"Java SE","slug":"Java-SE","permalink":"https://vanessayaoyao.github.io/categories/Java-SE/"}],"tags":[{"name":"java","slug":"java","permalink":"https://vanessayaoyao.github.io/tags/java/"}]},{"title":"git 入门","slug":"learn-git","date":"2022-01-07T08:35:36.000Z","updated":"2022-03-24T12:28:16.937Z","comments":true,"path":"2022/01/07/learn-git/","link":"","permalink":"https://vanessayaoyao.github.io/2022/01/07/learn-git/","excerpt":"","text":"虽然之前在GitHub传过几个项目，但那都是用Pycharm的插件传的，我对git可以说是只见其声不见其人，根本不会用。 Git is officially defined as a distributed version control system (VCS). 版本控制系统 Learn GitInitializing a repository12$ git initInitialized empty Git repository in D:/helloworld/OtherProjects/Snake/.git/ 我这里有一个用原生JavaScript写的贪吃蛇小游戏（比着人家的视频写的） Checking the status1234567891011$ git statusOn branch masterNo commits yetUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) game.js index.htmlnothing added to commit but untracked files present (use &quot;git add&quot; to track) Staging files1$ git add game.js index.html 或者 1$ git add . 再次查看状态 123456789$ git statusOn branch masterNo commits yetChanges to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) new file: game.js new file: index.html Making commits12345$ git commit -m &quot;this is my first commit&quot;[master (root-commit) 1637404] this is my first commit 2 files changed, 196 insertions(+) create mode 100644 game.js create mode 100644 index.html 123$ git statusOn branch masternothing to commit, working tree clean Commit history1234567$ git logcommit 1637404a766dad9bb1bc5c7995261131c688f747 (HEAD -&gt; master)Author: VanessaYaoyao &lt;929228571@qq.com&gt;Date: Fri Jan 7 17:00:11 2022 +0800 this is my first commit go back to a previous state of your project code that you committed, you can use the following command: 1$ git checkout &lt;commit-hash&gt; go back to the latest commit (the newest version of our project code), you can type this command: 1$ git checkout master Creating a new branch1$ git branch &lt;new-branch-name&gt; Changing branches1$ git checkout &lt;branch-name&gt; Learn GitHubCreating a new GitHub repository点击左上角头像旁边的加号 Pushing our code to the GitHub repository1234567891011$ git remote add origin https://github.com/VanessaYaoyao/JavaScript-Snake.git$ git push -u origin masterEnumerating objects: 4, done.Counting objects: 100% (4/4), done.Delta compression using up to 8 threadsCompressing objects: 100% (4/4), done.Writing objects: 100% (4/4), 2.15 KiB | 735.00 KiB/s, done.Total 4 (delta 0), reused 0 (delta 0), pack-reused 0To https://github.com/VanessaYaoyao/JavaScript-Snake.git * [new branch] master -&gt; masterBranch &#x27;master&#x27; set up to track remote branch &#x27;master&#x27; from &#x27;origin&#x27;. Making changes to the GitHub repository1$ git push origin master Cloning an existing GitHub repository1$ git clone &lt;github-repo-link&gt; 现在估计就够我用的了。其他的用法以后用到的时候在学。 附：GitHub Quick setup","categories":[{"name":"Web相关","slug":"Web相关","permalink":"https://vanessayaoyao.github.io/categories/Web%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"git","slug":"git","permalink":"https://vanessayaoyao.github.io/tags/git/"}]},{"title":"Java Part 2 - OOP","slug":"learning-java-2","date":"2021-12-28T04:54:53.000Z","updated":"2022-03-24T12:23:57.495Z","comments":true,"path":"2021/12/28/learning-java-2/","link":"","permalink":"https://vanessayaoyao.github.io/2021/12/28/learning-java-2/","excerpt":"","text":"Object-oriented ProgrammingUltimate Java Part 2 - Object-oriented Programming | Code with Mosh The four principles of object-oriented programming are: Encapsulation : bundling the data and operations on the data inside a single unit (class). Abstraction : reducing complexity by hiding unnecessary details (metaphor: the implementation detail of a remote control is hidden from us. We only work with its public interface.) Inheritance : a mechanism for reusing code. Polymorphism : a mechanism that allows an object to take many forms and behave differently. This will help us build extensible applications. Getting StartedProgramming Paradigms ways or styles of writing code 编程范式 Precedural Functional Object-oriented Event-driven Logic Aspect-oriented Problem Solving Process of defining a problem, identifying and comparing different solutions, and picking the one that best solves that problem with respect to the context and constraints. Depends on the problem, context and budget. Benefits of OOP Reduced Complexity Easier Maintenance Code Reuse Faster Development ClassesClass and ObjectClass: A blueprint for creating objects Object: An instance of a class. UML: unified modeling language 123456789101112package com.company;public class TextBox &#123; //设置初始值，不设置则为null, very dangerous public String text = &quot;&quot;; //Field public void setText(String text)&#123; this.text = text; &#125; public void clear()&#123; text = &quot;&quot;; &#125;&#125; 1234567public class Main &#123; public static void main(String[] args) &#123; TextBox textBox1 = new TextBox(); //jdk10以上可用var, like js textBox1.setText(&quot;Box 1&quot;); System.out.println(textBox1.text);//Box 1 &#125;&#125; Memory Allocation内存分配 heap:堆 stack:栈 1234TextBox textBox1 = new TextBox();TextBOx textBox2 = textBox1;textBox2.setText(&quot;Hello World&quot;);System.out.println(textBox1.text);//Hello World What is the difference between stack and heap memory? How are they managed? Stack is used for storing primitive types (numbers, boolean and character) and variables that store references to objects in the heap. Variables stored in the stack are immediately cleared when they go out of scope (eg when a method finishes execution). Objects stored in the heap get removed later on when they’re no longer references. This is done by Java’s garbage collector. Garbage collection: automatically remove unused objects on the heap. Encapsulation Bundle the data and methods that operate on the data in a single unit.封装 Procedural Programming过程化编程 spaghetti code What are the problems of procedural code? How does object-oriented programming help solve these problems? Big classes with several unrelated methods focusing on different concerns and responsibilities. These methods often have several parameters. You often see the same group of parameters repeated across these methods. All you see is procedures calling each other passing arguments around. By applying object-oriented programming techniques, we extract these repetitive parameters and declare them as fields in our classes. Our classes will then encapsulate both the data and the operations on the data (methods). As a result, our methods will have fewer parameters and our code will be cleaner and more reusable. 1234567public class Employee &#123; public int baseSalary; public int hourlyRate; public int calculateWage(int extraHours)&#123; return baseSalary + (hourlyRate*extraHours); &#125;&#125; 12345678910public class Main &#123; public static void main(String[] args) &#123; Employee employee = new Employee(); employee.baseSalary = 50_000; //如果输入一个负数呢? 可以在主函数里写if else,but it&#x27;s not good. employee.hourlyRate = 20; int wage = employee.calculateWage(10); System.out.println(wage); &#125;&#125; Getters and Setters Why should we declare fields as private? How we store data in an object is considered an implementation detail. We may change how we store the data internally. Plus, we don’t want our objects to go into a bad state (hold bad data). That’s why we should declare fields as private and provide getters and or setters only if required. These setters can ensure our objects don’t go into a bad state by validating the values that are passed to them. 1234567891011public class Employee &#123; private int baseSalary; public void setBaseSalary(int baseSalary)&#123; if (baseSalary&lt;=0) throw new IllegalArgumentException(&quot;can&#x27;t be 0 or less.&quot;); this.baseSalary = baseSalary; &#125; public int getBaseSalary()&#123; return baseSalary; &#125;&#125; A trick: ask intellij to do it for us. press Alt+Enter apply Abstraction Reduce complexity by hiding unnecessary details. 抽象 给你一个遥控器，我们只需要知道如何换台，不需要知道按钮之下的电路如何运作。 As a metaphor, think of the remote control of your TV. All the complexity inside the remote control is hidden from you. It’s abstracted away. You just work with a simple interface to control your TV. We want our objects to be like our remote controls. Coupling The level of dependency between classes. 耦合 The more our classes are dependent on each other, the harder it is to change them. Changing one class may result in several cascading and breaking changes. Reducing coupling 123456789101112131415public class Browser &#123; //其他类只调用navigate这个函数 public void navigate(String address)&#123; String ip = findIpAddress(address); String html = sendHttpRequest(ip); System.out.println(html); &#125; //其他函数隐藏，即private private String sendHttpRequest(String ip) &#123; return &quot;&lt;html&gt;&lt;/html&gt;&quot;; &#125; private String findIpAddress(String address) &#123; return &quot;127.0.0.1&quot;; &#125;&#125; How does the abstraction principle help reduce coupling? By hiding the implementation details, we prevent other classes from getting affected when we change these details. For example, if the logic board and transistors inside a remote control change from one model to another, we’re not affected. We still use the same interface to work with our TV. Also, reducing these details and exposing fewer methods makes our classes easier to use. For example, remote controls with fewer buttons are easier to use. Constructors Constructors are called when we instantiate our class. We use them to initialize our objects. Initialization means putting an object into an early or initial state (eg giving it initial values). 12345678910public class Employee &#123; private int baseSalary; private int hourlyRate; //构造器，没有返回类型，名字与类名一致 public Employee(int baseSalary, int hourlyRate)&#123; setBaseSalary(baseSalary); setHourlyRate(hourlyRate); &#125; ...&#125; if we don’t create a constructor, the java compiler will automatically create one for us(the default constructor). Method Overloading Method overloading means declaring a method with the same name but with different signatures. The number, type and order of its parameters will be different. creating different implementations of it with different parameters. trick: ctrl+D to duplicate 123456public int calculateWage(int extraHours)&#123; return baseSalary + (getHourlyRate() *extraHours);&#125;public int calculateWage()&#123; return calculateWage(0) ;&#125; be aware of it, but don’t overuse it. Constructor Overloading1234567public Employee(int baseSalary)&#123; this(baseSalary,0);&#125;public Employee(int baseSalary, int hourlyRate)&#123; setBaseSalary(baseSalary); setHourlyRate(hourlyRate);&#125; Static Members Static methods are accessible via classes, not objects. 1234567891011public class Employee()&#123; public static int numberOfEmployees; public static void printNumberOfEmployees&#123; //在里面调用其他函数，必须先创建实例 ... &#125; ...&#125;Employee.numberOfEmployees;//不用创实例，直接调用类System.out.print();//这就是调用的 static methodInteger.parseInt();//这也是 Refactoring to an Object-oriented Design重构代码 trick 1: ask intellij to refactor for us 鼠标点击函数名后，选择上方工具栏的Refactor→Refactor this→Move trick 2: ask intellij to generate something for us, such as a constructor 选择上方工具栏的Code→Genreate→Constructor 右击类名，find usages Inheritance 123456public class UIControl&#123; ...&#125;public class TextBox extends UIControl &#123; ...&#125; The Object Class12345TextBox box1 = new TextBox();TextBox box2 = new TextBox();System.out.println(box1.hashCode()); //356573597 relted to address//box1.equal(box2) false hashcode differentSystem.out.println(box1.toString()); //com,codewithmosh.TextBox@1540e19d package@hashcode(hexodecimal十六进制) Constructors and Inheritance12345678910111213//父类public UIcontrol(boolean isEnabled) &#123; this.isEnabled = isEnabled; System.out.println(&quot;UIControl&quot;);&#125;//子类public TextBox() &#123; super(true);//需要放在第一条 System.out.println(&quot;TextBox&quot;);&#125;TextBox box1 = new TextBox();//先输出UIControl后输出TextBox The super keyword is a reference to the base or parent class. We can use it to access the members (fields and methods) or call the constructors of the base class. In contrast, the this keyword returns a reference to the current object. Access Modifiers访问修饰符 public private protected How accessible is a field or method if it’s declared without an access modifier? If we omit the access modifier, the member will have the defaultaccess modifier which makes that member public in package. In otherwords, that member will be public in the package but private outside ofthe package. private fields and methods are not inherited by subclasses and they are not accessible outside of a class. protected: public in package and accessible by child classes in different packages hard to maintain the application Overriding MethodsMethod overriding means changing the implementation of an inherited method in a subclass. For example, we can override the equals() or hashCode() methods of the Object class. Method overloading means declaring a method with different signatures (different number, type and order of parameters). 1234@Override //an annotation telling java compilerpublic String toString()&#123; return text;&#125; What is the benefit of applying the @Override annotation when overriding a method? It signals the Java compiler that we’re overriding a method in the base class and this helps the compiler check our code for correctness. It will ensure the signature of the method in the subclass matches the on declared in the base class. Also, if we remove this method from the base class, the compiler will let us know and we can remove the method in the subclass as well. Upcasting and Downcasting123TextBox box = new TextBox();UIcontrol control = new UIcontrol(true);show(box1); //upcasting empty downcasting helloworld 12345678910public static void show(UIcontrol control)&#123; System.out.println(control);&#125;public static void show(UIcontrol control)&#123; if (control instanceof TextBox)&#123; var textBox = (TextBox)control; textBox.setText(&quot;Hello World&quot;); &#125; System.out.println(control);&#125; Comparing Objects1234var point1 = new Point(1,2);var point2 = new Point(1,2);point1 == point2 //falsepoint1.euqal(point2) //false 123456789@Overridepublic boolean equals(Object obj) &#123; if(this == obj) return true; if( !(obj instanceof Point)) return false; Point other = (Point)obj; return other.x == x &amp;&amp; other.y == y;&#125; trick: ask intellij to do it for us. PolymorphismEncapsulation Abstraction Inheritance Polymorphism 123456789101112//UIcontrolpublic void render()&#123;&#125; //empty//CheckBox@Overridepublic void render() &#123; System.out.println(&quot;render checkbox&quot;);&#125;//TextBox@Overridepublic void render() &#123; System.out.println(&quot;render textbox&quot;);&#125; 1234UIcontrol[] controls = &#123; new TextBox(), new CheckBox()&#125;;for( UIcontrol control:controls)&#123; control.render();&#125; Abstract Classes and Methods When do we use abstract classes? An abstract class is a partially-implemented (half-cooked) class. We cannot instantiate them. But we use them to share some common code across their subclasses. we cannot instantiate abstract class but only extend it. 123public abstract class UIcontrol &#123; public abstract void render();&#125; Class ‘CheckBox’ must either be declared abstract or implement abstract method ‘render()’ in ‘UIcontrol’. Can we have an abstract class without any abstract methods? Yes! An abstract class does not need abstract methods. But if we mark a method as abstract, we should mark the class as abstract as well. Final Classes and Methods When do we use final classes? Final classes cannot be inherited. We use them when we’ve made certain assumptions about a class and we want to prevent other classes extending our class and break those assumptions. we cannot extend final classes and we cannot override final methods. Deep Inheritance and HierarchiesDon’t create deep inheritance hierarchies. What is the diamond problem? The diamond problem happens in languages that support multiple inheritance. If two classes (B, C) derive from A and are also the parents of another class (D), we see a diamond. If the top class (A) declares a method (eg toString) and its children (B and C) override this method, it’s not clear which implementation will be inherited by D. Multiple Inheritancea class can have multiple parents Java does not support this feature. simple and robust. Interfaces We use interfaces to build loosely-coupled, extensible and testable applications. What is tightly-coupled code? Tightly-coupled code is code that is hard to change because there is a strong dependency between the entities (eg classes) in the code. Changing one class may result in several cascading, breaking changes in the code. Creating an Interface123public interface TaxCalculator &#123; double calculateTax();&#125; 123456789101112public class TaxCalculator2022 implements TaxCalculator&#123; private double taxableIncome; public TaxCalculator2022(double taxableIncome) &#123; this.taxableIncome = taxableIncome; &#125; @Override public double calculateTax()&#123; return taxableIncome * 0.3; &#125;&#125; Dependency Injection Dependency injection refers to passing or injecting dependencies of a class. Our classes should not instantiate their dependencies. 依赖注入 The separation of concerns: We need to separate creating an object and using it. Constructor Injection Setter Injection Method Injection Constructor Injection1234567public class TaxReport &#123; private TaxCalculator calculator; public TaxReport(TaxCalculator calculator)&#123; //only working with an interface this.calculator = calculator; &#125;&#125; progromming against interfaces 123456public class Main &#123; public static void main(String[] args) &#123; TaxCalculator2022 calculator2022 = new TaxCalculator2022(100_000); TaxReport report = new TaxReport(calculator2022); //pass or inject this calculator object &#125;&#125; dependency injection framework: pass these dependencies to our classes. Spring is one of the popular ones. Setter Injection123456public class TaxReport &#123; private TaxCalculator calculator; public void setCalculator(TaxCalculator calculator) &#123; this.calculator = calculator; &#125;&#125; 12345678910public class Main &#123; public static void main(String[] args) &#123; TaxCalculator2022 calculator2022 = new TaxCalculator2022(100_000); TaxReport report = new TaxReport(calculator2022); report.show(); //30000.0 report.setCalculator(new TaxCalculator2023()); report.show(); //0.0 &#125;&#125; Method Injection123456public class TaxReport &#123; public void show(TaxCalculator calculator)&#123; double tax = calculator.calculateTax(); System.out.println(tax); &#125;&#125; 1234TaxCalculator2022 calculator2022 = new TaxCalculator2022(100_000);TaxReport report = new TaxReport();report.show(calculator2022);report.show(new TaxCalculator2023()); Interface Segregation Principle The Interface Segregation Principle (ISP) suggests that we should segregate or divide big, fat interfaces into smaller ones, each focusing on a single responsibility or capability. Smaller interfaces are less likely to change. Changes to one capability, will only affect a single interface and fewer classes that depend on that interface. divide big interfaces into smaller ones UIWidget Deaggable Resizable A interface can have multiple parents Why shouldn’t we declare fields, static or private methods in interfaces? Fields, static and private methods are all about implementation. Interfaces are contracts and should not have any implementation. Interface and Abstract Classes What are the similarities and differences between interfaces and abstract classes? Both are abstract concepts and we cannot instantiate them. Interfaces are contracts and should only have method declarations. Abstract classes are partially-implemented classes. We use them to share some common code across their derivates. The new features in Java allow writing code and logic in interfaces but this is a bad practice and should be avoided. When to use Interfaces Should we extract an interface from every class? Why? Blindly extracting interfaces doesn’t solve any problems nor is it considered a best practice. If you extract an interface from every single class, you’ll end up with an explosion of interfaces that don’t necessarily add any values. You should use interfaces in situations where you want to decouple a class from its dependencies so you can swap these dependencies. This allows building applications that are extensible and testable","categories":[{"name":"Java SE","slug":"Java-SE","permalink":"https://vanessayaoyao.github.io/categories/Java-SE/"}],"tags":[{"name":"java","slug":"java","permalink":"https://vanessayaoyao.github.io/tags/java/"}]},{"title":"Java Part 1 - Fundamentals","slug":"learning-java","date":"2021-12-25T06:44:55.000Z","updated":"2022-03-24T12:23:47.939Z","comments":true,"path":"2021/12/25/learning-java/","link":"","permalink":"https://vanessayaoyao.github.io/2021/12/25/learning-java/","excerpt":"","text":"Java还是要学的。找工作就靠它了吧。 Fundamentals视频链接：Learning Java with Mosh Part One Anatomy of java program function 1234567891011ReturnType Name()&#123; ...&#125;void sendEmail()&#123; ...&#125;public class Main&#123; public void main()&#123; ... &#125;&#125; class: A container for related functions PascalNamingConvention→Classes camelNamingConvention→Methods How Java Code Gets Executed compilation→javac Main.class excution→java Mian Intellij hides that for us. TypesVariables primitive for storing simple values reference for storing complex objects 1234long viewsCount = 3_123_456_789L;float price = 10.99F;char letter = &#x27;A&#x27;;boolean isEligible = false; 1234567 byte x = 1; byte y = x;//改变x值y值不变Point point1 = new Point(1,1);Point point2 = point1;point1.x = 2;//point2的值也改变 Strings1234String message = &quot;Hello world&quot; + &quot;!!&quot;;message.length();//.出后看方法message.replace(&quot;target&quot;,&quot;replacement&quot;)message.trim()//去除前后空白（就像Python里的strip? In Java, Strings are immutable. return a new string Escape Sequences12345// Hello &quot;world&quot;String message = &quot;Hello \\&quot;world\\&quot;&quot;;// c:\\Windows\\..String message = &quot;c:\\\\windows\\\\..&quot;;//常用的还有\\n 和\\t Arrays1234567891011int[] numbers = new int[5];numbers[0] = 1;numbers[1] = 2;System.out.println(Arrays.toString(numbers));//[1,2,0,0,0]int[] numbers = &#123;2,3,4,1,4&#125;;System.out.println(numbers.length);//5Arrays.sort(numbers);System.out.println(Arrays.toString(numbers));//[1,2,3,4,4] In Java, arrays have a fixed size. Muti-dimensional Arrays123456int[][] numbers = new int[2][3];numbers[0][0]=1;System.out.println(Arrays.deepToString(numbers));//[[1, 0, 0], [0, 0, 0]]int[][] numbers = &#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;;//[[1, 2, 3], [4, 5, 6]] Constants1final float PI = 3.14F; Arithmetic Expressions1234567891011int result = 10/3;//3double result = (double)10/(double)3;//3.333333int x = 1;int y = x++;//x=2;y=1int x = 1;int y = ++x;//x=2,y=2x +=2; Casting1234567891011// Implicit casting// byte &gt; short &gt; int &gt; long &gt; float &gt; doubleshort x = 1;int y = x + 2;double x = 1.1;double y = x + 2;//2.0 // Explicit castingint y = (int)x + 2;String x = &quot;1&quot;;int y = Integer.parseInt(x) + 2; //3//Short.parseShort() Float.parseFloat()... The Math Class12345int result = Math.round(1.1F) //1int result = (int)Math.ceil(1.1F) //2int result = (int)Math.floor(1.1F) //1int result = Math.max(1,2) //2int result = (int)Math.round(Math.random()*100);//0-100随机数 Formatting Numbers123456NumberFormat currency = NumberFormat.getCurrencyInstance();String result = currency.format(1234567.891);//￥1,234,567.89NumberFormat percent = NumberFormat.getPercentInstance();String result = percent.format(0.1);//10% Reading Input123456789Scanner scanner = new Scanner(System.in);System.out.print(&quot;Age: &quot;);byte age = scanner.nextByte();//.nextFloat() .nextDouble()System.out.println(&quot;You are &quot;+age);String name = scanner.next();//Name: Vanessa Yao//You are Vanessa (空格后的词被丢失)String name = scanner.nextLine().trim();//You are Vanessa Yao Control FlowLogical Operators123456Scanner scanner = new Scanner(System.in);byte temperature = scanner.nextByte();boolean isWarm = (temperature &gt; 20) &amp;&amp; (temperature &lt; 30);// and(&amp;&amp;)第一个表达式为false时，java will ignore others.// or(||)第一个表达式为true时, java will ignore others.// not(!) If Statements12345678int temp &#x3D; 32;if(temp&gt;30)&#123; System.out.println(&quot;It&#39;s a hot day&quot;);&#125;else if(temp&gt;20)&#123;&#125;else&#123;&#125; simplifying if statement 12int income = 120_000;boolean hasHighIncome = (income &gt; 100_000); The Ternary Operator12int income = 120_000;String className = income &gt; 100_000 ? &quot;First&quot; : &quot;Economy&quot; Switch Statements1234567891011String role = &quot;admin&quot;;switch(role)&#123; case &quot;admin&quot;: System.out.println(&quot;You are an admin&quot;); break; case &quot;moderator&quot;: System.out.println(&quot;You are a moderator&quot;); break; default: System.out.println(&quot;You are a guest&quot;);&#125; For Loops123for(int i = 0; i&lt;5; i++)&#123; System.out.println(&quot;Hello world&quot;);&#125; While Loopsdon’t know how many times 1234567String input = &quot;&quot;;Scanner = scanner = new Scanner(System.in)while(!input.equals(&quot;quit&quot;))&#123; //不能用==，比较的是地址 System.out.print(&quot;Input: &quot;); input = scanner.next().toLowerCase(); System.out.println(input);&#125; Do…While Loopsat least once Break and Continue1234while(true)&#123; if(input.equals(&quot;quit&quot;)) break;&#125; For-Each Loop12345String[] fruits = &#123;&quot;Apple&quot;,&quot;Mango&quot;,&quot;Orange&quot;&#125;;for(String fruit : fruits)&#123; System.out.println(fruit);&#125;//只能从头到尾，not index 第一部分在油管上免费，讲的确实不错。第二部分和第三部分要收钱了。 哦吼，B站有人搬运，白嫖使我快乐。https://www.bilibili.com/video/BV19J411t7dD Object-oriented ProgrammingUltimate Java Part 2 - Object-oriented Programming | Code with Mosh Classes Refactoring Towards an Object-oriented Design Inheritance Interfaces Advanced TopicsUltimate Java Part 3: Advanced Topics | Code with Mosh Exceptions Generics泛型 Collections Lambda Expressions and Functional Interfaces Streams Concurrency and Multi-threading The Executive Framework","categories":[{"name":"Java SE","slug":"Java-SE","permalink":"https://vanessayaoyao.github.io/categories/Java-SE/"}],"tags":[{"name":"java","slug":"java","permalink":"https://vanessayaoyao.github.io/tags/java/"}]},{"title":"Ajax初识","slug":"ajax","date":"2021-12-23T04:33:25.000Z","updated":"2022-03-24T12:37:10.758Z","comments":true,"path":"2021/12/23/ajax/","link":"","permalink":"https://vanessayaoyao.github.io/2021/12/23/ajax/","excerpt":"","text":"是啥AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML） AJAX 是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 我理解的就是前端用AJAX来请求接口 实例 一个小例子，点击按钮获得3条动物信息。 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JSON and AJAX&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;header&gt; &lt;h1&gt;JSON and AJAX&lt;/h1&gt; &lt;button id=&#x27;btn&#x27;&gt;Fetch Info for 3 New Animals&lt;/button&gt; &lt;/header&gt; &lt;div id=&#x27;animal-info&#x27;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&#x27;main.js&#x27;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031var pageCounter = 1;var animalContainer = document.getElementById(&quot;animal-info&quot;)var btn = document.getElementById(&quot;btn&quot;);//监听事件，当btn被点击时调用该匿名函数btn.addEventListener(&quot;click&quot;, function()&#123; //新建对象 var ourRequest = new XMLHttpRequest(); //用GET请求URL ourRequest.open(&quot;GET&quot;,&quot;https://learnwebcode.github.io/json-example/animals-&quot;+pageCounter+&quot;.json&quot;) //onload意为全部加载完后 ourRequest.onload = function()&#123; //转为JSON对象 var ourData = JSON.parse(ourRequest.responseText) renderHTML(ourData); &#125;; ourRequest.send() pageCounter++; if (pageCounter&gt;3) &#123; btn.classList.add(&quot;hide-me&quot;);//这里是点击三次后隐藏按钮，但我这好像不太管用 &#125;&#125;)function renderHTML(data)&#123; var htmlString = &#x27;&#x27;; for(var i=0;i&lt;data.length;i++)&#123; //数据展示 htmlString += &quot;&lt;p&gt;&quot;+data[i].name+&quot; is a &quot;+data[i].species +&quot;.&lt;/p&gt;&quot; &#125; animalContainer.insertAdjacentHTML(&quot;beforeend&quot;,htmlString)&#125; 到这里还和我看到别人用的ajax不太一样。我看的用法好像是$ajax(…)什么什么的，这好像是jquary的用法？ 未完待续。 2021/12/29 更新 VanillaJS是史上最轻量跨平台前端框架 ，我们能够使用它构建强大的JS应用。从过去到以后他都是最轻量的框架。因为vanillaJS的广受欢迎，所有的浏览器都已经内置这个框架了！ jQuery也是一个框架。 Vanilla JS 1234567var r = new XMLHttpRequest();r.open(&quot;POST&quot;, &quot;path/to/api&quot;, true);r.onreadystatechange = function () &#123; if (r.readyState != 4 || r.status != 200) return; alert(&quot;Success: &quot; + r.responseText);&#125;;r.send(&quot;banana=yellow&quot;); jQuery 1234567891011&lt;script src=&quot;//ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;$.ajax(&#123; type: &#x27;POST&#x27;, url: &quot;path/to/api&quot;, data: &quot;banana=yellow&quot;, success: function (data) &#123; alert(&quot;Success: &quot; + data); &#125;,&#125;);&lt;/script&gt;","categories":[{"name":"Web相关","slug":"Web相关","permalink":"https://vanessayaoyao.github.io/categories/Web%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"https://vanessayaoyao.github.io/tags/Ajax/"}]},{"title":"Redis初识","slug":"meet-redis","date":"2021-12-18T05:30:10.000Z","updated":"2022-03-24T12:28:32.140Z","comments":true,"path":"2021/12/18/meet-redis/","link":"","permalink":"https://vanessayaoyao.github.io/2021/12/18/meet-redis/","excerpt":"","text":"程序部有一回课是讲缓存的，但那天我睡过头了没上成。就对redis不怎么了解，也没具体应用过。此事警醒我们不要睡过头！ 什么是Redis？Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 MySQL VS RedisMySQL是关系型数据库,主要用于存放持久化数据,将数据存储在硬盘中,读取速度较慢. Redis是NOSQL,即非关系型数据库,也是缓存数据库,即将数据存储在缓存中,缓存的读取速度快,能够大大的提高运行效率,但是保存时间有限. 缓存的必要网站访问的特点和现实世界的财富分配一样遵循二八定律：80% 的业务访问集中在20% 的数据上。既然大部分业务访问集中在一小部分数据上，那么如果把这一小部分数据缓存在内存中，就可以减少数据库的访问压力，提高整个网站的数据访问速度，改善数据库的写入性能了。 Redis 在django的使用下载首先要先下载Redis, 参考步骤：click this 1pip install django-redis redis 和 django-redis的区别，就像mysql和mysqlclient的区别。 我以前还以为下载django-redis就完事了呢，😓 settings.py里的配置复制一下github上官方文档的配置 123456789CACHES = &#123; &quot;default&quot;: &#123; &quot;BACKEND&quot;: &quot;django_redis.cache.RedisCache&quot;, &quot;LOCATION&quot;: &quot;redis://127.0.0.1:6379/1&quot;, &quot;OPTIONS&quot;: &#123; &quot;CLIENT_CLASS&quot;: &quot;django_redis.client.DefaultClient&quot;, &#125; &#125;&#125; 简单使用我有这么简简单单一张表 12345# models.pyclass Blog(models.Model): title = models.CharField(max_length=128) author = models.CharField(max_length=128) content = models.TextField() 我想实现：当用户访问一篇博客时，第一次访问从数据库里拿出来，放在缓存里。当用户再次访问时，不再进行数据库查询，使用缓存数据。 123456789101112131415161718192021#views.pyfrom django.core.cache import cachedef blog(request,id): dic = &#123;&#125; if request.method == &quot;GET&quot;: if cache.get(id): dic[&#x27;code&#x27;] = 200 dic[&#x27;msg&#x27;] = &quot;hit the cache&quot; dic[&#x27;data&#x27;] = BlogSerializer(cache.get(id)).data # cache.delete(id) else: dic[&#x27;code&#x27;] = 201 dic[&#x27;msg&#x27;] = &quot;hit the database&quot; blog = Blog.objects.get(id=id) cache.set(id, blog) #id为键，blog为值 dic[&#x27;data&#x27;] = BlogSerializer(blog).data else: dic[&#x27;code&#x27;] = 400 dic[&#x27;msg&#x27;] = &quot;wrong method&quot; return JsonResponse(dic) 第一次访问 再次访问 更多操作（如设置过期时间）可参考：django-redis","categories":[{"name":"Web相关","slug":"Web相关","permalink":"https://vanessayaoyao.github.io/categories/Web%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://vanessayaoyao.github.io/tags/redis/"}]},{"title":"英语、计算机与我","slug":"about-me","date":"2021-12-12T04:59:55.000Z","updated":"2022-03-24T12:35:53.628Z","comments":true,"path":"2021/12/12/about-me/","link":"","permalink":"https://vanessayaoyao.github.io/2021/12/12/about-me/","excerpt":"","text":"Thanks for your watching. Early Years我来自一个十八线小县城，上初中前没接触过英语，上大学前没接触过编程。 小学就在我们村里上的，上午上数学，下午上语文，体育课就是老师领着我们去操场上转两圈。没有英语课，更别说什么音乐课手工课的。对于小时候的我来说，日子过得平淡又快乐，没有什么糟心事，没有什么成绩排名，放学了就背着书包走着回家。这时还不知道能用双脚丈量的距离有多珍贵。可能偶尔烦恼就是，和我家在一个胡同的发小，她有好多好看的发卡，常常戴满了头发，而我没有，有时会嫉妒她哈哈。 上了初中就开始每周回一次家了，发小她之后对我说上了初中之后，她的童年就结束了，其实想想我也是。上小学的时候从来没有什么成绩排名，脑海里根本没有这个意识。上了初中就开始排名排名排名，但日子还算轻松。初一的时候认识的很多朋友，现在平时虽然不怎么联络，但在我心里她们已经是家人般的存在。下课的时候看看言情小说，和朋友打打闹闹，偶尔关心一下成绩排名，还早恋过，时间过得很快。有时会突然地恍惚，不知道现在是哪年哪月哪天，已经过去好久的事情仿佛就是昨天。 上了高中，曾经要好的朋友散落各地，也没有精力去结交新的朋友，我逐渐适应了一个人生活。一个人跑着去吃饭，很多时候都沉默寡言，没有话说，也没有什么表情。其实也没有什么很大的变化，我一直如此，懒得很，一个人的时间反而让我很自在。高中几乎都是学习了，学习学习学习，考上一个好大学。两周回家一次到最后一个月回家一次，一次在家的时间不超过二十四小时，一切照搬衡水中学的模式。 Why English忘记上高中的时候还是上初中的时候了，我有一段时间特别喜欢去校门口的书摊那买书，周一就把所有的零花钱就花光了。书摊上有许多三毛的书，我买来读过后，很是羡慕她。感觉三毛洒脱又自由，我也想这样。于是我就把北京十月出版社的三毛系列全买来读了一遍。三毛会好几种语言，西班牙语经常出现在她的书里，估计这就是我想读语言的由来吧，那时候一直给同学说我上大学要读西班牙语。现在这股读书的劲头早已消散，书买来也就是摆着。 恰巧高中的时候我英语的成绩还不错，一般考试成绩都在一百三以上，有次还上了一百四，不自觉便飘飘然，认为自己有学语言的天赋，自己就是学语言的天选之女，现在想想也是挺好笑的。那时候我还想着自己将来会去外交部，会穿着优雅知性的西装套裙站在国家领导人的背后，为他们翻译。谁还没有点梦想呢。哦不，是空想。在所有的课里，我最喜欢上的就是英语，感觉上的最轻松的也是英语，哪一次英语没有考好还会暗自神伤。但其实想想，我其实是被自己所营造的假象所欺骗了，我一直暗示自己，我的英语很好，我的英语很好，如此这般。 高考完后选专业，可想而知，我把所有学校的语言专业选了个遍，非语言专业不读。现在的我知道选语言专业不是一个好的决定，你所有的热情会被消磨殆尽，你会甚至讨厌英语，会不断怀疑自己。但对于当时的我来说，我也没有什么其他的选择，父母学识有限，给不了我很好的建议。所有的选择权都在我自己，其实完全是瞎选的，去知乎看了几篇帖子，草草地就结束了。我现在只能庆幸当时没有把北京第二外国语学院放在第一志愿，冲着海大985的名头选了海大。人呐，有时候还是要追名逐利一点的好（doge。 当时在知乎看了很多关于英语专业的问题，在B站也看了很多关于英语专业的视频分享，幻想着自己也能像他们这样，一口流利英语，结交各国好友，从此走上人生巅峰。但有个东西叫，幸存者偏差。我不自觉地忽视了一切不同的声音，只想看到自己看到的东西。哦对了，当时我还认为语言专业大三的时候都能出国交换的。那些出来分享的当然是过得还不错的，还有他们是北外或者上外的，沉默的大多数是没有话语权的。 进入大学，我给自己营造出的“我英语很好”的假象开始一点点瓦解。老师在专业课上指出我读音有问题；词汇量差的一批还不喜欢背单词；进入英表班，被非英语专业的同学吊打。人和人的差距真大呀。而且学英语的话还是要家境殷实一点的好，没有家庭支撑你想出去留学的话那等于胡闹。有钱啥时候都好啊，至少有选择的余地，有从头再来的底气。 英语当作兴趣那是极好的，但选英语专业我只能说是完全不必要的。英语这种专业啥样的大学都有，我不理解，除了北外上外的语言专业，其他学校的语言专业能不能不要开了。语言只是工具。没有其他技能的加持，真的很慌，真的没有底气。我一直很抵触说自己是英语专业的，感觉很难受或者说难为情。英语专业的英语不好哈哈。如果抱着当老师的想法那另当别论。至于我，我不想当老师，我当不好。 For Computer Science我和编程的起源，是我在大一下的时候选了一门课叫Python程序设计。那时候也不知道天高地厚，完全不知道Python是个什么东西，从来没接触过编程，但就是选了这门课。可以说这门课真的影响我很大吧。那时候还是疫情在家上网课，我就从什么都不会，不知道在哪输入字符。到慢慢有点思路，一耗两三个小时就是为了把一个练习题做出来。甚至还在班级群里回答其他同学的问题，虽然是用匿名。每成功一步都让我欣喜若狂、欢呼雀跃。这种心情是我上英语专业以来从未体会过的，真的从未体会到过。上了英语专业我就自动把自己归了底层一类，就忘记了自己也曾想当一个闪闪发光的人。 在大一下学期快结束的时候，我好像就在突然之间萌生了转到计算机专业的想法，这种想法只一瞬，但就像一粒种子，在我心中生了根发了芽，没过多久就长成了参天大树，无法动摇。想来人生也真是挺奇妙的，这样的事情最近又在我的人生中上演。人人都考研，但不考研的想法就不知何时飘进了我的脑中，这种想法愈演愈烈，让我做出了自己的决定。我不知道像这样的想法会将我的人生带向何处，但我知道它们已经改变了我的人生，我也期待着前方的路。 大二前的那个小学期我就没有选英语专业的课了，大二上学期的课完全照着计算机专业培养方案选的，兴高采烈等着加课。那天应该是一个星期一，我在院办值班，看到群里有人说加课结果出来了，我就打开看看自己的结果，结果为未通过。开始慌了。我早早下班了。出了外院门，我就给信院的教秘打电话。下午的课也直接翘掉了，直接去信院找教秘，教秘不管，又给系主任打电话。说是不给大二才转的加课。其实从看到结果的时候，我就知道再去找谁也不会改变什么了。现在想起来那天的经历还会觉得鼻头酸酸。在一个下午的时间里，我挣扎过，又很快接受了我不能改变的现状，马上去教务处加上了英语专业的课。只想毕业就好。 可能不能系统地学习计算机课程会有一点遗憾。有遗憾。但我现在也想开了。转过去的话，要补一年的课，每次选课都提心吊胆，还要面临延毕的焦虑，没有认识的朋友，估计也会很难熬。有时候会感觉老天在指引我的人生。之前的时候都能加课的，现在好像也能加课，就好巧没给我加课。我并没有“被安排”的感觉，要质问什么的，我只是觉得很奇妙。来到海大，大一下学了Python，就此产生转专业的想法，大二上凭着Python进了爱特程序部，到现在决定不考研毕业直接去找工作。一环扣一环，时间错开一点，我的人生估计又会有很大的不同。 Sophomore Year and Later转专业失败后，就回去继续上英语专业的课。上课就是等着下课，数着时间一点点过去。很长一段时间，我感觉我像被绑在一根绳上，两端都被紧紧拉着，没办法左移也没法右移，我也没法喘气。我想在课余时间里从“英语专业”里抽离出来去学点计算机相关的东西，但那些作业和数不清的展示又把我绑了回去。我又怂得很，不敢翘课，不敢不交作业，没有摆烂的勇气。躺平这个词还可以，我就任凭别人卷我，再卷我也不为所动，对很多事情也不太关心了。 比较幸运的事就是进入了爱特工作室，爱特是我唯一可以接触代码的地方。虽然我一直觉得自己像这个社团的“局外人”，我不是信院的，不爱玩游戏没什么共同话题，对技术的热爱也谈不上，但我一直很留恋在社团的时间，也从来没想过退出。爱特给了我一个平台，让我看到真正优秀的计算机大佬是什么样子的。写项目的过程，从什么都不会一个简单的东西查半天，到现在回望自己之前写的代码感觉像shit，我没学到了很多，但也确实是学到了很多。 爱特给了我成长，也给了我很多伤感emo的瞬间。我不记得我有多少个星期日的晚上，是垂头丧气回宿舍的。在看到别人的优秀后，我不知道我要怎么样才能追赶他们的脚步，我太垃圾了，太菜了。要学的东西太多了，会的东西太少了，和别人的差距太大了。现在我也时时会焦虑，但我已经学会和自己和解，不要和别人比，要和昨天的自己比。”无论人生上到哪一层台阶，阶下有人在仰望你，阶上亦有人在俯视你。你抬头自卑，低头自得。唯有平视，才能看见真正的自己。” 现在大三上学期即将结束，还有好几篇论文没写完，明天就是新的一年。下学期有更多自己可以支配的时间了，多学点，大四可能去实习。毕业后就去北京找工作了。不知道还会经历多少社会的毒打，就期待自己能获得自由吧。人生有什么意义呢？越去想人生有什么意义，我越觉得人生无意义。专注当下吧，想太多都是闲得，赶快去学习，反而能得到快乐和满足。 to be continued…","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://vanessayaoyao.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"life","slug":"life","permalink":"https://vanessayaoyao.github.io/tags/life/"}]},{"title":"JWT在Django中的具体实现","slug":"JWT在Django中的具体实现","date":"2021-12-03T09:10:25.000Z","updated":"2022-03-01T04:52:52.412Z","comments":true,"path":"2021/12/03/JWT在Django中的具体实现/","link":"","permalink":"https://vanessayaoyao.github.io/2021/12/03/JWT%E5%9C%A8Django%E4%B8%AD%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"记录一下，加深自己的理解。 什么是JWT？JWT是Json Web Token的缩写，可去官网查看更多。 简单说来，它和session干着一样的活，即身份认证。它保存在客户端，本质是一长串字符串，由header, payload和signature组成。 Why JWT not session? 使用session 存在CSRF攻击 session存在服务器端，无法适用分布式站点。 在Django中使用首先安装PyJWT 1pip install PyJWT models.py里建一张用户表，有用户名、密码等字段。 in views.py 1234567891011121314151617181920212223242526from .models import Userimport jwt, datetime, simplejson #导入def login(request): if request.method == &quot;POST&quot;: #接收json数据 username = simplejson.loads(request.body)[&#x27;username&#x27;] password = simplejson.loads(request.body)[&#x27;password&#x27;] #这里验证密码是否正确什么的我就先不写了 user = User.objects.filter(username=username).first() payload = &#123; #将该用户的id或username加入payload中 &quot;id&quot;: user.id, #过期时间，我这里写的是60分钟后过期 &quot;exp&quot;: datetime.datetime.utcnow() + datetime.timedelta(minutes=60), #生效时间，我这里写的是即刻生效 &quot;iat&quot;: datetime.datetime.utcnow() &#125; #将payload加密，我的密钥是&quot;secret&quot;(可以随便写) token = jwt.encode(payload, &quot;secret&quot;, algorithm=&#x27;HS256&#x27;).decode(&#x27;utf-8&#x27;) #将token返回 return JsonResponse(&#123;&#x27;jwt&#x27;: token, &#x27;msg&#x27;:&#x27;success&#x27;&#125;) else: return JsonResponse(&#123;&#x27;msg&#x27;: &#x27;wrong http method&#x27;&#125;) 123456789101112131415161718192021def user_info(request): if request.method == &quot;GET&quot;: #接收前端小伙伴放在HTTP头部的token #这样也避免了CSRF攻击 token = request.META.get(&#x27;HTTP_AUTHORIZATION&#x27;) if not token: msg = &#x27;not get token&#x27; try: #使用相同的密钥解密 payload = jwt.decode(token, &#x27;secret&#x27;, algorithms=[&#x27;HS256&#x27;]) #拿到用户id，从而完成用户认证 user = User.objects.get(id=payload[&#x27;id&#x27;]) msg = &#x27;get token, and I know you are &#x27; + user.username #也会存在异常 except jwt.ExpiredSignatureError: #如这里是token过期 msg = &#x27;token expired&#x27; except Exception as e: #还有其他过期类型，就不展开写了 msg = &quot;token invalid&quot; return JsonResponse(&#123;&#x27;token&#x27;: token, &#x27;msg&#x27;: msg&#125;) else: return JsonResponse(&#123;&#x27;msg&#x27;: &#x27;wrong http method&#x27;&#125;) 接口测试可用Postman， apifox等。 这只是一个小demo，实际运用中不可能每个需要身份认证的地方都写一遍（这么干也不是不行），所以考虑封装成装饰器。 这里我自我检讨一下，其实我装饰器并没有学会，只会照抄别人的代码。 改天再写一篇关于装饰器的博客。（立flag了） See you.","categories":[{"name":"Web相关","slug":"Web相关","permalink":"https://vanessayaoyao.github.io/categories/Web%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"JWT","slug":"JWT","permalink":"https://vanessayaoyao.github.io/tags/JWT/"}]},{"title":"怎么说呢，说就是不想考研了","slug":"怎么说呢，说就是不想考研了","date":"2021-10-11T00:23:28.000Z","updated":"2022-03-24T12:36:31.517Z","comments":true,"path":"2021/10/11/怎么说呢，说就是不想考研了/","link":"","permalink":"https://vanessayaoyao.github.io/2021/10/11/%E6%80%8E%E4%B9%88%E8%AF%B4%E5%91%A2%EF%BC%8C%E8%AF%B4%E5%B0%B1%E6%98%AF%E4%B8%8D%E6%83%B3%E8%80%83%E7%A0%94%E4%BA%86/","excerpt":"","text":"我虽无意逐鹿，却知苍生苦楚。 我头铁，要去撞南墙了。 2022/2/24更新之父母安心版 告诉了父母不考研的决定，他们虽然还是想让我继续学业，家里也不是供不起，但也是不强求，让我自己作主。三个多月前的有点像一时起意的想法，已经在我心底坐实，现在也是时候捋顺一下，算是一个交代吧。 摆在眼前有这么几条可以走的路吧，老师或者考公体制内算一种，考研算一种，互联网算一种。体制内可以直接pass了，教资我也考过，兼职的老师我也当过，我当老师和我当学生的心态完全一样，当学生想着如何撑到下课，当老师想的也是如何能苟到下课。考研其实不算一条真正的路吧，算是延期，倒时候还是要做选择。互联网挑战多机遇也多吧。 我发现我已经逐渐丧失了坐在课堂里听老师讲课学习的能力，可能是因为我上的课大多是水课，好久没有“学到知识”的体会了，我已经习惯了在课堂上玩手机。英语专业大多课都如此，平时水过去，全靠期末突击，得个还过得去的成绩，分高了还沾沾自喜一下。也有需要平时努力的课，当你作业认真完成，课堂展示和结课论文想得头秃，最后得的分数还不如随便水水的一门课时，你就应该知道分数根本代表不了什么。 最近考研成绩也陆续出来了，不免听到什么考了380，390分没学上的消息，我不知道是不是我又陷入了信息茧房中，但考研人数每年都是再创新高，越来越卷是事实。可能是我害怕我努力不够达不到目标，我卷不过，但选择另一条路也可以算是勇敢吧。考研的话，肯定是考计算机，英一数一408再加上政治，跨考难度飞起了吧。 考研的目的对我来说就是一个学历上的提升，而学历的提升也就是方便找工作。我对研究生的生活没什么向往，我也打听过研究生的生活是什么样的，基本就是要发文章，上课基本不怎么上，每周开会说说自己看了什么文献。可能如果我没参加过SRDP的话，还不会对看文献产生这么大的抵触心理。看文献发文章就算了，不是那块料，力不从心硬着头皮看，那真是煎熬。 工作的话，就算是本科，海大985的牌子还是有点用处的，我也不是非大厂不去，能去大厂当然很好，去不了就慢慢来嘛。我对技术也谈不上热爱吧，反正是不讨厌。我也不打算给自己一个具体的职业规划，我也规划不出来，三年前高三的我肯定没有想到现在的我在做什么打算，现在的我也预测不到未来的我。会遇到什么机遇吗？会惨兮兮地在出租房掉眼泪吗？会一直坚持做技术吗？会35岁失业吗哈哈哈哈。趁着年轻多去闯闯吧。 而且我已经期待完全的独立好久了。 Ps. 这学期选了游泳课，一定要学会游泳！","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://vanessayaoyao.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"life","slug":"life","permalink":"https://vanessayaoyao.github.io/tags/life/"}]},{"title":"寒假日常","slug":"寒假日常","date":"2021-02-07T16:23:46.000Z","updated":"2022-03-01T04:52:09.947Z","comments":true,"path":"2021/02/08/寒假日常/","link":"","permalink":"https://vanessayaoyao.github.io/2021/02/08/%E5%AF%92%E5%81%87%E6%97%A5%E5%B8%B8/","excerpt":"","text":"第一天 刷手机 第二天 刷手机 第三天 刷手机 第四天 刷手机 第五天 刷手机 第六天 tmd, 烦死了。老子要学习！ 第七天 刷手机。。。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://vanessayaoyao.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[]},{"title":"hello world!","slug":"hello-world-1","date":"2021-01-31T07:17:39.000Z","updated":"2022-03-01T04:51:50.385Z","comments":true,"path":"2021/01/31/hello-world-1/","link":"","permalink":"https://vanessayaoyao.github.io/2021/01/31/hello-world-1/","excerpt":"","text":"Hi. This is my first blog. I’m very excited.","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://vanessayaoyao.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"hello world","slug":"hello-world","permalink":"https://vanessayaoyao.github.io/tags/hello-world/"}]}],"categories":[{"name":"Web相关","slug":"Web相关","permalink":"https://vanessayaoyao.github.io/categories/Web%E7%9B%B8%E5%85%B3/"},{"name":"Bug调试","slug":"Bug调试","permalink":"https://vanessayaoyao.github.io/categories/Bug%E8%B0%83%E8%AF%95/"},{"name":"杂谈","slug":"杂谈","permalink":"https://vanessayaoyao.github.io/categories/%E6%9D%82%E8%B0%88/"},{"name":"Java SE","slug":"Java-SE","permalink":"https://vanessayaoyao.github.io/categories/Java-SE/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://vanessayaoyao.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://vanessayaoyao.github.io/tags/nginx/"},{"name":"mybatis-plus","slug":"mybatis-plus","permalink":"https://vanessayaoyao.github.io/tags/mybatis-plus/"},{"name":"springmvc","slug":"springmvc","permalink":"https://vanessayaoyao.github.io/tags/springmvc/"},{"name":"springboot","slug":"springboot","permalink":"https://vanessayaoyao.github.io/tags/springboot/"},{"name":"杂谈","slug":"杂谈","permalink":"https://vanessayaoyao.github.io/tags/%E6%9D%82%E8%B0%88/"},{"name":"AOP Ioc","slug":"AOP-Ioc","permalink":"https://vanessayaoyao.github.io/tags/AOP-Ioc/"},{"name":"reflection","slug":"reflection","permalink":"https://vanessayaoyao.github.io/tags/reflection/"},{"name":"tree","slug":"tree","permalink":"https://vanessayaoyao.github.io/tags/tree/"},{"name":"data structures","slug":"data-structures","permalink":"https://vanessayaoyao.github.io/tags/data-structures/"},{"name":"decorator","slug":"decorator","permalink":"https://vanessayaoyao.github.io/tags/decorator/"},{"name":"CROS","slug":"CROS","permalink":"https://vanessayaoyao.github.io/tags/CROS/"},{"name":"java","slug":"java","permalink":"https://vanessayaoyao.github.io/tags/java/"},{"name":"git","slug":"git","permalink":"https://vanessayaoyao.github.io/tags/git/"},{"name":"Ajax","slug":"Ajax","permalink":"https://vanessayaoyao.github.io/tags/Ajax/"},{"name":"redis","slug":"redis","permalink":"https://vanessayaoyao.github.io/tags/redis/"},{"name":"life","slug":"life","permalink":"https://vanessayaoyao.github.io/tags/life/"},{"name":"JWT","slug":"JWT","permalink":"https://vanessayaoyao.github.io/tags/JWT/"},{"name":"hello world","slug":"hello-world","permalink":"https://vanessayaoyao.github.io/tags/hello-world/"}]}