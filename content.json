{"meta":{"title":"CicadaOnTheTree","subtitle":"哈喽呀","description":"我要握住一个最美的梦给未来的自己","author":"Vanessa Yao","url":"https://vanessayaoyao.github.io","root":"/"},"pages":[{"title":"tags","date":"2021-12-03T10:26:53.000Z","updated":"2021-12-03T10:27:25.448Z","comments":true,"path":"tags/index.html","permalink":"https://vanessayaoyao.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-03-01T04:39:50.000Z","updated":"2022-03-01T04:41:54.562Z","comments":true,"path":"categories/index.html","permalink":"https://vanessayaoyao.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"八股文（二）","slug":"bagu2","date":"2022-10-04T07:42:00.000Z","updated":"2022-10-04T07:46:05.700Z","comments":true,"path":"2022/10/04/bagu2/","link":"","permalink":"https://vanessayaoyao.github.io/2022/10/04/bagu2/","excerpt":"","text":"哪些集合类是线程安全的？ 线性安全的Vector：只要是关键性的操作，方法前面都加了synchronized关键字，来保证线程的安全性Hashtable：使用了synchronized关键字，所以相较于Hashmap是线程安全的。ConcurrentHashMap:使用锁分段技术确保线性安全，是一种高效但是线程安全的集合。Stack：栈，也是线程安全的，继承于Vector。 线性不安全的Hashmap，Arraylist，LinkedList，HashSet，TreeSet，TreeMap Hashmap：HashMap在put操作的时候，如果插入的元素超过了容量（由负载因子决定）的范围就会触发扩容操作，就是resize，这个会重新将原数组的内容重新hash到新的扩容数组中，在多线程的环境下，存在同时其他的元素也在进行put操作，如果hash值相同，可能出现同时在同一数组下用链表表示，造成闭环，导致在get时会出现死循环，所以HashMap是线程不安全的。 Arraylist： List 对象在做 add 时，执行 Arrays.copyOf 的时候，返回一个新的数组对象。当有线程 A、B… 同时进入 grow方法，多个线程都会执行 Arrays.copyOf 方法，返回多个不同的 elementData 对象，假如，A先返回，B 后返回，那么 List.elementData ==A. elementData,如果同时B也返回，那么 List.elementData ==B. elementData,所以线程B就把线程A的数据给覆盖了，导致线程A的数据被丢失。 LinkedList：与Arraylist线程安全问题相似，线程安全问题是由多个线程同时写或同时读写同一个资源造成的。 HashSet：底层数据存储结构采用了Hashmap，所以Hashmap会产生的线程安全问题HashSet也会产生。 JVM内存分区 根据各种数据的特性JVM从逻辑上把内存划分成了几个区域；分别为方法区、虚拟机栈、本地方法栈、程序计数器、堆 5个区域. JVM方法区是用于保存已经被虚拟机加载的类元信息（包括类的版本、字段、方法、接口和父类等信息）、运行时常量信息(static、final定义的常量)、字符串常量信息(String a=”dfc”)。 栈这部分区域主要是用于线程运行方法的区域，此区域属于线程私有的空间，每一个线程创建后都会申请一个自己单独的栈空间，每一个方法的调用都会对应着一个栈帧。 由于java需要与一些底层系统如操作系统或某些硬件交换信息时的情况，这个时候就需要通过调用native本地方法来实现，本地方法栈和虚拟机栈功能差不多，区别在于本地方法栈是虚拟机调用native方法时使用的。 程序计数器是一块较小的内存空间，它的作用可以看作是当前线程所执行的字节码的行号指示器，程序计数器记录着某个线程当前执行指令的位置，此区域属于线程隔离区。 堆内存主要是用来存放我们运行过程中创建的对象数据，根据对象所生存时间长短的特性在逻辑上分为 新生代和老年代。 垃圾回收算法 1.标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。 该算法分为两个阶段，标记和清除。标记阶段标记所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。该算法最大的问题就是内存碎片严重化，后续可能发生对象不能找到利用空间的问题。 2.复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。 按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉。 3.标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。 标记后不是清理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。 4.分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。 当前商业虚拟机都采用分代收集的垃圾收集算法。分代收集算法，顾名思义是根据对象的存活周期将内存划分为几块。一般包括年轻代、老年代 和 永久代。 在Socket通信中，为什么需要指定端口？ socket相当于是运输层向应用层提供的服务接口，应用之间的通信都是以进程为单位，网络中标识一个进程就是用的端口号，所以socket必须要有端口 Java中创建线程的三种方式以及区别 采用继承Thread类方式： （1）优点：编写简单，如果需要访问当前线程，无需使用Thread.currentThread()方法，直接使用this，即可获得当前线程。 （2）缺点：因为线程类已经继承了Thread类，所以不能再继承其他的父类。 采用实现Runnable接口方式： （1）优点：线程类只是实现了Runable接口，还可以继承其他的类。在这种方式下，可以多个线程共享同一个目标对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。 （2）缺点：编程稍微复杂，如果需要访问当前线程，必须使用Thread.currentThread()方法。 Runnable和Callable的区别： (1)Callable规定的方法是call(),Runnable规定的方法是run(). (2)Callable的任务执行后可返回值，而Runnable的任务是不能返回值得 (3)call方法可以抛出异常，run方法不可以，因为run方法本身没有抛出异常，所以自定义的线程类在重写run的时候也无法抛出异常 (4)运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。 start（）和run（）的区别 start()方法用来，开启线程，但是线程开启后并没有立即执行，他需要获取cpu的执行权才可以执行 run()方法是由jvm创建完本地操作系统级线程后回调的方法，不可以手动调用（否则就是普通方法） final finally finalize的区别 1、final可以修饰类，变量，方法，修饰的类不能被继承，修饰的变量不能重新赋值，修饰的方法不能被重写。 2、finally用于抛异常，finally代码块内语句无论是否发生异常，都会在执行finally，常用于一些流的关闭。 3、finalize方法用于垃圾回收。一般情况下不需要我们实现finalize，当对象被回收的时候需要释放一些资源，比如socket链接，在对象初始化时创建，整个生命周期内有效，那么需要实现finalize方法，关闭这个链接。但是当调用finalize方法后，并不意味着GC会立即回收该对象，所以有可能真正调用的时候，对象又不需要回收了，然后到了真正要回收的时候，因为之前调用过一次，这次又不会调用了，产生问题。所以不推荐使用finalize方法。 JDBC连接数据库的步骤 1.加载驱动 2.连接数据库 3.创建Statement对象 4.执行sql语句 5.处理结果集 6.处理异常，关闭资源 类加载机制 类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。 IPV6 IPv4和IPv6用于用户标识和Internet上不同设备之间的通信。IPv4是32位IP地址，而IPv6是128位IP地址。IPv4是数字地址，用点分隔。IPv6是一个字母数字地址，用冒号分隔 HTTPS Hyper Text Transfer Protocol over SecureSocket Layer 网站在使用HTTPS前，需要向CA机构申领一份数字证书，数字证书里含有证书持有者信息、公钥信息等。服务器把证书传输给浏览器，浏览器从证书里获取公钥就行了，证书就如身份证，证明“该公钥对应该网站”。数字证书 = 网站信息 + 数字签名 HTTPS就是使用SSL/TLS协议进行加密传输，让客户端拿到服务器的公钥，然后客户端随机生成一个对称加密的秘钥，使用公钥加密，传输给服务端，后续的所有信息都通过该对称秘钥进行加密解密，完成整个HTTPS的流程。 三大缓存问题 缓存穿透：当我们去查询一个一定不存在的数据，比如Mybatis在缓存是未命中的情况下需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。 缓存击穿：某个 Key 属于热点数据，访问非常频繁，同一时间很多人都在访问，在这个Key失效的瞬间，大量的请求到来，这时发现缓存中没有数据，就全都直接请求数据库，相当于击穿了缓存屏障，直接攻击整个系统核心。 缓存雪崩：当你的Redis服务器炸了或是大量的Key在同一时间过期，这时相当于缓存直接GG了，那么如果这时又有很多的请求来访问不同的数据，同一时间内缓存服务器就得向数据库大量发起请求来重新建立缓存，很容易把数据库也搞GG。","categories":[],"tags":[]},{"title":"八股文（一）","slug":"bagu1","date":"2022-09-28T01:05:23.000Z","updated":"2022-10-04T07:47:52.500Z","comments":true,"path":"2022/09/28/bagu1/","link":"","permalink":"https://vanessayaoyao.github.io/2022/09/28/bagu1/","excerpt":"","text":"tcp和http区别 TCP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。从本质上来说，二者没有可比性。Http协议是建立在TCP协议基础之上的，当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。Http会通过TCP建立起一个到服务器的连接通道，当本次请求需要的数据完毕后，Http会立即将TCP连接断开，这个过程是很短的，所以Http连接是一种短连接，是一种无状态的连接。 为什么三次握手，如果两次握手会怎么样 建立连接的过程是利用客户服务器模式，假设主机A为客户端，主机B为服务器端。 （1）TCP的三次握手过程：主机A向B发送连接请求；主机B对收到的主机A的报文段进行确认；主机A再次对主机B的确认进行确认。请求连接-&gt; 同意并请求连接-&gt;同意 （2）采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。 四次挥手 请求关闭-&gt;同意-&gt;请求关闭-&gt;同意 http请求包含哪几个部分 请求行、请求头、请求体 GET/sample.jspHTTP/1.1Accept:image/gif.image/jpeg,/Accept-Language:zh-cnConnection:Keep-AliveHost:localhostUser-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0)Accept-Encoding:gzip,deflate username=jinqiao&amp;password=1234 1xx：指示信息–表示请求已接收，继续处理2xx：成功–表示请求已被成功接收、理解、接受3xx：重定向–要完成请求必须进行更进一步的操作。4xx：客户端错误–请求有语法错误或请求无法实现。5xx：服务器端错误–服务器未能实现合法的请求。 存储引擎 MyISAM：MySQL5.5之前的默认存储引擎，在插入和查询的情况下性能很高，但是它不支持事务，只能添加表级锁。 InnoDB：MySQL5.5之后的默认存储引擎，它支持ACID事务、行级锁、外键，但是性能比不过MyISAM，更加消耗资源。 Memory：数据都存放在内存中，数据库重启或发生崩溃，表中的数据都将消失。 事务隔离级别 事务的四大特性分别是：原子性、一致性、隔离性、持久性 read uncommitted读未提交: 能够读取到其他事务中未提交的内容，存在脏读问题。 read committed读提交: 只能读取其他事务已经提交的内容，存在不可重复读问题。 repeatable可重复读: 在读取某行后不允许其他事务操作此行，直到事务结束，但是依然存在幻读问题。 serializable可序化: 一个事务的开始必须等待另一个事务的完成 Mysql索引类型及底层实现 单列索引 normal 普通索引 unique 唯一索引 spatial 空间索引，不常用 fulltext 全文索引 SELECT * FROM articles WHERE MATCH (body) AGAINST (‘database’); SELECT * FROM articles WHERE body like ‘%database%’; 组合索引 Hash表和B-Tree Mysql锁机制 从对数据的操作类型上来说，锁分为读锁和写锁： 读锁：也叫共享锁，当一个事务添加了读锁后，其他的事务也可以添加读锁或是读取数据，但是不能进行写操作，只能等到所有的读锁全部释放。 写锁：也叫排他锁，当一个事务添加了写锁后，其他事务不能读不能写也不能添加任何锁，只能等待当前事务释放锁。 从锁的作用范围上划分，分为全局锁、表锁和行锁： 全局锁：锁作用于全局，整个数据库的所有操作全部受到锁限制。 表锁：锁作用于整个表，所有对表的操作都会收到锁限制。 行锁：锁作用于表中的某一行，只会通过锁限制对某一行的操作（仅InnoDB支持） 记录锁 间隙锁 临键锁 redis 的单线程体现在哪里 Redis客户端对服务端的每次调用都经历了发送命令，执行命令，返回结果三个过程。其中执行命令阶段，由于Redis是单线程来处理命令的，所有每一条到达服务端的命令不会立刻执行，所有的命令都会进入一个队列中，然后逐个被执行。并且多个客户端发送的命令的执行顺序是不确定的。但是可以确定的是不会有两条命令被同时执行，不会产生并发问题，这就是Redis的单线程基本模型。 多线程 volatile与synchronized关键字 并发的三个概念 原子性：一个操作或多个操作要么执行且在执行过程中不被任何因素打断，要么不执行。（基本数据读取，赋值（数据赋值给变量）都是原子性操作）。 可见性：多个线程访问一个变量，当一个线程改变了变量的值，其他线程是可以立即看到新值。 有序性：程序执行按照代码的先后顺序。 涉及指令重排序：处理器为提高运行效率，对代码执行顺序进行优化，不保证程序按照代码先后顺序执行，但保证结果与代码顺序执行结果一致。重排序不会影响单线程操作，但对多线程操作可能会产生影响。 volatile轻量级线程同步关键字不能保证原子性，可以保证有序性 synchronized关键字又被称为重量级锁 volatile与synchronized的区别1、volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。 2、volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。 3、volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。 4、volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。 5、volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。","categories":[],"tags":[]},{"title":"栈、队列和树","slug":"stack-queue-and-tree","date":"2022-09-06T09:21:54.000Z","updated":"2022-09-06T09:28:52.462Z","comments":true,"path":"2022/09/06/stack-queue-and-tree/","link":"","permalink":"https://vanessayaoyao.github.io/2022/09/06/stack-queue-and-tree/","excerpt":"","text":"栈 先进后出1234567Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();stack.push(1);stack.push(2);stack.push(3);System.out.println(stack.pop()); // 3// 官方推荐创建方法Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;(); 从性能上来说应该使用Deque代替Stack。Stack和Vector都是线程安全的，其实多数情况下并不需要做到线程安全，因此没有必要使用Stack。毕竟保证线程安全需要上锁，有额外的系统开销。 ArrayDeque和LinkedList这两者底层，一个采用数组存储，一个采用链表存储； 数组存储，容量不够时需要扩容和数组拷贝，通常容量不会填满，会有空间浪费； 链表存储，每次push都需要new Node节点，并且node节点里面有prev和next成员，也会有额外的空间占用。 括号匹配是使用栈解决的经典问题 1234567891011121314151617181920212223class Solution &#123; public boolean isValid(String s) &#123; Deque&lt;Character&gt; deque = new LinkedList&lt;&gt;(); char ch; for (int i = 0; i &lt; s.length(); i++) &#123; ch = s.charAt(i); //碰到左括号，就把相应的右括号入栈 if (ch == &#x27;(&#x27;) &#123; deque.push(&#x27;)&#x27;); &#125;else if (ch == &#x27;&#123;&#x27;) &#123; deque.push(&#x27;&#125;&#x27;); &#125;else if (ch == &#x27;[&#x27;) &#123; deque.push(&#x27;]&#x27;); &#125; else if (deque.isEmpty() || deque.peek() != ch) &#123; return false; &#125;else &#123;//如果是右括号判断是否和栈顶元素匹配 deque.pop(); &#125; &#125; //最后判断栈中元素是否匹配 return deque.isEmpty(); &#125;&#125; 队列 先进后出队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作。 LinkedList类实现了Queue接口，因此我们可以把LinkedList当成Queue来用。 1234567//add()和remove()方法在失败的时候会抛出异常(不推荐)Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;();//添加元素queue.offer(&quot;a&quot;);queue.offer(&quot;b&quot;);queue.offer(&quot;c&quot;);System.out.println(queue.poll()); // a 树一些术语和性质度：树中一个结点的孩子个数称为该结点的度。二叉树结点的度可能为0，1，2.树中结点的最大度数成为树的度。 叶子结点（又称终端结点）：度为0的结点。 结点的层次从树根开始定义，根结点为第1层，它的子节点为第2层。 树的性质 树中的结点数等于所有结点的度数加1 度为m的书中第i层至多有mi-1个节点 高度为h的m叉树至多有（mh-1）/（m-1）个结点 具有n个结点的m叉树的最小高度为logm(n(m-1)+1) 满二叉树：一颗高度为h，且含有2h-1个结点的二叉树称为满二叉树。 完全二叉树：高度为h、有n个结点的二叉树，当且仅当其每个结点都与高度为h的满二叉树中编号1-n的结点一一对应时，称为完全二叉树。 二叉排序树：左子树上所有结点的关键字均小于根结点的关键字；右子树上的所有结点的关键字均打羽根节点的关键字；左子树和右子树又各是一个二叉排序树。 平衡二叉树：树上任一结点的左子树和右子树的深度之差不超过1. 二叉树的性质 非空二叉树上的叶子结点数等于度为2的节点数加1 非空二叉树上第k层上至多有2(k-1)个结点 高度为h的二叉树至多有2h-1个结点 对完全二叉树按从上到下、从左到右的顺序以此编号1，2，···，n，则 当i&gt;1时，结点i的双亲的编号为i/2，即当i为偶数时，其双亲的编号为i/2,它是双亲的左孩子；当i为奇数时，其双亲的编号为（i-1）/2,它是双亲的友孩子； 当2i&lt;=n时，结点i的左孩子编号为2i,否则无左孩子 当2i+1&lt;=n时，结点i的左孩子编号为2i+1,否则无右孩子 结点i所在层次（深度）为log2i+1 具有n个（n&gt;0）结点的完全二叉树的高度为log2(n+1)或log2n+1 二叉树的遍历 先序遍历 根-左-右 中序遍历 左-根-右 后序遍历 左-右-根 递归算法以先序遍历为例 12345678910111213public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); preOrder(root,list); return list;&#125;void preOrder(TreeNode root, List&lt;Integer&gt; list)&#123; if (root == null)&#123; return; &#125; list.add(root.val); preOrder(root.left,list); preOrder(root.right,list);&#125; 非递归算法以中序遍历为例 沿着根的左孩子，以此入栈，直到左孩子为空，说明已找到可以输出的结点 栈顶元素出栈并访问：若其右孩子为空，继续执行2；若其右孩子不空，将右子树转执行1. 12345678910111213141516171819public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;(); if (root == null)&#123; return result; &#125; TreeNode cur = root; while (cur != null || !stack.isEmpty())&#123; if (cur !=null)&#123; stack.push(cur); cur = cur.left; &#125;else &#123; cur = stack.pop(); result.add(cur.val); cur = cur.right; &#125; &#125; return result;&#125; 先序遍历和中序遍历思想基本相同。 12345678910111213141516171819202122// 前序遍历顺序：中-左-右，入栈顺序：中-右-左class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null)&#123; return result; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty())&#123; TreeNode node = stack.pop(); result.add(node.val); if (node.right != null)&#123; stack.push(node.right); &#125; if (node.left != null)&#123; stack.push(node.left); &#125; &#125; return result; &#125;&#125; 再来看后序遍历，先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了 1234567891011121314151617181920212223// 后序遍历顺序 左-右-中 入栈顺序：中-左-右 出栈顺序：中-右-左， 最后翻转结果class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null)&#123; return result; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty())&#123; TreeNode node = stack.pop(); result.add(node.val); if (node.left != null)&#123; stack.push(node.left); &#125; if (node.right != null)&#123; stack.push(node.right); &#125; &#125; Collections.reverse(result); return result; &#125;&#125; 层次遍历先将二叉树根节点入队，然后出队，访问出队结点，若它有左子树，则将左子树根节点入队；若它有右子树，则将右子树根节点入队。然后出队，访问出队结点···如此反复，直至队列为空。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 102.二叉树的层序遍历class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; resList = new ArrayList&lt;List&lt;Integer&gt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; //checkFun01(root,0); checkFun02(root); return resList; &#125; //DFS--递归方式 public void checkFun01(TreeNode node, Integer deep) &#123; if (node == null) return; deep++; if (resList.size() &lt; deep) &#123; //当层级增加时，list的Item也增加，利用list的索引值进行层级界定 List&lt;Integer&gt; item = new ArrayList&lt;Integer&gt;(); resList.add(item); &#125; resList.get(deep - 1).add(node.val); checkFun01(node.left, deep); checkFun01(node.right, deep); &#125; //BFS--迭代方式--借助队列 public void checkFun02(TreeNode node) &#123; if (node == null) return; Queue&lt;TreeNode&gt; que = new LinkedList&lt;TreeNode&gt;(); que.offer(node); while (!que.isEmpty()) &#123; List&lt;Integer&gt; itemList = new ArrayList&lt;Integer&gt;(); int len = que.size(); while (len &gt; 0) &#123; TreeNode tmpNode = que.poll(); itemList.add(tmpNode.val); if (tmpNode.left != null) que.offer(tmpNode.left); if (tmpNode.right != null) que.offer(tmpNode.right); len--; &#125; resList.add(itemList); &#125; &#125;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://vanessayaoyao.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"ACM模式","slug":"acm","date":"2022-09-02T06:23:23.000Z","updated":"2022-09-02T07:28:31.871Z","comments":true,"path":"2022/09/02/acm/","link":"","permalink":"https://vanessayaoyao.github.io/2022/09/02/acm/","excerpt":"","text":"美团笔试是ACM模式，呃呃呃啥是ACM模式，俺不懂。搜了搜原来就是需要自己写输入输出的，在力扣上做的那种叫核心模式。 感觉又回到最初的起点了，一开始学Python的时候，就是需要自己写输入输出的，但那时候还不知道这叫ACM模式。从自己去做爱特的题到自己出题招下一届的人，都用的是ACM模式哈哈哈。 一般题目会给出输入格式和输出格式，提交代码时需要把自己引的包也复制过去，类名得叫Main，不能有package。 常见的输入格式我对Java的输入还是不是很熟，写Web根本用不到输入输出。 （1）输入描述: 12输入第一行包括一个数据组数t(1 &lt;&#x3D; t &lt;&#x3D; 100)接下来每行包括两个正整数a,b(1 &lt;&#x3D; a, b &lt;&#x3D; 1000) （2）输出描述: 1输出a+b的结果 （3）示例 输入 12321 510 20 输出 12630 123456789101112import java.util.Scanner;public class Main&#123; public static void main(String[] args)&#123; Scanner in = new Scanner(System.in); int n =in.nextInt(); while(n--&gt;0)&#123; int a = in.nextInt(); int b = in.nextInt(); System.out.println(a+b); &#125; &#125;&#125; （1）输入描述: 1输入包括两个正整数a,b(1 &lt;&#x3D; a, b &lt;&#x3D; 10^9),输入数据有多组, 如果输入为0 0则结束输入 （2）输出描述: 1输出a+b的结果 （3）示例 输入 1231 510 200 0 输出 12630 1234567891011121314151617181920import java.util.*;// 注意类名必须为 Main, 不要有任何 package xxx 信息public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); Boolean endFlag = false; // 注意 hasNext 和 hasNextLine 的区别 while (in.hasNextInt()&amp;&amp;!endFlag) &#123; // 注意 while 处理多个 case int a = in.nextInt(); int b = in.nextInt(); if(a==0&amp;&amp;b==0)&#123; endFlag=true; &#125; else &#123; list.add(a+b); &#125; &#125; list.forEach(e-&gt;System.out.println(e)); &#125;&#125; 接收字符串 123String s &#x3D; in.nextLine();&#x2F;&#x2F; 有时要注意回车问题in.netLine();","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://vanessayaoyao.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"突然引不到包？","slug":"not-found","date":"2022-08-17T00:04:53.000Z","updated":"2022-08-17T01:46:28.825Z","comments":true,"path":"2022/08/17/not-found/","link":"","permalink":"https://vanessayaoyao.github.io/2022/08/17/not-found/","excerpt":"","text":"前几天改了一下代码，然后提交，提交之前没有拉一下。提交的时候就提示让我合并，合就合了。合完之后，我就发现有个地方报红了，一个常量类突然引不到了，让阳哥帮忙看，他也没看出原因，很奇怪。我还以为是我合并出的问题，心里还忐忑不安的。当时的解决方法是换了一个文件夹，把代码重新从仓库拉了一遍，就好了。 在一账通的那个项目，也出现了这个问题，一个枚举类突然引不到了，之前都好好的。我想着把代码在拉一遍，光下依赖就得下好久。我就搜索了一下，发现也有人遇到这样的问题，竟然是IDEA的锅。把IDEA重启一下就可以了。 https://blog.csdn.net/victorzzzz/article/details/84946306 这这这。。。心梗了。。。 再聊聊最近的生活吧。 新学期开始了，租的房子也快到期了，我也分到了新的项目组里。但是心情并没有什么朝气蓬勃的感受，没有对未来翘首以盼的期待感，甚至不太开心，（只有看苍兰珏的时候能哈哈大笑）。可能是这两天没太睡好，新项目也就一直让我看，麦麦在线客服上线后出了个空指针的报错，然后秋招我竟然还没开始准备。。。 甚至在考虑实习要不要继续了，实习了差不多两个月了，其实在江哥那学到不少，需求评审，开发，联调，测试，上线，流程也熟悉的差不多了。这个新项目，注释啥的也没有，我不是很喜欢，（哈哈哈谁要你喜欢），感觉少了点激情。实习和秋招感觉有点撞了。继续实习的话，就没太多时间准备秋招了。 秋招还是一定要参加的，一定要把握好秋招的机会。之前在小红书问放弃秋招准备春招可不可以，清一律的都是让我把握好秋招。我之前是觉得太马不停蹄了，想喘口气，到春招可以准备的好点。其实都是借口啊，就是太懒。如今的我，已经悟了，秋招拿到offer，可以直接摆烂了，想干啥都行啊，在想参加春招的话也可以呀，骑驴找马，心里也有底气。话说春招的那时候要写毕业论文，正是头疼的时候呢。 又是一个决策时间，我的人生只有自己能把握呀。","categories":[{"name":"Bug调试","slug":"Bug调试","permalink":"https://vanessayaoyao.github.io/categories/Bug%E8%B0%83%E8%AF%95/"}],"tags":[]},{"title":"Dao层及各层的串联","slug":"dao","date":"2022-08-17T00:04:30.000Z","updated":"2022-08-17T00:30:45.210Z","comments":true,"path":"2022/08/17/dao/","link":"","permalink":"https://vanessayaoyao.github.io/2022/08/17/dao/","excerpt":"","text":"“姐，我再说一遍，你是我姐，你不是我粉丝。你不要再让我听到你说你是粉丝。这两个字我不要再听到了，听到没有。我再给你说一遍，我对你是真心的，你是我的姐，你是我唯一的姐！ “如果你真觉得我是在利用你，从始至终为了利用你没有把你当过姐，呵，那我可以给你Dao，你现在过来，你知道我家在哪，我让你一D捅S我。” 由此我们可以引出，Dao层是干嘛的。（认真脸） Dao层是干嘛的？DAO 是 Data Access Object(数据访问对象的缩写)，DAO层是业务逻辑层与数据库层之间的中间层，大大降低了开发成本，提升了系统维护效率。业务逻辑代码通过调用DAO组件来实现与数据库的交互。 Dao层=Mapper层。 现在来走一遍流程看看一个接口是怎么串联起来各个层的。 首先是Controller层这里其实是easyopen的api，加上@ApiService后这个类就具有了提供接口的能力 123456789101112131415// @ApiService// public class FlowMessageApi extends BaseApi @Api(name = &quot;messsage.flow.read&quot;, wrapResult = false)@ApiDocMethod(description = &quot;已读&quot;, results = &#123; @ApiDocField(name = &quot;value&quot;, description = &quot;UserApp信息&quot;, elementClass = UserAppVo.class) &#125;)public DataRsp&lt;Boolean&gt; read(FlowMessageDto dto) &#123; logger.info(&quot;审批消息read:&#123;&#125;&quot;, JSON.toJSONString(dto)); DataRsp&lt;Boolean&gt; dataRsp = DataRsp.builer(); try &#123; return flowMessageService.updateRead(dto.getId()); &#125; catch (Exception e) &#123; com.newbanker.framework.exception.RspErrorUtil.mappingErrorInfo(dataRsp, e); &#125; return dataRsp;&#125; 调用Service层12// public interface FlowMessageService DataRsp&lt;Boolean&gt; updateRead(Integer id); 1234567891011121314// @Service(&quot;flowMessageService&quot;)// public class FlowMessageServiceImpl implements FlowMessageService@Overridepublic DataRsp&lt;Boolean&gt; updateRead(Integer id) &#123; logger.info(&quot;审批消息updateRead:&#123;&#125;&quot;, id); DataRsp&lt;Boolean&gt; dataRsp = DataRsp.builer(); try &#123; flowMessageLogic.updateRead(id); &#125; catch (Exception e) &#123; logger.error(&quot;审批消息updateRead失败&quot;,e); RspErrorUtil.mappingErrorInfo(dataRsp, e); &#125; return dataRsp;&#125; 调用Logic层12// public interface FlowMessageLogicvoid updateRead(Integer id); 123456// @Repository// public class FlowMessageLogicImpl implements FlowMessageLogic@Overridepublic void updateRead(Integer id) &#123; flowMessageDao.updateRead(id);&#125; 调用Dao层12// public interface FlowMessageDaovoid updateRead(Integer id); 12345678&lt;update id=&quot;updateRead&quot;&gt; update flow_message set readed = 1 where id=#&#123;id&#125; &lt;/update&gt; 简称套娃…","categories":[{"name":"Web相关","slug":"Web相关","permalink":"https://vanessayaoyao.github.io/categories/Web%E7%9B%B8%E5%85%B3/"}],"tags":[]},{"title":"如何合并分支？","slug":"merge","date":"2022-08-08T14:12:50.000Z","updated":"2022-08-08T14:58:06.798Z","comments":true,"path":"2022/08/08/merge/","link":"","permalink":"https://vanessayaoyao.github.io/2022/08/08/merge/","excerpt":"","text":"之前整理过一篇关于git的博客，但只会简单的推和拉，当时说用到在学，now it’s time。 代码回滚当我们想要回退到过去的版本时，就可以执行回滚操作，执行后，可以将工作空间的内容恢复到指定提交的状态： 1git reset --hard commitID 执行后，会直接重置为那个时候的状态。再次查看提交日志，我们发现之后的日志全部消失了。 那么要是现在我又想回去呢？我们可以通过查看所有分支的所有操作记录： 1git reflog 这样就能找到之前的commitID，再次重置即可。 idea图形化界面，下方点击想要返回版本的commit message，右击选择reset current branch to here，会出来几个选项让你选，选完就行了 hard移动本地库HEAD指针，重置暂存区，重置工作区回滚后，本地代码就是你回退版本的代码 soft回滚后，仅仅是把本地库的指针移动了，而暂存区和你本地的代码是没有做任何改变的。而你上次改动已提交committed到本地库的代码显示是绿色即未提交 mixed移动本地库HEAD指针，重置暂存区回滚后，不仅移动了本地库的指针，同时暂存区的东西也没了，上次添加到暂存区的文件没了 keep移动本地库HEAD指针，暂存区不变，重置工作区回滚后，本地代码就是你回退版本的代码，而暂存区是没有做任何改变的 原文链接：https://blog.csdn.net/chuanchengdabing/article/details/121560568 合并分支我们也可以将两个分支更新的内容最终合并到同一个分支上，我们先切换回主分支： 1git checkout master 接着使用分支合并命令： 1git merge test 会得到如下提示： 123Auto-merging hello.txtCONFLICT (content): Merge conflict in hello.txtAutomatic merge failed; fix conflicts and then commit the result. 在合并过程中产生了冲突，因为两个分支都对hello.txt文件进行了修改，那么现在要合并在一起，到底保留谁的hello文件呢？ 我们可以查看一下是哪里发生了冲突： 1git diff 因此，现在我们将master分支的版本回退到修改hello.txt之前或是直接修改为最新版本的内容，这样就不会有冲突了，接着再执行一次合并操作，现在两个分支成功合并为同一个分支。 假设test分支和master分支并没有什么不同，他们都有一个函数 123public void hello()&#123; System.out.println(&quot;hello&quot;)&#125; 我在master分支上修改函数名为hi(),并且commit 123public void hi()&#123; System.out.println(&quot;hi&quot;)&#125; 这时将master分支合并到test分支上是不存在冲突的，test分支上的hello会被覆盖。 idea图形化页面，右下角点击要合并的分支，然后选择merge select into current 那什么时候会出现冲突呢？ 我在master分支上修改函数,并且commit 123public void hello()&#123; System.out.println(&quot;hello world!&quot;)&#125; 在test分支上修改函数,并且commit 123public void hello()&#123; System.out.println(&quot;hello earth!&quot;)&#125; 这时将master分支合并到test分支上才会出现冲突。 idea会弹出一个弹窗让你选择哪个版本。选完之后点apply,处理完所有的冲突也就merge完了。","categories":[{"name":"Web相关","slug":"Web相关","permalink":"https://vanessayaoyao.github.io/categories/Web%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"git","slug":"git","permalink":"https://vanessayaoyao.github.io/tags/git/"}]},{"title":"项目中的DTO、VO和Entity分别都是用来干嘛的？","slug":"dto","date":"2022-08-08T14:01:17.000Z","updated":"2022-08-08T14:10:13.076Z","comments":true,"path":"2022/08/08/dto/","link":"","permalink":"https://vanessayaoyao.github.io/2022/08/08/dto/","excerpt":"","text":"项目中的DTO、VO和Entity分别都是用来干嘛的？Entity这个好说，一个entity对应数据库里的一张表 123456789101112131415161718@Data@Accessors(chain = true)@TableName(&quot;cw_user&quot;)@ApiModel(value = &quot;User对象&quot;, description = &quot;平台用户表&quot;)public class User implements Serializable &#123; @TableId(value = &quot;user_id&quot;, type = IdType.AUTO) private Integer userId; @ApiModelProperty(value = &quot;用户名&quot;) private String username; @ApiModelProperty(value = &quot;手机号&quot;) private String mobile; @ApiModelProperty(value = &quot;密码&quot;) private String password;&#125; VO这个有两种理解，在我接触的项目中更加偏向 第二种 表现层对象(View Object) VO：值对象(Value Object)，通常用于业务层之间的数据传递，和Entity一样也是仅仅包含数据而已。但应是抽象出的业务对象，可以和表对应，也可以不，这根据业务的需要。 VO：表现层对象(View Object)，主要对应展示界面显示的数据对象，用一个VO对象来封装整个界面展示所需要的对象数据。 对应前端页面的展示数据 DTODTO：数据传输对象(Data Transfer Object)，是一种设计模式之间传输数据的软件应用系统。数据传输目标往往是数据访问对象从数据库中检索数据。数据传输对象与数据交互对象或数据访问对象之间的差异是一个以不具有任何行为除了存储和检索的数据（访问和存取器）。 说点人话。。球球了。。 简单来说，当我们需要一个对象10个字段的内容，但这个对象总共有20个字段，我们不需要把整个PO对象全部字段传输到客户端，而是可以用DTO重新封装，传递到客户端。此时，如果这个对象用来对应界面的展现，就叫VO。说白了，就是对Entity 的一个映射，减少数据的请求之类的数据字段的个数。 原文链接：https://blog.csdn.net/qq_40990854/article/details/90489116 大体理解DTO和VO是干什么的了，都是一些字段的拼凑。其实只是名字的不同，差别好像不是很大。。DTO感觉用的比较多。。","categories":[{"name":"Web相关","slug":"Web相关","permalink":"https://vanessayaoyao.github.io/categories/Web%E7%9B%B8%E5%85%B3/"}],"tags":[]},{"title":"实习日常","slug":"some-feelings","date":"2022-07-02T11:30:40.000Z","updated":"2022-07-02T13:12:43.133Z","comments":true,"path":"2022/07/02/some-feelings/","link":"","permalink":"https://vanessayaoyao.github.io/2022/07/02/some-feelings/","excerpt":"","text":"上一篇（指路）主要是说了实习前的事，那今天就说说实习给我的感受吧。 实习一个多星期了，其实还好，前两天就是让我看看公司之前的项目。之后江哥问我要不要试试更有挑战性的工作，我欣然接受了，光看确实看不出什么。拉着我去参加了一个会议，总共有七八个人参加，就讨论一个推荐的优化。我原本以为我只是“参与”到这个需求中，没想到其实我是主要写代码的那个人。 但其实还好，有江哥帮忙就还好，有任何不会的都可以问他。虽然但是，还是挺头疼的，存redis值的那块逻辑我来来回回写了三版，写好了之后，又发现并没有存进去redis，看了好久才发现是数据库有问题。这里改好之后，开始测接口，参数不知道咋写，后来才知道把配置的一个参数改为false就可以了，接口返回数据了，但是完全不对啊，我发现我的idSet怎么变他返回的数据都不变的。又问江哥，才发现user为空的时候，直接跳去了另一个逻辑，这才不变的。写了两三天，大体写好了，给测试发了邮件申请测试。 在等待测试的空隙，江哥让我去看看阿里巴巴手册和项目MQ部分，看嘛，其实可以划水的，划了一个上午吧，江哥又让我过去，说，看的话还是没有写的好是吧，正好他那里又有几个接口要写，问我怎么想，我只能笑着应和，其实内心OS想的是让我歇歇吧哈哈。刚给我说完，一个测试小姐姐就拿着手机过来了，上来就说，你看这排序完全不对啊，巴拉巴拉。我其实有点懵，这么快就测试了吗，江哥说还得等会呢。此时此景，我无语凝噎，只能拉江哥过来，让我问测试跑batch了吗，打开之后确实有我的那个JobHandler，执行一次之后，还是顺序还是乱的，发现是not found。江哥看了之后说都没有我的执行器，添加了一个，还是找不到。呃呃，江哥去问运维了，问完之后，改了一个地址，可以了，芜湖，有我的key了。 可以了之后，测试提了个bug，但还好，挺容易改的。她一会儿又过来说，你看，怎么又乱了？！呃呃，我也回答不出来为什么，不应该啊，然后她自己就走了。之后又有一个测试在钉钉上找我，说车位和房源重复的时候，只展示车位。这个要求写的时候我确实没想到，问了江哥，江哥说下午看看，结果他下午请假了。他给我说下午不来的时候，我已经感觉到不妙了，到了下午，测试就一直催我，问我改好了没有，问我怎么样了。说是计划今天（周五）测完，下周一就要上线。这点我真是有点无语，上午刚提的bug，下午就要改好，这时间也太短了吧。 我逻辑想好了，但是写的时候有一步卡住了，想调另一个module的实体，但调不过来。鼓足勇气问了旁边的小姐姐，但她也没能帮我解决。江哥让我找刘洋，刘洋也不在，后来一个人过来帮我解决了这个问题，是江哥让他过来的，让直接把其他module的实体复制过来一份。这个问题解决之后，还有其他问题，就一直报错，哈哈人生好难。主要是我对车位和房源怎么联系起来的这块业务不是很熟悉。后来发现，那个值是可以为空的，把这里改了之后，终于可以了，但也快要到六点了。去和测试说了情况，问周一上午行不行，内心OS你还要我怎样。 其实工作的内容和一定的压力都在情理之中，总的来说，感觉还是可以的，写起代码来也没有上课那种度日如年的感觉，反而意识不到时间其实过的很快。生活嘛，不只有工作，其他的方方面面共同构建起了我的最近。那就从衣食住行说起吧。 衣就还好，穿着舒服就行，在意识到“服美役”的存在后，我就有意识的让自己不在过度关注服饰，怎么说道阻且长吧。哦对了，这几天青岛一直下雨，导致我的鞋一直不干，这是可以说的吧。吃饭的话，早晨起来就直接走了，时间来得及的话，到公司楼下便利店买个包子啥的还是挺方便的。但是午饭的话，一直吃便利店的饭就不太好了，一来他不是现做的，二来也比较贵。听说有个订餐群，但我一直没有让谁把我拉进去，就是感觉要交流，交流就哒咩，不想交流哈哈，这种心态还是不行的，下周找个人把我拉进订餐群。住的话，就是在龙泽书苑住了，还挺好的，快递挺近的，楼下也有很多买饭的。合租的情侣也挺好的，他们卤了一锅东西，还盛了让我尝尝，过生日也分给我了一块蛋糕。 感觉最不好的就是通勤时间了，在学校住的时候，可以从学校穿过去，从西门坐地铁，时间差不多一个小时左右。现在在龙泽书苑住，通勤时间就差不多一个半小时了。我早晨的时候，也不知怎么回事，五点多就会醒，也不是被闹铃叫醒的，就是自己醒的，可能怕迟到，心里不踏实。一个半小时的话，九点上班，其实七点起时间就不会很赶的，对吧。但是！公交不比地铁啊，公交不知道啥时候来啊。有一次，我等了20多分钟的公交！心里都想着完了完了要迟到了，在换乘的时候一路狂奔，打卡的时候距离九点还有三分钟。 我在坐公交和地铁的时候就一直听博客，有一次听到了一个关于住在北上广的感受啥的，我一直都想去北京的，也说不上为啥，就是感觉如果要在中国所有的城市里挑一个，那个就是北京了。他们聊着聊着我就突然想到，我以后不会一直都这样吧，每天早起赶公交赶地铁，北京那寸土寸金的地方，租房子便宜的话那只能远点了，不要啊，我不想把时间都浪费通勤上啊。。。无能狂怒ing。去设想未来是怎样的，会不会每天都惨兮兮的，如果一直都这样的话，其实是件挺可怕的事情啊，大好的人生啊。 那就暂时别想那么远了。人生还有很多可能性的。啊，秋招，我得开始准备起来了吧。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://vanessayaoyao.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[]},{"title":"什么叫兵荒马乱","slug":"these-days","date":"2022-06-25T12:21:09.000Z","updated":"2022-08-08T15:00:17.556Z","comments":true,"path":"2022/06/25/these-days/","link":"","permalink":"https://vanessayaoyao.github.io/2022/06/25/these-days/","excerpt":"","text":"最近的日子真的是马不停蹄，焦头烂额。 5月19号我在海信官网投了简历，这就算我正式开始找实习了。海信一直没给我回信，直到现在！现在还正在处理中！垃圾！手机上下载了好多找工作的软件，投了很多都被拒绝了，还emo了几天，但一直没放弃。从19号开始找，到25号去面试第一家公式，说起来时间还听短的，甚至还有点轻轻松松的意味，但我真的被拒绝了好多次，在实习生上面投的竟然一个回音都没有。现在回想起来，好像真的也不是真的很困难，总之，重在坚持，再加一点缘分。 去面试的第一家，就是我现在在实习的公司了。我是真的很菜，但是面试完之后人事小姐姐说我过了，紧接着就和我谈薪资了。她问我期待薪资多少，我支支吾吾说我的期待不怎么高，就大概三四千左右。她听完之后竟然翻了个白眼，说我觉得你怎么也得说个五千吧。之后，也有去面试另一家，但是和第一家比起来环境各方面都不太好，感觉很会压榨的那种，还得用自己的电脑，薪资要不是我提，他都不说的。有了第一家，我就没再去找了，和人事小姐姐约好了6月22号上班。offer发到我的邮箱的时候，我真的很高兴，这种高兴有点像大二的时候帅姐姐夸我项目做的好的时候的高兴，感觉要飞到天上去了。 我是6月20号考完所有的考试，当时定上班日期的时候没想太多，离考完试就隔了一天。我没想到我还有一篇论文写不完，四千字的，其实也在预料之中，法语和美国文学都需要复习整理，我就想着考完试在写这篇论文。22号就需要交了，意思就是我需要在一天之内写完，ok，fine，我能写完。让我意料不到的还是实习不能留校，我之前一直在打听留校的事，我觉得大概率、极大概率是可以留校的。留校通知下来之后，我也就美美的提交了申请。6月19号，辅导员给我打电话说实习不能留校，学校要封闭管理，非必要不能离校，你这天天出去的不行呀。 不能留就不能留，我出去租房子。一开始我对租房子这事，甚至是有点小期待的，一个人，一个自己的空间。当时，考试周嘛，室友一个回来的比一个晚，宿舍也不熄灯，每天都得我说关灯吧，才关灯。都快十二点了，不关灯我睡不着。我就开始找房子了嘛，找着找着我发现，太难了呀，人家一般都是一年的合同，二个月短租的很少很少。考美国文学的前一个晚上和上午，我背也背不进去，一直在看房子。进美国文学考场的时候，都还是心神不宁的，还好，考的不难，都胡诌上了。 一开始我是想在五四广场周围找的，公司旁边有个滨海花园，甚至能步行到公司，每天早上八点多起床，走路到公司，美滋滋呀。然而根本找不到，在贝壳啥的找房APP上都是有一个狠便宜狠好狠近的房子，发消息问就是让加微信，加微信就说没有短租的，都是一年的合同。然后就扩大范围，三十分钟能到五四广场的也行。好不容易在小红书上刷到一个可以短租的，我当天下午就去看房了，然而那房子也太垃圾了，隔断房。我找了半天，没看见屋里有插头，问了一下那中介大哥才知道在床底下。卫生也不咋好，空气中弥漫着一股陈腐的味道，卫生间的垃圾桶里竟然有烟头，也没空调，价格也不是特别特别便宜，980一个月。后来那大哥也挺实诚的跟我说，这房子就是不太好租，所以才短租。 想着，要不租一年的？租一年的话，那我宿舍这边要退吗？那得多少钱啊？还是继续找着两个月短租的房子。去看了那个房之后，我觉得租房有点困难。我又转过头去问辅导员真的不能留校吗，诉了一番苦，但辅导员也没什么办法，还是说不能留校。原本给家里打电话说是可以留校的，他们也比较放心。现在给他们说了我要租房子之后，他们就开始担心我了，觉得租房子不安全，真不行就回家来不去实习了。家里人可能真的是我的软肋吧，没给他们打电话之前我是还挺乐观的，还没有担心太多，打完电话我就开始e了个大mo了，甚至想着要不就直接摆烂不实习了直接回家。 这怎么可以呀，找工作没有实习怎么办呀。可是我没有地方住呀。太难受了。当时距离学校正式放暑假还有一个星期吧。时间太紧了吧。22号实习的前一天晚上，我都在考虑还要不要去了。哦，对了，我甚至还去问了HR小姐姐公司提不提供住宿，我知道百分之九十九是不提供的，但我还是问了，结果也是显而易见的。室友给我提了建议说可以去龙泽书院问问有没有同学暑假回家可以短租出去的，真不行也可以偷偷住在宿舍呀，又没人来查。人间好室友啊，好主意！到这我的提着的心算是放下来了，真不行就住学校，偷偷着住，下下策。 22号那天我还是早早的就去了，那天的早上海雾特别大，不只是早上，那几天全天都是这样，空气中飘着小水珠，特别潮。语文考试提问，此处的环境描写起了什么作用？答，为主人公悲惨的实习生活做了铺垫。其实，实习内容还好，第一天就是填了一些合同文件啥的，熟悉熟悉了公司环境啥的，就领我到了工位。带我的江哥就是面试我的人，他是Java架构师，听“架构师”这几个字就可以知道好牛的。感觉他也是很真诚，真心希望我能在公司学习成长。这几天没干什么事，就是让我看看项目，学习学习。我不会的内容还真是很多，但他也没有太push我，就让我慢慢学。 实习第一天，从地铁站出来拍的。2022.6.22 22号是星期三，该我做核酸，但是我中午回不来，只能去外面做。又是一件麻烦事，还得找一个时间合适的，不是很远的做核酸的地方。六点下班，恒星晚上的班八点才开始，等做好回到宿舍已经是九点多了，身心俱疲。要怪就要怪这他爹的疫情，到底什么时候能够滚出我们的生活。不是疫情的话，我他爹的根本不用两天做一次核酸；不是疫情的话，我他爹的跟不用出去找房子住，可以直接留校的。说到底，还是早日润出去，这一切到底为什么，政治不可谈啊。 有同学在龙泽书院住，我就加了她的微信问她回不回家，她只回家几天，因为要考雅思。但是她推个我了一个中介，这个中介好像也没有合适的，就把我拉到一个几百人的微信群里，让我在群里问问。群里有人说自家房出租的，我加了好友问可不可以租两个月，可以！太好了！在微信中介大哥的朋友圈又刷到一个可以短租的房子，星期五那天下了班去看的，我只能说图片仅供参考，说多了都是泪。 星期六，也就是昨天，去看了龙泽书院的房子，在还没看之前，我一直在祈祷就这套吧，就这套吧，让我顺利租下来吧。去那看看了，我就觉得可以，当场就签了合同。房主是一对老夫妻，我加的是叔叔的微信，签合同的时候是阿姨签的，她问我租多久，我说两个月，她就面露难色，说一般都是租半年。我就说叔叔同意的，她思考了一下，勉强说听你叔叔的吧。和姐姐打了电话，要了房租的钱，姐姐也很爽快的给我了。晚上给爸爸打电话，又给了我生活费。 钱啊钱啊钱啊，赶紧让我赚钱吧，让我自己更够养活自己，不用在向家里要钱了。这一切都算稳定下来了，有个地方住了，这两天就陆陆续续把东西从宿舍搬进去。安心实习吧，努力学习，好好学习，抓紧时间学习，看看秋招的时候能不能有个好结果。计算机五班里有个学长，17级的，他好像就是毕了业直接去了新加坡工作。大四小学期还有一门课，秋季学期还有一门1-9周的课，大学就要结束了呀。 昨天晚上八点多的时候去外院交了应用语言学的论文。骑着小车从法学院那条路下来的，没有什么灯光。出了外院左拐去图书馆，那条路也是黑黑的。突然就想来有一次凌晨四点多，我一个人骑着电动车去考科二，但我并不害怕，一路放着歌，听着音乐。我其实真的挺勇敢的。 实习第二天，亲爱的中国海洋大学，天气不错。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://vanessayaoyao.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"intern","slug":"intern","permalink":"https://vanessayaoyao.github.io/tags/intern/"}]},{"title":"第一次笔试题","slug":"mst","date":"2022-05-27T05:37:19.000Z","updated":"2022-05-28T05:54:47.856Z","comments":true,"path":"2022/05/27/mst/","link":"","permalink":"https://vanessayaoyao.github.io/2022/05/27/mst/","excerpt":"","text":"啥也没准备就直接去面试了，到那了之后觉得工作环境还是不错的。在走廊的小桌子那坐了一会，人事给了我两张纸让我填，一张是基本信息啥的，另一张是笔试题。瞥了一眼，一个题都不会做哈哈哈哈。 1.设计模式的六大原则有哪些？ 单一职责原则（Single Responsibility Principle） 开闭原则(Open-Closed Principle, OCP) 里氏代换原则(Liskov Substitution Principle, LSP) 依赖倒置原则（Dependence Inversion Principle，DIP） 接口隔离原则(Interface Segregation Principle, ISP) 迪米特法则(Law of Demeter, LoD) 这东西背下来也没有什么意义，正好清空霞光的新番出了设计模式，大约一个小时，去看看去。 2.如何实现反射调用方法？（1）通过 Class 类的 getMethod 方法取的 Method 对象，并设置调用方法时需要的参数类型。 （2）使用 Method 方法调用 invoke 方法，并向该方法传递参数，其参数通常是一个类的对象。 3.数据库隔离级别数据库事务的隔离级别有4种，由低到高分别为Read uncommitted、Read committed 、Repeatable read 、Serializable 。 4.HashMap的数据结构（1.7与1.8的区别）HashMap底层实现JDK&lt;=1.7数组+链表，JDK&gt;=1.8数组+链表+红黑树；HashMap这一个类型底层涉及到3中数据类型，数组、链表、红黑树，其中查询速度最快的是数组，时间复杂度是O(1),链表数据量少的时候还行，数据量过大性能就一般了，它的时间复杂度是O(N)，红黑树在数据量打的时候性能会比链表要好，他的时间复杂度是O(logn),这里在链表和红黑树这里性能对比其实在HashMap的扩容时，已经体现出来了，Hash值产生碰撞后，链表长度&gt;8时会由链表转换为红黑树，而当红黑树的节点&lt;6时，会由红黑树转换为链表，这就是二者的性能临界点。 5.JAVA1.8有哪些新的特性？ Lambda表达式：Lambda允许把函数作为一个方法的参数（函数作为参数传递到方法中）。 方法引用：方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。 默认方法：默认方法就是一个在接口里面有了一个实现的方法。 新工具：新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。 Stream API：新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。 Date Time API：加强对日期与时间的处理。 Optional类：Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。 Nashorn，JavaScript引擎：JDK1.8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。 6.以下or查询有什么问题？该如何优化？1select * from t where num = 10 or num = 20; 应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描。可以改为： 123select id from t where num=10union allselect id from t where num=20 https://blog.csdn.net/qq_43842093/article/details/124548764 7.StringBuffer与StringBuilder的区别 String: 不可变字符串； StringBuffer: 可变字符串、效率低、线程安全； StringBuilder: 可变字符序列、效率高、线程不安全； 8.线程池的种类有以及线程的生命周期有哪些？1、newCachedThreadPool 2、newFixedThreadPool 3、newSingleThreadExecutor 4、newScheduleThreadPool 5、newSingleThreadScheduledExecutor 线程的生命周期会经历以下几个状态： 新建：new创建线程对象时 就绪：调用 **start()**方法时 运行：调用 **run()**方法时 阻塞： 多种原因可导致阻塞 死亡：多种原因 9.Spring中都使用了哪些设计模式？Spring 框架中使用到了大量的设计模式，下面列举了比较有代表性的： 1、代理模式：在 AOP 和 remoting 中被用的比较多。 2、单例模式：在 spring 配置文件中定义的 bean 默认为单例模式。 3、模板模式：用来解决代码重复的问题。 比如. RestTemplate, JmsTemplate, JpaTemplate。 4、委派模式：Spring 提供了 DispatcherServlet 来对请求进行分发。 5、工厂模式：BeanFactory 用来创建对象的实例，贯穿于 BeanFactory / ApplicationContext 接口的核心理念。 6、代理模式：AOP 思想的底层实现技术，Spring 中采用 JDK Proxy 和 CgLib 类库。 10.Mysql的锁类型有哪些？按锁粒度分类：行级锁&amp;表级锁&amp;页级锁 锁级别分类：共享锁 &amp; 排他锁 &amp; 意向锁 有重复数字的升序数组的二分查找 Java基础太差了，线程完全不懂，mysql只会基础语句，随便问问都不会，设计模式也没去学过，还有数据结构也没去学，leetcode只写过十几道。。。快点学习。。。我真的会谢。。。","categories":[{"name":"Web相关","slug":"Web相关","permalink":"https://vanessayaoyao.github.io/categories/Web%E7%9B%B8%E5%85%B3/"}],"tags":[]},{"title":"Nginx","slug":"nginx","date":"2022-05-13T12:16:31.000Z","updated":"2022-05-14T13:37:50.650Z","comments":true,"path":"2022/05/13/nginx/","link":"","permalink":"https://vanessayaoyao.github.io/2022/05/13/nginx/","excerpt":"","text":"Nginx概述Nginx介绍Nginx是一款轻量级的Web服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx的网站有：百度、京东、新浪、网易、腾讯、淘宝等。 Nginx下载和安装https://nginx.org/en/download.html 安装过程：1.安装依赖包 yum -y install gcc pcre-devel zlib-devel openssl openssl-devel2.下载Nginx安装包 wget https://nginx.org/download/nginx-1.16.1tar.gz3.解压tar -zxvf nginx-1.16.1.tar.gz4.cd nginx-1.16.15../configure ==prefix=/usr/local/nginx6.make &amp;&amp; make install Nginx目录重点目录/文件： conf/nginx.conf nginx配置文件 html 存访静态文件（html css js等） logs 日志目录，存放日志文件 sbin/nginx 二进制文件，用于启动、停止Nginx服务 Nginx命令查看版本在sbin目录下 1.&#x2F;nginx -v 检查配置文件正确性123root@iZuf67ss8kqoyvili0eqo2Z:&#x2F;usr&#x2F;sbin# .&#x2F;nginx -tnginx: the configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf syntax is oknginx: configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf test is successful 启动和停止启动Nginx服务 1.&#x2F;nginx 停止Nginx服务 1.&#x2F;nginx -s stop 启动完成后可以查看Nginx进程 1ps -ef|grep nginx 重新加载配置文件1.&#x2F;nginx -s reload Nginx配置文件结构 全局块 和Nginx运行相关的全局配置 events块 和网络连接相关的配置 http块 代理、缓存、日志记录、虚拟主机配置 http全局块 server块 server全局块 location块 注意：http块中可以配置多个server块，每个server块中可以配置多个location块。 Nginx具体应用部署静态资源Nginx可以作为静态Web服务器来部署静态资源。静态资源指在服务端真实存在并且能够直接展示的一些文件，比如常见的html页面，css文件，js文件，图片、视频等资源。 相对于Tomcat，Nginx处理静态资源的能力更加高效，所以在生产环境下，一般都会将静态资源部署到Nginx中。将静态资源部署到Nginx非常简单，只需要将文件复制到Nginx安装目录下的html目录中即可。 12345678server&#123; listen 80; # 箭头端口 server_name localhost; # 服务器名称 location &#x2F;&#123; # 匹配客户端请求url root html; # 指定静态资源根目录 index index.html # 指定默认首页 &#125;&#125; Spring Boot项目 12345678910111213server &#123; listen 8899; server_name 47.102.215.61; add_header Access-Control-Allow-Origin *; location &#x2F; &#123; root &#x2F;home&#x2F;test&#x2F;static; charset utf-8; add_header &#39;Access-Control-Allow-Origin&#39; &#39;*&#39;; add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;; add_header &#39;Access-Control-Allow-Methods&#39; &#39;*&#39;; add_header &#39;Access-Control-Allow-Headers&#39; &#39;Content-Type,*&#39;; &#125; &#125; Django项目 123456789101112131415161718server &#123; listen 8888; server_name 47.102.215.61; root &#x2F;home&#x2F;Haixun; index index.html index.htm index.nginx-debian.html; location &#x2F; &#123; include uwsgi_params; uwsgi_pass 127.0.0.1:8002; uwsgi_send_timeout 120s; uwsgi_read_timeout 120s; &#125; location &#x2F;static &#123; alias &#x2F;home&#x2F;Haixun&#x2F;static; &#125; location &#x2F;media &#123; alias &#x2F;home&#x2F;Haixun&#x2F;media; &#125;&#125; 反向代理正向代理正向代理是一个位于客户端和原始服务器（origin server）之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标（原始服务器），然后代理向原始服务器转交请求并将获得的内容返回给客户端。 正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。（梯子）正向代理一般是在客户端设置代理服务器，通过代理服务器转发请求，最终访问到目标服务器。 反向代理反向代理服务器位于用户与目标服务器之间，但是对于用户而言，反向代理服务器就相当于目标服务器，即用户直接访问反向代理服务器就可以获得目标服务器的资源，反向代理服务器负责将请求转发给目标服务器。 用户不需要知道目标服务器的地址，也无须再用户端作任何设定。 配置反向代理1234567server&#123; listen 82; servername 192.168.138.100; location &#x2F; &#123; proxy_pass http:&#x2F;&#x2F;192.168.138.101:8080; # 反向代理配置，将请求转发到指定服务 &#125;&#125; 负载均衡早期的网络流量和业务功能都比较简单，单台服务器就可以满足基本需求，但是随着互联网的发展，业务流量越来越大并且业务逻辑也越来越复杂，单台服务器的性能及单点故障问题就凸显出来了，因此需要多台服务器组成应用集群，进行性能的水平扩展以及避免单点故障出现。 应用集群：将同一应用部署到多台机器上，组成应用集群，接收负载均衡器分发的请求，进行业务处理并返回响应数据 负载均衡器：将用户请求根据对应的负载均衡算法分发到应用集群中的一台服务器进行处理 配置负载均衡1234567891011upstream targetserver &#123; server 192.168.138.101:8080; server 192.168.138.101:8081;&#125;server &#123; listen 8080; server_name 192.168.138.100; location &#x2F; &#123; proxy_pass http:&#x2F;&#x2F;targetserver; &#125;&#125; 负载均衡策略 轮询：默认方式 weight：权重方式 ip_hash：根据ip分配方式 least_conn：根据最少连接方式 url_hash：根据url分配方式 fair：根据响应时间方式","categories":[{"name":"Web相关","slug":"Web相关","permalink":"https://vanessayaoyao.github.io/categories/Web%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://vanessayaoyao.github.io/tags/nginx/"}]},{"title":"Mybatis-Plus之Lambda条件构造器","slug":"querywrapper","date":"2022-05-10T10:23:26.000Z","updated":"2022-05-10T10:42:51.012Z","comments":true,"path":"2022/05/10/querywrapper/","link":"","permalink":"https://vanessayaoyao.github.io/2022/05/10/querywrapper/","excerpt":"","text":"LambdaQueryWrapper&lt;T&gt;创建LambdaQueryWrapper&lt;T&gt;实例的三种方法： 1234LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = new LambdaQueryWrapper();LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper1 = new QueryWrapper&lt;User&gt;().lambda(); // 官方建议下面这种方法LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper2 = Wrappers.lambdaQuery(); 简单用法 12345LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = new LambdaQueryWrapper();lambdaQueryWrapper.like(User::getUsername , &quot;k&quot;).lt(User::getAge , 30);List&lt;User&gt; userList = userMapper.selectList(lambdaQueryWrapper);userList.forEach(System.out::println);lambdaQueryWrapper.eq(User::getUsername, username); LambdaQueryChainWrapper&lt;T&gt;123List&lt;User&gt; userList = new LambdaQueryChainWrapper&lt;User&gt;(userMapper) .like(User::getUsername , &quot;k&quot;).lt(User::getAge , 30).list();userList.forEach(System.out::println);","categories":[{"name":"Web相关","slug":"Web相关","permalink":"https://vanessayaoyao.github.io/categories/Web%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"mybatis-plus","slug":"mybatis-plus","permalink":"https://vanessayaoyao.github.io/tags/mybatis-plus/"}]},{"title":"RequestBody、RequestParam、PathVariable注解以及不加注解接收参数的区别","slug":"request","date":"2022-05-10T10:08:39.000Z","updated":"2022-05-10T10:46:59.155Z","comments":true,"path":"2022/05/10/request/","link":"","permalink":"https://vanessayaoyao.github.io/2022/05/10/request/","excerpt":"","text":"@RequestParam主要用来接收GET请求拼接在URL后的参数，或者是POST传递，且Content-type为x-www-form-urlencoded方式。格式为xxx?username=123&amp;password=456。 因为不管是GET方式还是用x-www-form-urlencoded方式传递，参数都是以键值对方式拼接的，然后经过URLencoded编码，传递给服务端。@RequestParam只能接收简单参数类型，复杂的参数类型要用@RequestBody来接收，或者不加注解来接收。 @RequestBody主要用来接收前端传递给后端的 json字符串中的数据(请求体中的数据) 使用@RequestBody该注解，前端请求只能为POST，因为该注解是从请求体中获得对象的。且请求头中的Content-type一般为application/json方式。所以使用该注解能够接收JSON格式的数据，并且能把接收到的JSON数据绑定到JAVA对象中 @PathVariable接收请求路径中占位符的值，”/{id}” 什么也不写当请求content_type为：application/x-www-form-urlencoded类型的或multipart/form-data时，数据格式为aaa=111&amp;bbb=222。","categories":[{"name":"Web相关","slug":"Web相关","permalink":"https://vanessayaoyao.github.io/categories/Web%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"springmvc","slug":"springmvc","permalink":"https://vanessayaoyao.github.io/tags/springmvc/"}]},{"title":"SpringBoot项目部署到服务器","slug":"springboot-on-linux","date":"2022-04-13T00:42:12.000Z","updated":"2022-04-16T02:48:10.756Z","comments":true,"path":"2022/04/13/springboot-on-linux/","link":"","permalink":"https://vanessayaoyao.github.io/2022/04/13/springboot-on-linux/","excerpt":"","text":"这是一个简单的前后端分离的SpringBoot项目。登录、注册、登出。涉及到发邮件、用redis做缓存，SpringSecurity拦截，跨域解决，开发环境和生产环境的切换。 环境安装安装JDK1sudo apt install openjdk-8-jdk 测试 1234root@iZuf67ss8kqoyvili0eqo2Z:~# java -versionopenjdk version &quot;1.8.0_292&quot;OpenJDK Runtime Environment (build 1.8.0_292-8u292-b10-0ubuntu1~16.04.1-b10)OpenJDK 64-Bit Server VM (build 25.292-b10, mixed mode) 安装Redis1sudo apt install redis-server 测试 123root@iZuf67ss8kqoyvili0eqo2Z:~# redis-cli127.0.0.1:6379&gt; pingPONG 安装MySql1sudo apt install mysql-server-8.0 在root权限下，可以直接登录服务器，不用输密码。 1mysql -u root -p 创建项目的数据库 1create database springboot; 常用的命令查看端口占用 lsof(list open files)是一个列出当前系统打开文件的工具。 1laof -i:端口号 1netstat -tunlp | grep 端口号 -t (tcp) 仅显示tcp相关选项 -u (udp)仅显示udp相关选项 -n 拒绝显示别名，能显示数字的全部转化为数字 -l 仅列出在Listen(监听)的服务状态 -p 显示建立相关链接的程序名 查看服务的进程号 1ps -ef|grep nginx 杀掉对应进程 1kill -9 PID 1 (HUP)：重新加载进程。 9 (KILL)：杀死一个进程。 15 (TERM)：正常停止一个进程。 nginx启动、停止、重启 1sudo service nginx start &#x2F; stop &#x2F; status &#x2F; restart 1sudo systemctl restart nginx.service uwsgi启动、停止 1uwsgi --ini uwsgi.ini 1sudo killall -9 uwsgi 尝试启动在阿里云把项目生产环境的启动端口打开 1java -jar springboot-project-0.0.1-SNAPSHOT.jar 意想不到的，非常流畅的就启动了，虽然后面还是遇到了一些问题，但最起码可以看到页面了。回想一开始部署Django的时候，那真是废了老鼻子劲了，各种各样的Bug，寸步难行，快给人整崩溃了。 遇到的问题发送邮件换端口阿里云25端口是被封了的，听说是处于安全的考虑，可以换成465端口。 123456789101112131415spring: mail: host: smtp.163.com username: password: port: 465 properties: mail: smtp: ssl: enable: true imap: ssl: socketFactory: fallback: false 后台运行jar把xshell叉了，项目就停了，这不行啊。怎么让它可以一直挂着？ 1nohup java -jar love-0.0.1-SNAPSHOT.jar &amp; no hangup。此时程序控制台输出会被转移到 nohup.out 文件中。 分离了？嘿，我给你合上！这是一个比较神奇的问题，我把静态文件从springboot里拿了出来，放在了和jar包同一个目录下。咱们就是一个前后端大分离的动作。按说这时候的springboot的项目就纯纯的提供接口了，没有html页面了，但是我启动还是可以访问到index.html。我clean了好几次，再打包，结果还是可以访问到index.html。我就试着把那个jar包在本地启动，是没有html页面的，放在服务器上就有了。把服务器上的static文件夹删了才访问不到了，这是什么情况！难道nginx可以自动反向代理？我配置什么都没写啊？神奇！ 这里或许是springboot项目在起作用。。 Nginx反向代理Nginx非常强大，它能够通提供非常方便的反向代理服务，并且支持负载均衡。 啥是反向代理，听起来好高大上，我现在的理解就是，把静态资源交给nginx管，这样访问速度能快点。 12cd &#x2F;etc&#x2F;nginxsudo vim nginx.conf 12345678910111213server &#123; listen 80; server_name 192.168.10.4; add_header Access-Control-Allow-Origin *; location &#x2F; &#123; root &#x2F;home&#x2F;test&#x2F;static; charset utf-8; add_header &#39;Access-Control-Allow-Origin&#39; &#39;*&#39;; add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;; add_header &#39;Access-Control-Allow-Methods&#39; &#39;*&#39;; add_header &#39;Access-Control-Allow-Headers&#39; &#39;Content-Type,*&#39;; &#125; &#125; 通过另一个端口访问静态资源，好像是快了那么一点点。但我登不进去主页了？？info接口没有获得用户信息？？？ tell me why!!!!","categories":[{"name":"Web相关","slug":"Web相关","permalink":"https://vanessayaoyao.github.io/categories/Web%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://vanessayaoyao.github.io/tags/springboot/"}]},{"title":"自定义SpringBoot启动Banner","slug":"edit-springboot-banner","date":"2022-04-02T09:11:56.000Z","updated":"2022-04-02T09:21:13.776Z","comments":true,"path":"2022/04/02/edit-springboot-banner/","link":"","permalink":"https://vanessayaoyao.github.io/2022/04/02/edit-springboot-banner/","excerpt":"","text":"SpringBoot项目启动时会在控制台打印banner, be like: 1234567 . ____ _ __ _ _ &#x2F;\\\\ &#x2F; ___&#39;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | &#39;_ | &#39;_| | &#39;_ \\&#x2F; _&#96; | \\ \\ \\ \\ \\\\&#x2F; ___)| |_)| | | | | || (_| | ) ) ) ) &#39; |____| .__|_| |_|_| |_\\__, | &#x2F; &#x2F; &#x2F; &#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|_|&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|___&#x2F;&#x3D;&#x2F;_&#x2F;_&#x2F;_&#x2F; :: Spring Boot :: (v2.6.5) 想修改其实很容易，只需要在resources文件夹下加上一个banner.txt文件即可 可以使用在线生成网站进行生成自己的个性Banner：https://www.bootschool.net/ascii 12345678 ██ ██ ██ ██ ██ ██ ██ ██░██ ░██ ░██ ░██ ░██ ░██ ░██ ░██░██ ░██ █████ ░██ ░██ ██████ ░██ █ ░██ ██████ ██████ ░██ ░██░██████████ ██░░░██ ░██ ░██ ██░░░░██ ░██ ███ ░██ ██░░░░██░░██░░█ ░██ ██████░██░░░░░░██░███████ ░██ ░██░██ ░██ ░██ ██░██░██░██ ░██ ░██ ░ ░██ ██░░░██░██ ░██░██░░░░ ░██ ░██░██ ░██ ░████ ░░████░██ ░██ ░██ ░██░██ ░██░██ ░██░░██████ ███ ███░░██████ ░██░ ░░░██░░██████ ░███ ███░░██████░░ ░░ ░░░░░░ ░░░ ░░░ ░░░░░░ ░░ ░░ ░░░░░░ ░░░ ░░░ ░░░░░░ 内容随便改，甚至可以这样 1234567891011121314151617181920&#x2F;&#x2F; _ooOoo_ &#x2F;&#x2F;&#x2F;&#x2F; o8888888o &#x2F;&#x2F;&#x2F;&#x2F; 88&quot; . &quot;88 &#x2F;&#x2F;&#x2F;&#x2F; (| ^_^ |) &#x2F;&#x2F;&#x2F;&#x2F; O\\ &#x3D; &#x2F;O &#x2F;&#x2F;&#x2F;&#x2F; ____&#x2F;&#96;---&#39;\\____ &#x2F;&#x2F;&#x2F;&#x2F; .&#39; \\\\| |&#x2F;&#x2F; &#96;. &#x2F;&#x2F;&#x2F;&#x2F; &#x2F; \\\\||| : |||&#x2F;&#x2F; \\ &#x2F;&#x2F;&#x2F;&#x2F; &#x2F; _||||| -:- |||||- \\ &#x2F;&#x2F;&#x2F;&#x2F; | | \\\\\\ - &#x2F;&#x2F;&#x2F; | | &#x2F;&#x2F;&#x2F;&#x2F; | \\_| &#39;&#39;\\---&#x2F;&#39;&#39; | | &#x2F;&#x2F;&#x2F;&#x2F; \\ .-\\__ &#96;-&#96; ___&#x2F;-. &#x2F; &#x2F;&#x2F;&#x2F;&#x2F; ___&#96;. .&#39; &#x2F;--.--\\ &#96;. . ___ &#x2F;&#x2F;&#x2F;&#x2F; .&quot;&quot; &#39;&lt; &#96;.___\\_&lt;|&gt;_&#x2F;___.&#39; &gt;&#39;&quot;&quot;. &#x2F;&#x2F;&#x2F;&#x2F; | | : &#96;- \\&#96;.;&#96;\\ _ &#x2F;&#96;;.&#96;&#x2F; - &#96; : | | &#x2F;&#x2F;&#x2F;&#x2F; \\ \\ &#96;-. \\_ __\\ &#x2F;__ _&#x2F; .-&#96; &#x2F; &#x2F; &#x2F;&#x2F;&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#96;-.____&#96;-.___\\_____&#x2F;___.-&#96;____.-&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x2F;&#x2F;&#x2F;&#x2F; &#96;&#x3D;---&#x3D;&#39; &#x2F;&#x2F;&#x2F;&#x2F; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ &#x2F;&#x2F;&#x2F;&#x2F; 佛祖保佑 永无BUG 永不修改 &#x2F;&#x2F; 哈哈哈哈，太搞了。 这样技术含量并不太高的小trick, 却让我觉得眼前一亮！","categories":[],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://vanessayaoyao.github.io/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"tomcat9中文乱码","slug":"tomcat-encoding","date":"2022-03-29T14:22:24.000Z","updated":"2022-04-02T09:10:03.468Z","comments":true,"path":"2022/03/29/tomcat-encoding/","link":"","permalink":"https://vanessayaoyao.github.io/2022/03/29/tomcat-encoding/","excerpt":"","text":"HTML页面一直乱码，很搞心态啊，明明up主没乱码，到我这就乱码了，如封面一样。tomcat10也没乱码，9就乱码。我一开始打算干脆一句中文不写，我全写英文，我看你还怎么乱码。但是到后面我看视频看得烦了，改前端页面改的人麻了，不想跟着一句一句写了。我就直接下载了源码，想着跑起来就行了吧，但中文全是乱码的，把中文改成英文也挺烦的。可见，有些bug不改不行啊。 成功操作在诸多尝试后，我发现只要一句话就能解决我的问题。 编辑tomcat启动项，在Environment Variables加上 Name Value JAVA_OPTS -Dfile.encoding=UTF-8 其实不用红框的那句，只有上一句就可以。重要的是一定要先点Apply，再点OK. 未起作用尝试下面的这些操作可以一试，只是并没有解决我的问题。 Thymeleaf这地方还是要写的 123456789//我们需要使用ThymeleafViewResolver作为视图解析器，并解析我们的HTML页面@Beanpublic ThymeleafViewResolver thymeleafViewResolver(@Autowired SpringTemplateEngine springTemplateEngine)&#123; ThymeleafViewResolver resolver = new ThymeleafViewResolver(); resolver.setOrder(1); resolver.setCharacterEncoding(&quot;UTF-8&quot;); resolver.setTemplateEngine(springTemplateEngine); return resolver;&#125; Spring Security这里也要写，要不然传进数据库里乱码 12345@Overrideprotected void beforeSpringSecurityFilterChain(ServletContext servletContext) &#123; servletContext.addFilter(&quot;characterEncodingFilter&quot;, new CharacterEncodingFilter(&quot;UTF-8&quot;, true)) .addMappingForUrlPatterns(null, false, &quot;/*&quot;);&#125; server.xml12345&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;connectionTimeout=&quot;20000&quot;redirectPort=&quot;8443&quot; URIEncoding=&quot;UTF-8&quot; /&gt;&lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; URIEncoding=&quot;UTF-8&quot;/&gt; catalina.bat12set &quot;JAVA_OPTS=%JAVA_OPTS% %JSSE_OPTS%&quot;-Dfile.encoding=UTF8 -Dsun.jnu.encoding=UTF8 按说这个应该成功的，和上面改的一样，但是并没有成功。 web.xml1234567891011121314151617&lt;servlet&gt;&lt;servlet-name&gt;default&lt;/servlet-name&gt;&lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt;&lt;init-param&gt;&lt;param-name&gt;debug&lt;/param-name&gt;&lt;param-value&gt;0&lt;/param-value&gt;&lt;/init-param&gt;&lt;init-param&gt;&lt;param-name&gt;fileEncoding&lt;/param-name&gt;&lt;param-value&gt;UTF-8&lt;/param-value&gt;&lt;/init-param&gt;&lt;init-param&gt;&lt;param-name&gt;listings&lt;/param-name&gt;&lt;param-value&gt;false&lt;/param-value&gt;&lt;/init-param&gt;&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; 回馈反思maybe 我要去学习整理一下编码方式,ascii,unicode,utf-8….啥的。 flag~","categories":[{"name":"Bug调试","slug":"Bug调试","permalink":"https://vanessayaoyao.github.io/categories/Bug%E8%B0%83%E8%AF%95/"}],"tags":[]},{"title":"IoC和AOP","slug":"AOP","date":"2022-03-25T02:18:30.000Z","updated":"2022-03-26T13:54:58.117Z","comments":true,"path":"2022/03/25/AOP/","link":"","permalink":"https://vanessayaoyao.github.io/2022/03/25/AOP/","excerpt":"","text":"Spring为了简化开发而生，它是轻量级的IoC和AOP的容器框架，主要是针对JavaBean的生命周期进行管理的轻量级容器，并且它的生态已经发展得极为庞大。 JavaBean和普通类差不多，它的所有属性都是private，所有的属性都可以通过get/set方法进行访问，同时还需要有一个无参构造（默认就有）。 IoC控制反转在采用面向对象方法设计的软件系统中，它的底层实现都是由N个对象组成的，所有的对象通过彼此的合作，最终实现系统的业务逻辑。对象之间耦合度过高的系统，必然会出现牵一发而动全身的情形。 IoC（Inverse of Control:控制反转） 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。 将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。 在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置太繁琐，于是SpringBoot 注解配置就慢慢开始流行起来。 IoC和DIIoC是一种设计思想或者说是某种模式。IoC 最常见以及最合理的实现方式叫做依赖注入（Dependency Injection，简称 DI）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递(注入)给它。 每个文本输入框有一个文本检查器，每次初始化一个文本选择框都需要一个检查器。 123456789101112public class TextInput &#123; private SpellCheck spellCheck; public TextInput() &#123; spellCheck=new SpellCheck(); &#125;&#125;public class TextInput &#123; private SpellCheck spellCheck; public TextInput(SpellCheck spellCheck) &#123; this.spellCheck=spellCheck; &#125;&#125; 观察以上两段不同的代码我们可以发现他们本质的区别是 SpellCheck对象创建的时间以及地点不同，在后面代码中文本检查器作为一个文本框的构造方法中的一个形参传入文本框内部。即可以了解为将spellCheck对象注入TextInput类。通过这个例子大概就可以了解上面提出的问题，什么是依赖，什么是注入了吧，文本框依赖检查器 ，将依赖的类作为形参放入依赖的类中就成为依赖注入。 AOP面向切面编程AOP(Aspect-Oriented Programming:面向切面编程)，又是一个听起来很高大上的名词，AOP思想实际上就是：在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。也就是说，我们可以使用AOP来帮助我们在方法执行前或执行之后，做一些额外的操作，实际上，就是代理！ 我感觉和python中的装饰器有点像。。 通过AOP我们可以在保证原有业务不变的情况下，添加额外的动作，比如我们的某些方法执行完成之后，需要打印日志，那么这个时候，我们就可以使用AOP来帮助我们完成，它可以批量地为这些方法添加动作。可以说，它相当于将我们原有的方法，在不改变源代码的基础上进行了增强处理。 相当于我们的整个业务流程，被直接斩断，并在断掉的位置添加了一个额外的操作，再连接起来，也就是在一个切点位置插入内容。它的原理实际上就是通过动态代理机制实现的。不过Spring底层并不是使用的JDK提供的动态代理，而是使用的第三方库实现，它能够以父类的形式代理，而不是接口。 https://juejin.cn/post/6844904071657160717https://juejin.cn/post/6844903973715968007https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#spring-ioc-aop","categories":[{"name":"Web相关","slug":"Web相关","permalink":"https://vanessayaoyao.github.io/categories/Web%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"AOP Ioc","slug":"AOP-Ioc","permalink":"https://vanessayaoyao.github.io/tags/AOP-Ioc/"}]},{"title":"不是吧, 阿Sir","slug":"i-hate-gitee","date":"2022-03-24T12:39:01.000Z","updated":"2022-03-26T13:49:36.103Z","comments":true,"path":"2022/03/24/i-hate-gitee/","link":"","permalink":"https://vanessayaoyao.github.io/2022/03/24/i-hate-gitee/","excerpt":"","text":"我的图啊。。。额滴亲娘。。。 无语了。。。 最近日常 看框架，也不知道学进去了多少。算法也算没开始吧。自己现在真的是啥都不行啊，拿什么找工作啊！！！！ 最近发现两部脑洞大开的动画片，好看！ 《瑞克和莫蒂》 《希尔达》 2022/3/26更新 今天星期六，网页一组发了他们的播放器。。 无力吐槽。。放眼一看，全是bug。。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://vanessayaoyao.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[]},{"title":"查缺补漏之反射","slug":"reflection","date":"2022-03-23T00:59:47.000Z","updated":"2022-03-24T12:19:38.347Z","comments":true,"path":"2022/03/23/reflection/","link":"","permalink":"https://vanessayaoyao.github.io/2022/03/23/reflection/","excerpt":"","text":"感觉在mosh的那个课里没有说到反射。最近在看框架方面的视频，up主提到好几次反射，现在来看看吧。 什么是反射？反射 (Reflection) 是 Java 的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。 Java反射就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；并且能改变它的属性。 程序中一般的对象的类型都是在编译期就确定下来的，而 Java 反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。 反射的核心是 JVM 在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。 反射的主要用途我们知道反射机制允许程序在运行时取得任何一个已知名称的class的内部信息，包括包括其modifiers(修饰符)，fields(属性)，methods(方法)等，并可于运行时改变fields内容或调用methods。那么我们便可以更灵活的编写代码，代码可以在运行时装配，无需在组件之间进行源代码链接，降低代码的耦合度；还有动态代理的实现等等；但是需要注意的是反射使用不当会造成很高的资源消耗！ 反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 Bean），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射，运行时动态加载需要加载的对象。 反射的基本用法Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类： Field ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段； Method ：可以使用 invoke() 方法调用与 Method 对象关联的方法； Constructor ：可以用 Constructor 的 newInstance() 创建新的对象。 12345678910111213141516171819// 一个Person类package com.ys.reflex;public class Person &#123; //私有属性 private String name = &quot;Tom&quot;; //公有属性 public int age = 18; //构造方法 public Person() &#123; &#125; //私有方法 private void say()&#123; System.out.println(&quot;private say()...&quot;); &#125; //公有方法 public void work()&#123; System.out.println(&quot;public work()...&quot;); &#125;&#125; ①、得到 Class 的三种方式 123456789101112//1、通过对象调用 getClass() 方法来获取,通常应用在：比如你传过来一个 Object// 类型的对象，而我不知道你具体是什么类，用这种方法 Person p1 = new Person(); Class c1 = p1.getClass();//2、直接通过 类名.class 的方式得到,该方法最为安全可靠，程序性能更高// 这说明任何一个类都有一个隐含的静态成员变量 class Class c2 = Person.class;//3、通过 Class 对象的 forName() 静态方法来获取，用的最多，// 但可能抛出 ClassNotFoundException 异常 Class c3 = Class.forName(&quot;com.ys.reflex.Person&quot;); 需要注意的是：一个类在 JVM 中只会有一个 Class 实例，即我们对上面获取的 c1,c2,c3进行 equals 比较，发现都是true。 ②、通过 Class 类获取成员变量、成员方法、接口、超类、构造方法等 查阅 API 可以看到 Class 有很多方法： getName()：获得类的完整名字。 getFields()：获得类的public类型的属性。 getDeclaredFields()：获得类的所有属性。包括private 声明的和继承类 getMethods()：获得类的public类型的方法。 getDeclaredMethods()：获得类的所有方法。包括private 声明的和继承类 getMethod(String name, Class[] parameterTypes)：获得类的特定方法，name参数指定方法的名字，parameterTypes 参数指定方法的参数类型。 getConstructors()：获得类的public类型的构造方法。 getConstructor(Class[] parameterTypes)：获得类的特定构造方法，parameterTypes 参数指定构造方法的参数类型。 newInstance()：通过类的不带参数的构造方法创建这个类的一个对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//获得类完整的名字String className = c2.getName();System.out.println(className);//输出com.ys.reflex.Person//获得类的public类型的属性。Field[] fields = c2.getFields();for(Field field : fields)&#123; System.out.println(field.getName());//age&#125;//获得类的所有属性。包括私有的Field [] allFields = c2.getDeclaredFields();for(Field field : allFields)&#123; System.out.println(field.getName());//name age&#125;//获得类的public类型的方法。这里包括 Object 类的一些方法Method [] methods = c2.getMethods();for(Method method : methods)&#123; System.out.println(method.getName());//work waid equls toString hashCode等&#125;//获得类的所有方法。Method [] allMethods = c2.getDeclaredMethods();for(Method method : allMethods)&#123; System.out.println(method.getName());//work say&#125;//获得指定的属性Field f1 = c2.getField(&quot;age&quot;);System.out.println(f1);//获得指定的私有属性Field f2 = c2.getDeclaredField(&quot;name&quot;);//启用和禁用访问安全检查的开关，值为 true，则表示反射的对象在使用时应该取消 java 语言的访问检查；反之不取消f2.setAccessible(true);System.out.println(f2);//创建这个类的一个对象Object p2 = c2.newInstance();//将 p2 对象的 f2 属性赋值为 Bob，f2 属性即为 私有属性 namef2.set(p2,&quot;Bob&quot;);//使用反射机制可以打破封装性，导致了java对象的属性不安全。System.out.println(f2.get(p2)); //Bob//获取构造方法Constructor [] constructors = c2.getConstructors();for(Constructor constructor : constructors)&#123; System.out.println(constructor.toString());//public com.ys.reflex.Person()&#125; 反射机制与动态加载类 new创建对象的方式称作为静态加载，而使用Class.forName(“XXX”)称作为动态加载，它们俩本质的区别在于静态加载的类的源程序在编译时期加载（必须存在），而动态加载的类在编译时期可以缺席（源程序不必存在）。 123456789101112// 静态加载类 public class StaticClass &#123; public static void main(String[] args) &#123; if(&quot;teacher&quot;.equals(args[0])) &#123; Teacher t = new Teacher(); // 使用new关键字 t.getAvgAge(); &#125;else if(&quot;student&quot;.equals(args[0])) &#123; Student s = new Student(); s.getAvgAge(); &#125; &#125;&#125; 上面的代码中的前提是Teacher和Student还没有编译，此代码在javac的编译阶段就会报错。因为使用new关键字来实例对象时，此时就是静态加载类，编译时会查看类用到的所有类是否都可以找到。而此类在实际的生产环境中如果这样实现，不仅仅给内存提高了要求，也有了很多的限制。如果项目目前只需要Teacher就可以满足需求了，而迫于代码的原因，不得不把Student也实现了才可以使用。 程序代码中的工具类往往都会存在类似的问题，此时通过动态加载类的方式就可以很好的解决此问题：分别创建DynamicClass类、People接口类、Student类、Teacher类，其中Student和Teacher实现People接口，为了能够面向接口编程，减少依赖，降低耦合度。 12345678public class DynamicClass &#123; public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException &#123; Class ct = Class.forName(args[0]); //面向接口编程 People tea = (People) ct.newInstance(); tea.getAvgAge(); &#125;&#125; 通过使用动态类加载技术，在工具类中，不再需要进行大量的判断。通过输入的参数，动态加载需要使用的类即可，在获取类的实例化对象时，也不再向上转型为具体的实现类，而是面向接口，提高了应用的扩展性，在People的类别增加或者变化上，不需要修改工具类，均可以获得相应类别的平均年龄。 https://www.cnblogs.com/ysocean/p/6516248.html https://www.sczyh30.com/posts/Java/java-reflection-1/https://blog.csdn.net/itxiaohei323/article/details/87808306","categories":[{"name":"Java SE","slug":"Java-SE","permalink":"https://vanessayaoyao.github.io/categories/Java-SE/"}],"tags":[{"name":"reflection","slug":"reflection","permalink":"https://vanessayaoyao.github.io/tags/reflection/"}]},{"title":"二叉树的构建与遍历","slug":"binary-tree","date":"2022-03-16T01:16:42.000Z","updated":"2022-03-24T12:35:20.895Z","comments":true,"path":"2022/03/16/binary-tree/","link":"","permalink":"https://vanessayaoyao.github.io/2022/03/16/binary-tree/","excerpt":"","text":"二叉树的存储结构顺序存储结构 完全二叉树和满二叉树采用顺序存储比较合适。对于比较稀疏的二叉树，空间利用率较低。 链式存储结构 二叉链表至少包含3个域：数据域data，左指针域lchild，右指针域rchild。 123456789101112131415161718192021222324// 二叉树节点private static class TreeNode&#123; int data; TreeNode leftChild; TreeNode rightChild; public TreeNode(int data) &#123; this.data = data; &#125;&#125;//构建二叉树public static TreeNode createBinaryTree(LinkedList&lt;Integer&gt; inputList)&#123; TreeNode node = null; if (inputList == null || inputList.isEmpty())&#123; return null; &#125; Integer data = inputList.removeFirst(); if (data != null)&#123; node = new TreeNode(data); node.leftChild = createBinaryTree(inputList); node.rightChild = createBinaryTree(inputList); &#125; return node;&#125; 二叉树的构建方法有很多，这里把一个线性的链表转化成非线性的二叉树，链表节点的顺序恰恰是二叉树前序遍历的顺序。链表中的空值，代表二叉树节点的左孩子或右孩子为空的情况。 深度优先搜索深度优先搜索（DFS, depth-first search），它的思想是从一个顶点开始，沿着一条路一直走到底，如果发现不能到达目标解，那就返回到上一个节点，然后从另一条路开始走到底。 前序遍历输出顺序是：根节点、左子树、右子树。 123456789// 前序遍历public static void preOrderTraversal(TreeNode node)&#123; if (node == null)&#123; return; &#125; System.out.println(node.data); preOrderTraversal(node.leftChild); preOrderTraversal(node.rightChild);&#125; 中序遍历输出顺序是左子树、根节点、右子树。 123456789// 中序遍历public static void inOrderTraversal(TreeNode node)&#123; if (node == null)&#123; return; &#125; inOrderTraversal(node.leftChild); System.out.println(node.data); inOrderTraversal(node.rightChild);&#125; 后序遍历输出顺序是左子树、右子树、根节点。 123456789// 后序遍历public static void postOrderTraversal(TreeNode node)&#123; if (node == null)&#123; return; &#125; postOrderTraversal(node.leftChild); postOrderTraversal(node.rightChild); System.out.println(node.data);&#125; 测试 {3,2,9,null,null,10,null,null,8,null,4} 12345678910public static void main(String[] args) &#123; LinkedList&lt;Integer&gt; inputList = new LinkedList&lt;&gt;(Arrays.asList(new Integer[]&#123;3,2,9,null,null,10,null,null,8,null,4&#125;)); TreeNode treeNode = createBinaryTree(inputList); System.out.println(&quot;前序遍历&quot;); preOrderTraversal(treeNode); // 3，2，9，10，8，4 System.out.println(&quot;中序遍历&quot;); inOrderTraversal(treeNode); // 9，2，10，3，8，4 System.out.println(&quot;后序遍历&quot;); postOrderTraversal(treeNode); // 9，10，2，4，8，3&#125; 非递归遍历绝大多数可以用递归解决的问题，其实都可以用另一种数据结构来解决，这种数据结构就是栈 。因为递归和栈都有回溯的特性。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 非递归前序遍历public static void preOrderTraversalWithStack(TreeNode node)&#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while (node != null || !stack.isEmpty())&#123; // 迭代访问节点的左孩子，并入栈 while (node != null)&#123; System.out.println(node.data); stack.push(node); node = node.leftChild; &#125; // 如果节点没有左孩子，则弹出栈顶节点，访问节点右孩子 if (!stack.isEmpty())&#123; node = stack.pop(); node = node.rightChild; &#125; &#125;&#125;// 非递归中序遍历public static void inOrderTraversalWithStack(TreeNode node)&#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while(node != null || !stack.empty()) &#123; while (node != null) &#123; stack.push(node); node = node.leftChild; &#125; if(!stack.empty()) &#123; node = stack.pop(); System.out.println(node.data); node = node.rightChild; &#125; &#125;&#125;// 非递归后序遍历public static void postOrderTraversalWithStack(TreeNode node)&#123; Stack&lt;TreeNode&gt; stack1 = new Stack&lt;&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;&gt;(); int i = 1; while(node != null || !stack1.empty()) &#123; while (node != null) &#123; stack1.push(node); stack2.push(0); node = node.leftChild; &#125; while(!stack1.empty() &amp;&amp; stack2.peek() == i) &#123; stack2.pop(); System.out.println(stack1.pop().data); &#125; if(!stack1.empty()) &#123; stack2.pop(); stack2.push(1); node = stack1.peek(); node = node.rightChild; &#125; &#125;&#125; https://www.cnblogs.com/liuyang0/p/6271331.html 广度优先搜索广度优先搜索（BFS, breadth-first search），它的思想是从一个顶点开始，辐射状地优先遍历其周围较广的区域。 层序遍历层序遍历，顾名思义，就是二叉树按照从根节点到叶子节点的层次关系，一层一层横向遍历各个节点。 二叉树同一层次的节点之间是没有直接关联的。实现层序遍历，需要借助队列这种数据结构。 123456789101112131415// 二叉树层序遍历public static void levelOrderTraversal(TreeNode root)&#123; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty())&#123; TreeNode node = queue.poll(); System.out.println(node.data); if (node.leftChild != null)&#123; queue.offer(node.leftChild); &#125; if (node.rightChild != null)&#123; queue.offer(node.rightChild); &#125; &#125;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://vanessayaoyao.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"tree","slug":"tree","permalink":"https://vanessayaoyao.github.io/tags/tree/"}]},{"title":"哈希是什么神奇东东？","slug":"hash","date":"2022-03-12T12:17:12.000Z","updated":"2022-03-12T13:16:16.019Z","comments":true,"path":"2022/03/12/hash/","link":"","permalink":"https://vanessayaoyao.github.io/2022/03/12/hash/","excerpt":"","text":"最早听说哈希应该是哪位学长说过数据库密码要加密，最好是什么哈希加密。从此哈希一词就在我脑海中留下了高深莫测的印象。 什么是hash查查百度 Hash，一般翻译做散列、杂凑，或音译为哈希，是把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。 什么鬼。。能说点人话吗。。 刚才在看《漫画算法小灰的算法之旅》，突然感觉懂了，以下是正文。 再如我们需要统计一本英文书里某些单词出现的频率，就需要遍历整本书的内容，把这些单词出现的次数记录在内存中。因为这些需求，一个重要的数据结构诞生了，这个数据结构叫作散列表 。 散列表也叫作哈希表 （hash table），这种数据结构提供了键（Key） 和值（Value） 的映射关系。只要给出一个Key，就可以高效查找到它 所匹配的Value，时间复杂度接近于O(1) 。 以下是小灰（菜鸟）和大黄（大佬）的对话 那么，散列表是如何根据Key来快速找到它所匹配的Value呢？ 这就是我下面要讲的散列表的基本原理。 小灰，在咱们之前学过的几个数据结构中，谁的查询效率最高？ 当然是数组喽，数组可以根据下标，进行元素的随机访问。 说得没错，散列表在本质上也是一个数组。 可是数组只能根据下标，像a[0]、a[1]、 a[2]、a[3]、a[4]这样来访问，而散列表的Key则是以字符串类型为主的。 例如以学生的学号作为Key，输入 002123，查询到李四；或者以单词为Key，输入by，查询到数字 46…… 所以我们需要一个“中转站”，通过某 种方式，把Key和数组下标进行转换。这个中转站就叫作哈希函数。 这个所谓的哈希函数是怎么实现的呢？ 在不同的语言中，哈希函数的实现方式是不一样的。这里以Java的常用 集合HashMap为例，来看一看哈希函数在Java中的实现。 在Java及大多数面向对象的语言中，每一个对象都有属于自己的 hashcode，这个hashcode是区分不同对象的重要标识。无论对象自身的类型是什么，它们的hashcode都是一个整型变量。 既然都是整型变量，想要转化成数组的下标也就不难实现了。最简单的 转化方式是什么呢？是按照数组长度进行取模运算。 index = HashCode (Key) % Array.length 实际上，JDK（Java Development Kit，Java语言的软件开发工具包）中 的哈希函数并没有直接采用取模运算，而是利用了位运算的方式来优化 性能。不过在这里可以姑且简单理解成取模操作。 通过哈希函数，我们可以把字符串或其他类型的Key，转化成数组的下标index。 如给出一个长度为8的数组，则当key=001121时，index = HashCode (“001121”) % Array.length = 1420036703 % 8 = 7 而当key=this时， index = HashCode (“this”) % Array.length = 3559070 % 8 = 6 它其实就是一个算法，最简单的算法就是加减乘除，比方，我设计个数字算法，输入+7=输出，比如我输入1，输出为8；输入2，输出为9。 哈希算法不过是一个更为复杂的运算，它的输入可以是字符串，可以是数据，可以是任何文件，经过哈希运算后，变成一个固定长度的输出，该输出就是哈希值。但是哈希算法有一个很大的特点，就是你不能从结果推算出输入,所以又称为不可逆的算法。 常见 Hash 算法有 MD5 和 SHA 系列，目前 MD5 和 SHA1 已经被破解，一般推荐至少使用 SHA2-256 算法。 哈希特性 不可逆：在具备编码功能的同时，哈希算法也作为一种加密算法存在。即，你无法通过分析哈希值计算出源文件的样子，换句话说：你不可能通过观察香肠的纹理推测出猪原来的样子。 计算极快：20G高清电影和一个5K文本文件复杂度相同，计算量都极小，可以在0.1秒内得出结果。也就是说，不管猪有多肥，骨头多硬，做成香肠都只要眨眨眼的时间。 哈希的用途哈希算法的不可逆特性使其在以下领域使用广泛： 1、密码，我们日常使用的各种电子密码本质上都是基于hash的，你不用担心支付宝的工作人员会把你的密码泄漏给第三方，因为你的登录密码是先经过 hash+各种复杂算法得出密文后 再存进支付宝的数据库里的。 2、文件完整性校验，通过对文件进行hash，得出一段hash值 ，这样文件内容以后被修改了，hash值就会变。 MD5 Hash算法的”数字指纹”特性，使它成为应用最广泛的一种文件完整性校验和(Checksum)算法，不少Unix系统有提供计算md5 checksum的命令。 3、数字签名，数字签名技术是将摘要信息用发送者的私钥加密，与原文一起传送给接收者。接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与解密的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。 此外，hash算法在区块链领域也使用广泛。 基于hash的数据结构有哪些？python中有字典dict和集合set","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://vanessayaoyao.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"data structures","slug":"data-structures","permalink":"https://vanessayaoyao.github.io/tags/data-structures/"}]},{"title":"Python中的装饰器","slug":"decorator","date":"2022-03-02T13:02:03.000Z","updated":"2022-03-24T12:28:01.830Z","comments":true,"path":"2022/03/02/decorator/","link":"","permalink":"https://vanessayaoyao.github.io/2022/03/02/decorator/","excerpt":"","text":"Python中的装饰器 (Decorator)无参数无返回值12345678910111213141516171819202122import time# 判断是否为质数def is_prime(num): if num &lt; 2: return False elif num == 2: return True else: for i in range(2, num): if num % i == 0: return False return True# 输出1-10000的质数，并输出运行时间def prime_nums(): t1 = time.time() for i in range(2, 10000): if is_prime(i): print(i) t2 = time.time() print(t2 - t1)# 计时与逻辑并存，可读性低prime_nums() 123456789101112131415def display_time(func): # 函数套函数 def wrapper(): t1 = time.time() func() # 函数放这 t2 = time.time() print(t2 - t1) return wrapper@display_timedef prime_nums(): for i in range(2, 10000): if is_prime(i): print(i)prime_nums() # 这时运行prime_nums()，实际运行的是display_time 有返回值12345678910@display_timedef count_prime_nums(): count = 0 for i in range(2, 10000): if is_prime(i): count += 1 return count# 不修改装饰器的话count = count_prime_nums()print(count) # 返回值为None 12345678def display_time(func): def wrapper(): t1 = time.time() result = func() # 接收返回值 t2 = time.time() print(&quot;Total time: &#123;:.4&#125; s&quot;.format(t2 - t1)) return result # 返回该值 return wrapper 有参数12345678910111213141516171819def display_time(func): def wrapper(*args): # *args代表有参数，不知道几个，有几个你给我传几个 t1 = time.time() result = func(*args) # 这里同样是 *args t2 = time.time() print(&quot;Total time: &#123;:.4&#125; s&quot;.format(t2 - t1)) return result return wrapper @display_timedef count_prime_nums(maxnum): count = 0 for i in range(1, maxnum): if is_prime(i): count = count + 1 return count count = count_prime_nums(10000)print(count) Java 中的注解 (Annotation) 看到那个@就感觉挺像的。一快看看吧。 注解可以被标注在任意地方，包括方法上、类名上、参数上、成员属性上、注解定义上等，就像注释一样，它相当于我们对某样东西的一个标记。而与注释不同的是，注解可以通过反射在运行时获取，注解也可以选择是否保留到运行时。 额。。反射。。又是不会的东西。。基础不牢，地动山摇。暂时没有迫切想要了解的心，一时半会也用不到，就先这样吧。","categories":[{"name":"Web相关","slug":"Web相关","permalink":"https://vanessayaoyao.github.io/categories/Web%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"decorator","slug":"decorator","permalink":"https://vanessayaoyao.github.io/tags/decorator/"}]},{"title":"什么是跨域？","slug":"cross-domain","date":"2022-02-28T08:05:10.000Z","updated":"2022-03-01T05:00:06.288Z","comments":true,"path":"2022/02/28/cross-domain/","link":"","permalink":"https://vanessayaoyao.github.io/2022/02/28/cross-domain/","excerpt":"","text":"什么是跨域？ 跨域请求这个词听说过，但是我其实并没有真正了解过，也没有遇到过。因为出bug不是出在我这边😂，可以的话还是去学学vue吧。之前和web组合作的时候，跨域也是前端去解决的。现在社团新学期项目也开始了，昨天开会的时候，提到这个跨域问题，说是让后端解决。我也来学学吧。 跨域：指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对javascript施加的安全限制。 浏览器的同源策略同源策略：是指协议，域名，端口都要相同，其中有一个不同都会产生跨域。同源策略是为了保证用户信息的安全，防止恶意的网站窃取数据。浏览器中的大部分内容都是受同源策略限制的，但对于像 img、iframe、script 等标签的 src 属性是特例，它们是可以访问非同源网站的资源的。 现在想想后端算一个项目，前端算一个项目，分两拨人写肯定不是协议域名端口都相同。后端先部署一部分接口在服务器上，vue在本地127.0.0.1上去调接口肯定是跨域了。就算是只有一个人去写前后端分离的项目，前端工程和后端工程都在127.0.0.1下，两个项目端口号肯定不能一样，这样也是跨域了。 如何解决跨域问题？CORS跨域资源分享CORS是跨域资源分享的缩写，能够彻底解决Ajax的跨域问题，同时允许任意类型的请求。需要服务器响应头中增加下面一种或几种 1234567891011//*表示允许任意源的访问，也可以指定特定的源1.Access-Control-Allow-Origin：* //表示跨域访问时带上cookie，需同时在ajax请求中设置`withCredentials: true`，2.Access-Control-Allow-Credentials: true//预检请求后响应的必须字段，返回所有支持的方法，而不单是浏览器请求的那个方//法。这是为了避免多次&quot;预检&quot;请求3.Access-Control-Allow-Methods: GET, POST, PUT//预检请求后响应的必须字段，放入预检请求时请求所带的头4.Access-Control-Allow-Headers：Content-Type//允许浏览器在指定时间内，无需再发送预检请求进行协商，直接用本次协商结果即可5.Access-Control-Max-Age: 1728000 当一个资源(origin)通过脚本向另一个资源(host)发起请求，而被请求的资源(host)和请求源(origin)是不同的源时(协议、域名、端口不全部相同)，浏览器就会发起一个 跨域 HTTP 请求，并且浏览器会自动将当前资源的域添加在请求头中一个叫 Origin 的 Header 中。通过在响应报文中设置额外的 HTTP 响应头来告诉浏览器，运行在某个 origin 上的 Web 应用被准许访问来自不同源服务器上的资源，此时浏览器就不会将该响应拦截掉了。 CORS请求分为简单请求(HEAD、GET、POST)和非简单请求(PUT或DELETE或Content-Type为application) 非简单请求会向发一个预检请求(preflight)，请求类型为OPTION，收到预检请求的响应后再发送真正的请求，这个时候的请求与简单请求无异。 简单地说下CORS请求会携带的头信息 123456//必要请求头，表示当前源，相应的预检响应需要返回Access-Control-Allow-Origin1.Origin//预检时会带上的头，表示真正请求的方法，相应的预检响应需要返回Access-Control-Allow-Method2.Access-Control-Request-Method//预检时会带上的头，表示真正请求会额外发送的头信息，相应的预检响应需要返回Access-Control-Allow-Headers3.Access-Control-Request-Headers 怎样实现CORS通过JSONP只支持GET 前端去搞的 利用反向代理服务器如果是服务器向服务器请求就无需遵循同源策略。 所以通过反向代理服务器可以有效的解决跨域问题，代理服务器需要做以下几个步骤： 1.接受客户端的请求 2.将请求转发给实际的服务器 3.将服务器的响应结果返回给客户端 Nginx就是类似的反向代理服务器，可以通过配置Nginx代理来解决跨域问题。 nginx不太熟，只配置过。抽空学学。 服务端支持CORS, 以Django为例最安全的还是服务端来设置允许哪些来源的请求，即服务端在接收到请求之后，对允许的请求源设置Access-Control-Allow-Origin 的响应头。 1pip install django-cors-headers settings.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344INSTALLED_APPS = [ ... &#x27;corsheaders&#x27;， ... ] MIDDLEWARE = [ &#x27;django.middleware.security.SecurityMiddleware&#x27;, &#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;, &#x27;corsheaders.middleware.CorsMiddleware&#x27;, #注意顺序，必须放在这儿 &#x27;django.middleware.common.CommonMiddleware&#x27;, ... ]# 跨域增加忽略CORS_ALLOW_CREDENTIALS = TrueCORS_ORIGIN_ALLOW_ALL = TrueCORS_ORIGIN_WHITELIST = ( &#x27;*&#x27;)CORS_ALLOW_METHODS = ( &#x27;DELETE&#x27;, &#x27;GET&#x27;, &#x27;OPTIONS&#x27;, &#x27;PATCH&#x27;, &#x27;POST&#x27;, &#x27;PUT&#x27;, &#x27;VIEW&#x27;,)CORS_ALLOW_HEADERS = ( &#x27;XMLHttpRequest&#x27;, &#x27;X_FILENAME&#x27;, &#x27;accept-encoding&#x27;, &#x27;authorization&#x27;, &#x27;content-type&#x27;, &#x27;dnt&#x27;, &#x27;origin&#x27;, &#x27;user-agent&#x27;, &#x27;x-csrftoken&#x27;, &#x27;x-requested-with&#x27;, &#x27;Pragma&#x27;,) 仍需继续学习! 参考链接： https://zhuanlan.zhihu.com/p/145837536 https://www.jianshu.com/p/f4fc1ce49956","categories":[{"name":"Web相关","slug":"Web相关","permalink":"https://vanessayaoyao.github.io/categories/Web%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"CROS","slug":"CROS","permalink":"https://vanessayaoyao.github.io/tags/CROS/"}]},{"title":"Data Structures & Algorithms Part 1-2","slug":"data-structures-algorithms-part1-2","date":"2022-02-11T07:19:31.000Z","updated":"2022-03-24T12:24:34.383Z","comments":true,"path":"2022/02/11/data-structures-algorithms-part1-2/","link":"","permalink":"https://vanessayaoyao.github.io/2022/02/11/data-structures-algorithms-part1-2/","excerpt":"","text":"救。。。快点学习。。。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://vanessayaoyao.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"data structures","slug":"data-structures","permalink":"https://vanessayaoyao.github.io/tags/data-structures/"}]},{"title":"Data Structures & Algorithms Part 1-1","slug":"data-structures-algorithms-part1","date":"2022-02-03T10:48:03.000Z","updated":"2022-03-24T12:27:56.057Z","comments":true,"path":"2022/02/03/data-structures-algorithms-part1/","link":"","permalink":"https://vanessayaoyao.github.io/2022/02/03/data-structures-algorithms-part1/","excerpt":"","text":"Data Structures and algorithms for beginners. Ace your coding interview. Watch this tutorial to learn all about Big O, arrays and linked lists! Big O NatationWe use Big O to describe the performance of an algorithm. scalable how much on an algorithm slows down as the input grows larger O(1)Constant time 12345public void log(int[] numbers)&#123; // O(1) System.out.println(numbers[0]); System.out.println(numbers[0]);&#125; O(n)linear 12345public void log(int[] numbers)&#123; // O(n) n-&gt;size of the input for (int i = 0; i &lt; numbers.length; i++) System.out.println(numbers[i]);&#125; O(n^2)quadratic 12345public void log(int[] numbers)&#123; for (int first : numbers) for (int second : numbers) System.out.println(first + &quot;, &quot; + second);&#125; O(log n)logarithmic Binary search 二分法 1 million items in an array, find the target item with a maximum of 19 comparisons O(2^n)exponential Space Complexitythe additional space that we should allocate relative to the size of the input 1234567public void greet(String[] names)&#123; // O(1) space for (int i = 0; i &lt; names.length; i++) System.out.println(&quot;Hi &quot; + names[i]); // O(n) space String[] copy = new String[names.length];&#125; Arraysstrored sequentially in memory Lookup O(1) Insert O(n) Delete O(n) Exercise: Building an Array1234567891011121314151617181920212223242526272829303132333435363738394041public class Array &#123; private int[] items; private int count; public Array(int length)&#123; items = new int[length]; &#125; public void insert(int item)&#123; // If the array is full, resize it if (items.length == count)&#123; // Create a new array (twice the size) int[] newItems = new int[count * 2]; // Copy all the existing items for (int i = 0; i &lt; count; i++) newItems[i] = items[i]; // Set &quot;items&quot; to this new array items = newItems; &#125; // Add the new item at the end items[count++] = item; &#125; public void removeAt(int index) &#123; // Validate the index if (index &lt; 0 || index &gt;= count) throw new IllegalStateException(); // Shift the items to the left to fill the hole for (int i = index; i &lt; count; i++) items[i] = items[i+1]; count--; &#125; public int indexOf(int item) &#123; // If we find it, return index. Otherwise, return -1 for (int i = 0;i &lt; count; i++) if (items[i] == item) return i; return -1; &#125; public void print()&#123; for (int i = 0; i &lt; count; i++) System.out.println(items[i]); &#125;&#125; Dynamic Arrays12345678910111213&#x2F;&#x2F; java has two implementations of dynamic arrays&#x2F;&#x2F; Vector: 100% - synchronized&#x2F;&#x2F; ArrayList: 50%ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();list.add(10);list.add(20);list.add(30);list.remove(0);list.indexOf(20);list.contains(1);list.size();list.toArray();System.out.println(list); Linked Lists链表 consistd of a group of nodes in sequence Lookup by value O(n) by index O(n) Insert At the end O(1) At the beginning O(1) In the middle O(n) delete From the beginning O(1) From the end O(n) 得找到倒数第二个结点 From the middle O(n) 1234567891011LinkedList list = new LinkedList();list.addLast(10);list.addLast(20);list.addLast(30);list.addFirst(&quot;hah&quot;);list.removeLast();list.contains(10);list.indexOf(10);list.size();Object[] array = list.toArray();System.out.println(Arrays.toString(array)); Exercise: Building a Linked List123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109import java.util.NoSuchElementException;public class LinkedList &#123; private class Node &#123; private int value; private Node next; public Node(int value) &#123; this.value = value; &#125; &#125; private Node first; private Node last; private int size; public void addLast(int item) &#123; Node node = new Node(item); if (isEmpty()) first = last = node; else &#123; last.next = node; last = node; &#125; size++; &#125; public void addFirst(int item) &#123; Node node = new Node(item); if (isEmpty()) first = last = node; else &#123; node.next = first; first = node; &#125; size++; &#125; public int indexOf(int item) &#123; int index = 0; Node current = first; while (current != null)&#123; if (current.value == item) return index; current = current.next; index++; &#125; return -1; &#125; public boolean contains(int item) &#123; return indexOf(item) != -1; &#125; public void removeFirst() &#123; if(isEmpty()) throw new NoSuchElementException(); if(first == last)&#123; first = last = null; size = 0; return; &#125; Node second = first.next; first.next = null; first = second; size--; &#125; public void removeLast() &#123; Node previous = getPrevious(last); if(isEmpty()) throw new NoSuchElementException(); if(first == last)&#123; first = last = null; size = 0; return; &#125; last = previous; last.next = null; size--; &#125; private Node getPrevious(Node node)&#123; Node current = first; while (current != null) &#123; if (current.next == node) return current; current = current.next; &#125; return null; &#125; public int size() &#123; return size; &#125; public int[] toArray() &#123; int[] array = new int[size]; Node current = first; int index = 0; while (current != null)&#123; array[index++] = current.value; current = current.next; &#125; return array; &#125; private boolean isEmpty() &#123; return first == null; &#125;&#125; Arrays vs Linked ListsSPACE Static arrays have a fixed size Dynamic arrays grow by 50-100% Linked lists don’t waste memory Use arrays if you know the number of items to store new ArrayList(100) Types of Linked Lists Your transcript or degree is not a reflection of your knowledge or capabilities. Exercise: Reversing a Linked List12345678910111213141516public void reverse()&#123; // [10 20 30] // p c n if (isEmpty()) return; Node previous = first; Node current = first.next; while (current != null)&#123; Node next = current.next; current.next = previous; previous = current; current = next; &#125; last = first; last.next = null; first = previous;&#125; Exercise: Kth Node form the EndFind the Kth node from the end of a linked list in one pass. 12345678910111213141516public int getKthFromTheEnd(int k)&#123; if (isEmpty()) throw new IllegalStateException(); Node a = first; Node b = first; for (int i = 0; i &lt; k - 1; i++) &#123; b = b.next; if (b == null) throw new IllegalArgumentException(); &#125; while (b != last)&#123; a = a.next; b = b.next; &#125; return a.value;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://vanessayaoyao.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"data structures","slug":"data-structures","permalink":"https://vanessayaoyao.github.io/tags/data-structures/"}]},{"title":"Java Part 3 - Advanced Topics","slug":"learning-java-3","date":"2022-01-21T15:52:29.000Z","updated":"2022-03-24T12:24:08.026Z","comments":true,"path":"2022/01/21/learning-java-3/","link":"","permalink":"https://vanessayaoyao.github.io/2022/01/21/learning-java-3/","excerpt":"","text":"Advanced Java FeaturesExceptionsthe stack trace in reverse order Types of Exceptions Checked eg.读取文件时,应该预测到文件不存在时怎么办 Unchecked or Runtime Exceptions NullPointerException 指针异常，传入空值 ArithmeticException 算术异常，除以0 IllegalArgumentException 传入非法参数 IndexOutofBoundsException 索引越界 IllegalStateException the underlying object is not in the right state Error an error external to our application 堆叠溢出 内存溢出 Exceptions Hierarchy Catching Exceptions12345678910public void show()&#123; try &#123; FileReader reader = new FileReader(&quot;file.txt&quot;); System.out.println(&quot;File opened&quot;); &#125;catch (FileNotFoundException ex)&#123; System.out.println(&quot;File does not exist.&quot;); System.out.println(ex.getMessage()); //file.txt (系统找不到指定的文件。) &#125;&#125; trick: alt+enter→Surround with try/catch Catching Multiple Types of Exceptions123456789101112try &#123; FileReader reader = new FileReader(&quot;file.txt&quot;); int value = reader.read();&#125;catch (FileNotFoundException e)&#123; System.out.println(e.getMessage());&#125;catch (IOException e)&#123; System.out.println(&quot;Could not read data.&quot;);&#125;try&#123; &#125;catch(IOException | ParseException e)&#123;&#125; The finally Block12345678910111213141516FileReader reader = null;try &#123; reader = new FileReader(&quot;file.txt&quot;); int value = reader.read();&#125;catch (IOException e)&#123; System.out.println(&quot;Could not read data.&quot;);&#125;finally &#123; //ugly if(reader!=null) &#123; try &#123; reader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; The try-with-resources Statement123456789try( FileReader reader = new FileReader(&quot;file.txt&quot;); ....//other object) &#123; int value = reader.read();&#125;catch (IOException e)&#123; System.out.println(&quot;Could not read data.&quot;);&#125;//与上面代码效果相同，不用写finally不用关文件.automatically Throwing Exceptions12345public void deposit(float value)&#123; if (value&lt;=0) throw new IllegalArgumentException(); //defensive programming&#125; 1234567891011public void deposit(float value) throws IOException&#123; if (value&lt;=0) throw new IOException();&#125;Account account = new Account();try &#123; account.deposit(1);&#125; catch (IOException e) &#123; e.printStackTrace();&#125; Re-throwing Exceptions1234567891011121314public static void main(String[] args) throws IOException &#123; Account account = new Account(); try &#123; account.deposit(1); &#125; catch (IOException e) &#123; System.out.println(&quot;Logging&quot;); throw e; &#125;&#125;try&#123; ...&#125; catch(Throwable e)&#123; System.out.println(&quot;error occcured.&quot;);&#125; Custom Exception自定义异常 12345678910111213141516//checked -&gt;Exception//unchecked(runtime) -&gt;RuntimeExceptionpublic class InsufficientFundsException extends Exception &#123; public InsufficientFundsException()&#123; System.out.println(&quot;Insufficient funds in your account&quot;); &#125; public InsufficientFundsException(String message)&#123; super(message); &#125;&#125;public void withdraw(float value) throws InsufficientFundsException &#123; if (value&gt;balance) throw new InsufficientFundsException();&#125; Chaining Exceptions12345678public void withdraw(float value) throws AccountException &#123; if (value&gt;balance)&#123; InsufficientFundsException fundsException = new InsufficientFundsException(); AccountException accountException = new AccountException(); accountException.initCause(fundsException); throw accountException; &#125;&#125; 1234567891011public class AccountException extends Exception&#123; public AccountException(Exception cause)&#123; super(cause); &#125;&#125;public void withdraw(float value) throws AccountException &#123; if (value&gt;balance)&#123; AccountException accountException = new AccountException(new InsufficientFundsException()); throw accountException; &#125;&#125; Generics泛型 1234public class List&#123; private Object[] items = new Objects[10]; //Object class is the parent of all reference types&#125; Generic Classes1234567891011121314public class GenericList&lt;T&gt; &#123; private T[] items = (T[]) new Object[10]; private int count; public void add(T item)&#123; items[count++] = item; &#125; public T get(int index)&#123; return items[index]; &#125;&#125;GenericList&lt;Integer&gt; list = new GenericList&lt;&gt;();list.add(1); Generics and Primitive Typesint -&gt; Integer float -&gt; Float boolean -&gt; Boolean 123GenericList&lt;Integer&gt; numbers = new GenericList&lt;&gt;();numbers.add(1); //Boxingint number = numbers.get(0); //Unboxing Constraints123456public class GenericList&lt;T extends Number&gt; &#123; // wrapper class of Interger Float Short...&#125;public class GenericList&lt;T extends Comparable &amp; Cloneable&gt; &#123; &#125; Type Erasure类型消除 Java compiler erases these type parameters and replaces them with a class or an interface depending on the constraints. The Comparable Interface12345678910111213141516public class User implements Comparable&lt;User&gt;&#123; private int points; public User(int points) &#123; this.points = points; &#125; @Override public int compareTo(User other) &#123; // this &lt; other -&gt; -1 // this == other -&gt; 0 // this &gt;other -&gt; 1 return points - other.points; &#125;&#125;user1.compareTo(user2) // &gt;&lt; 大于号小于号只能比较数字和字符 Generic Methods12345public class Utils &#123; public static &lt;T extends Comparable&lt;T&gt;&gt; T max(T first, T second)&#123; return (first.compareTo(second) &gt; 0) ? first : second; &#125;&#125; Multiple Type Paramaters123456789public class Utils &#123; public static &lt;K, V&gt; void print(K key, V value)&#123; System.out.println(key + &quot;=&quot; + value); &#125;&#125;public class KeyValuePair&lt;K, V&gt;&#123; private K key; private V value;&#125; Generic Classes and Inheritanceinstructor extends user printUsers GenericList&lt;Instructor&gt;不能调用printUsers Wildcards12345678// class CAP#1 extends User &#123;&#125;// class Instructor extends User &#123;&#125;public static void printUsers (GenericList&lt;? extends User&gt; users)&#123;//read // super add User x = users.get(0);&#125;Utils.printUsers(new GenericList&lt;Instructor&gt;()) CollectionsCollections Framework queue 队列 set无重复 The Iterables Interface we can iterate or loop over it. 123456public class GenericList&lt;T&gt; implements Iterable&lt;T&gt;&#123; @Override public Iterator&lt;T&gt; iterator() &#123; return null; //not finished yet &#125;&#125; 123456789GenericList&lt;String&gt; list = new GenericList&lt;&gt;();// Iterator iterator = list.iterator();// while(iterator.hasNext())&#123;// Object current = iterator.next();// System.out.println(current);// &#125;for(Object item: list) System.out.println(item);&#125; The Iterator Interface12345678910111213141516171819202122232425262728293031323334public class GenericList&lt;T&gt; implements Iterable&lt;T&gt;&#123; private T[] items = (T[]) new Object[10]; private int count; public void add(T item)&#123; items[count++] = item; &#125; public T get(int index)&#123; return items[index]; &#125; @Override public Iterator&lt;T&gt; iterator() &#123; return new ListIterator(this); &#125; private class ListIterator implements Iterator&lt;T&gt;&#123; private GenericList&lt;T&gt; list; private int index; public ListIterator(GenericList&lt;T&gt; list) &#123; this.list = list; &#125; @Override public boolean hasNext() &#123; return (index &lt; list.count); &#125; @Override public T next() &#123; return list.items[index++]; &#125; &#125;&#125; The Collection Interfaceadd() remove() contains() E–&gt; elements 1234567891011121314151617public class CollectionsDemo &#123; public static void show()&#123; Collection&lt;String&gt; collection = new ArrayList&lt;&gt;(); collection.add(&quot;a&quot;); collection.add(&quot;b&quot;); collection.add(&quot;c&quot;); //或者 Collections.addAll(collection, &quot;a&quot;,&quot;b&quot;,&quot;c&quot;); collection.remove(&quot;a&quot;); for(String item: collection) System.out.println(item); collection.clear(); collection.isEmpty();//true or false collection.contains(&quot;a&quot;);//true or false collection.toArray(new String[3]);//或者String[0] &#125;&#125; 1234Collection&lt;String&gt; other = new ArrayList&lt;&gt;();other.addAll(collection);collection == other; // falsecollection.equals(other); //true The List Interfacesequence 序列 index 123456789101112 List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;a&quot;);list.add(&quot;b&quot;);list.add(0,&quot;!&quot;);System.out.println(list); //[!,a,b]Collections.addAll(list,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);list.get(0);list.set(0,&quot;a+&quot;);list.remove(0);list.indexOf(&quot;a&quot;);//第一次出现的索引list.lastIndexof(&quot;a&quot;);list.subList(0,2);//[a,b] 原list不受影响 The Comparable Interfacehow to sort data 1234567891011121314151617public class Customer implements Comparable&lt;Customer&gt; &#123; private String name; public Customer(String name) &#123; this.name = name; &#125; @Override public int compareTo(Customer other) &#123; return name.compareTo(other.name); &#125; @Override public String toString() &#123; return name; &#125;&#125; 123456List&lt;Customer&gt; customers = new ArrayList&lt;&gt;();customers.add(new Customer(&quot;c&quot;));customers.add(new Customer(&quot;d&quot;));customers.add(new Customer(&quot;a&quot;));Collections.sort(customers);System.out.println(customers); //[a,c,d] The Comparator Interface12345678910111213public class EmailComparator implements Comparator&lt;Customer&gt; &#123; @Override public int compare(Customer o1, Customer o2) &#123; return o1.getEmail().compareTo(o2.getEmail()); &#125;&#125;List&lt;Customer&gt; customers = new ArrayList&lt;&gt;();customers.add(new Customer(&quot;c&quot;,&quot;e3&quot;));customers.add(new Customer(&quot;d&quot;,&quot;e2&quot;));customers.add(new Customer(&quot;a&quot;,&quot;e1&quot;));Collections.sort(customers, new EmailComparator());//[a,d,c]System.out.println(customers); The Queue Interfacecollection situation we want to process jobs based on the order we receive them 打印机 PriorityQueue ArrayDeque 123456789101112public static void main(String[] args) &#123; Queue&lt;String&gt; queue = new ArrayDeque&lt;&gt;(); queue.add(&quot;c&quot;); queue.add(&quot;a&quot;); queue.add(&quot;b&quot;); // queue.offer(&quot;d&quot;); // b-&gt;a-&gt;c String front = queue.peek(); System.out.println(front); // c queue.remove(); // c queue.poll(); // null&#125; The Set Interface唯一值 123456Set&lt;String&gt; set = new HashSet&lt;&gt;();set.add(&quot;sky&quot;);set.add(&quot;sky&quot;);set.add(&quot;is&quot;);set.add(&quot;bule&quot;);System.out.println(set); // [sky, bule, is] 去重 1234Collection&lt;String&gt; collection = new ArrayList&lt;&gt;();Collections.addAll(collection,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;);Set&lt;String&gt; set = new HashSet&lt;&gt;(collection);System.out.println(set); // [a,b] 12345678Set&lt;String&gt; set1 = new HashSet&lt;&gt;(Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;));Set&lt;String&gt; set2 = new HashSet&lt;&gt;(Arrays.asList(&quot;b&quot;,&quot;c&quot;,&quot;d&quot;));// Unionset1.addAll(set2); // set1 [a,b,c,d]//Intersectionset1.retainAll(set2); // [b,c]// Differenceset1.removeAll(set2); // [a] Hash TablesJava: Maps C#: Dictionary Python: Dictionary JavaScript: Objects The Map Interface123456789101112131415161718192021Customer c1 = new Customer(&quot;a&quot;, &quot;e1&quot;);Customer c2 = new Customer(&quot;b&quot;, &quot;e2&quot;);Map&lt;String, Customer&gt; map = new HashMap&lt;&gt;(); // not iterablemap.put(c1.getEmail(),c1);map.put(c2.getEmail(),c2);Customer customer = map.get(&quot;e1&quot;);System.out.println(customer); // a nullCustomer unknown = new Customer(&quot;Unknown&quot;,&quot;&quot;);map.getOrDefault(&quot;e10&quot;, unknown);Boolean exists = map.containsKey(&quot;e10&quot;);map.replace(&quot;e1&quot;, new Customer(&quot;a++&quot;,&quot;e1&quot;));for (String key: map.keySet())&#123; System.out.println(key);&#125;for (Map.Entry&lt;String, Customer&gt; key: map.entrySet())&#123; System.out.println(key); // e1=a e2=b // key.getValue()&#125;//map.values() Lambda Expressions and Functional InterfacesFunctional Interfaces An interface with a single abstract method 123456789101112131415161718public interface Printer &#123; void print(String message);&#125;public class ConsolePrinter implements Printer&#123; @Override public void print(String message) &#123; System.out.println(message); &#125;&#125;public class LambdasDemo &#123; public static void show()&#123; greet(new ConsolePrinter()); &#125; public static void greet(Printer printer)&#123; printer.print(&quot;Hello World&quot;); &#125;&#125; Anonymous Inner Class匿名内部类 12345678public static void show()&#123; greet(new Printer() &#123; @Override public void print(String message) &#123; System.out.println(message); &#125; &#125;);&#125; Lambda Expressions123456789public static void show()&#123; greet(( String message) -&gt;&#123; System.out.println(message); &#125;); // or in a more clear way greet(message -&gt; System.out.println(message));&#125;Printer printer = message -&gt; System.out.println(message); // an objectPrinter printer = new ConsolePrinter(); Variable Capture1234public static void show()&#123; String prefix = &quot;-&quot;; greet(message -&gt; System.out.println( prefix+message));&#125; Method References1234greet(message -&gt; System.out.println(message));//Class/Object::methodgreet(System.out::println);//equal 123456789101112public static void print(String message)&#123;&#125;public static void show()&#123; greet(message -&gt; print(message)); greet(LambdasDemo::print);&#125;public void print(String message)&#123;&#125;public static void show()&#123; LambdasDemo demo = new LambdasDemo(); greet(message -&gt; demo.print(message)); greet(demo::print);&#125; 12345public LambdasDemo(String message) &#123;&#125;public static void show()&#123; greet(message -&gt; new LambdasDemo(message)); greet(LambdasDemo::new);&#125; Build-in Functional Interfacesfour types of functional interfaces Consumer void consume(obj) Supplier obj supply() Function obj map(obj) Predicate bool test(condition) The Consumer Interface123456789public static void show()&#123; List&lt;Integer&gt; list = Arrays.asList(1,2,3); // Imperative Programming(for, if/else, switch/case) for(int item: list)&#123; System.out.println(item); &#125; //Declarative Programming list.forEach(System.out::println);&#125; Chaining Consumers1234567public static void show()&#123; List&lt;String&gt; list = Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;); Consumer&lt;String&gt; print = System.out::println; Consumer&lt;String&gt; printUpperCase = item -&gt; System.out.println(item.toUpperCase()); list.forEach(print.andThen(printUpperCase)); // a A b B c C&#125; The Supplier Interface12345public static void show()&#123; Supplier&lt;Double&gt; getRandom = Math::random; // () -&gt; Math.random(); double random = getRandom.get(); System.out.println(random);&#125; The Function Interface12345public static void show()&#123; Function&lt;String, Integer&gt; map = str -&gt; str.length(); int length = map.apply(&quot;Sky&quot;); System.out.println(length);&#125; Composing Function12345678910111213public static void show()&#123; // &quot;key: value&quot; // first: &quot;key=value&quot; // second: &quot;&#123;key=value&#125;&quot; Function&lt;String, String&gt; replaceColon = str -&gt; str.replace(&quot;:&quot;,&quot;=&quot;); Function&lt;String, String&gt; addBraces = str -&gt; &quot;&#123;&quot; + str + &quot;&#125;&quot;; //Declarative Programming String result = replaceColon .andThen(addBraces) .apply(&quot;key:value&quot;); result = addBraces.compose(replaceColon).apply(&quot;key:value&quot;); System.out.println(result);&#125; The Predicate Interface12345public static void show()&#123; Predicate&lt;String&gt; isLongerThan5 = str -&gt; str.length() &gt; 5; boolean result = isLongerThan5.test(&quot;sky&quot;); System.out.println(result);&#125; Combining Predicates123456public static void show()&#123; Predicate&lt;String&gt; hasLeftBrace = str -&gt; str.startsWith(&quot;&#123;&quot;); Predicate&lt;String&gt; hasRightBrace = str -&gt; str.endsWith(&quot;&#125;&quot;); // and() or() negate() Predicate&lt;String&gt; hasLeftAndRightBraces = hasLeftBrace.and(hasRightBrace); &#125; The BinaryOperator Interface12345public static void show()&#123; BinaryOperator&lt;Integer&gt; add = (a,b) -&gt;a+b; Function&lt;Integer,Integer&gt; square = a -&gt; a * a; int result = add.andThen(square).apply(1,2);&#125; The UniaryOperator Interface12345public static void show()&#123; UnaryOperator&lt;Integer&gt; square = n -&gt; n * n; UnaryOperator&lt;Integer&gt; increment = n -&gt; n + 1; int result = increment.andThen(square).apply(1);&#125; Streams To process a collection of data in a declarative way // functional programming Imperative vs Functional Programming Imperative Declarative How What SQL select * from movies where genre = 1 order by name A sream is a sequence of objects but it’s not like a collection it doesn’t store data. It’s just a way to get data out of a collection. 1234567// Imperative Programming howint count = 0;for(Movie movie : movies) if (movie.getLikes() &gt; 10) count++;// Declarative (Functional) Programming long count2 = movies.stream().filter(movie -&gt; movie.getLikes() &gt; 10).count(); Creating a Stream From collections Collection&lt;Integer&gt; x; From arrays var list = new ArrayList&lt;&gt;(); int [] numbers = {1,2,3}; Arrays.stream(numbers).forEach(n -&gt; System.out.println(n)) **From an arbitrary number of objects ** Stream.of(1,2,3,4) 123456public static void show()&#123; Stream stream = Stream.generate(()-&gt;Math.random()); //lazy evaluation stream.limit(3).forEach(n -&gt; System.out.println(n)); // terminates this streams&#125; Infinite/finite streams 1Stream.iterate(1, n -&gt; n+1).limit(10).forEach(n -&gt; System.out.println(n)); Mapping Elements map() flatMap() Stream&lt;List&lt;x&gt;&gt; -&gt; Stream&lt;x&gt; 12movies.stream().map(movie -&gt; movie.getTitle()) .forEach(name-&gt; System.out.println(name)); 123Stream stream = Stream.of(List.of(1,2,3),List.of(4,5,6));stream.forEach(list -&gt; System.out.println(list)); // [1,2,3] [4,5,6] stream.flatMap(list -&gt; list.stream()).forEach(n -&gt; System.out.println(n)); //1 2 3 4 5 6 Filtering Elements Intermediate Terminal map() filter() limit()/skip() sorted() distinct() peek() forEach() Reducers Slicing a Stream“a” “b” “c” limit(n) limit(2) a b skip(n) skip(2) c 1000 movies 10 movies per page 3rd page skip(20) = skip((page-1) * pageSize) limit(10) = limit(pageSize) takeWhile(predicate) takeWhile(m-&gt;m.getLikes() &lt;30) 遇到即停止 dropWhile(predicate) Sorting Streams12345movies.stream() .sorted((a,b) -&gt; a.getTitle().compareTo(b.getTitle())) .sorted(Comparator.comparing(m-&gt;m.getTitle()).reversed())//逆序 //Movie::getTitle .forEach(m-&gt;System.out.println(m)); Getting Distinct Elements1234movies.stream() .map(Movie::getLikes) .distinct() .forEach(System.out::println); Peeking Elements123456movies.stream() .filter(m-&gt;m.getLikes()&gt;10) .peek(m-&gt;System.out.println(&quot;filtered:&quot;+m.getTitle())) .map(Movie::getTitle) .peek(t-&gt;System.out.println(&quot;mapped:&quot;+t)) .forEach(System.out::println); Simple Reducers count(n) anyMatch(predicate) .anyMatch(m-&gt;m.getLikes()&gt;20) true or false allMatch(predicate) noneMatch(predicate) findFrist() return Optional&lt;Movie&gt; findAny() max(comparator) .max(Comparator.comparing(Movie::getLikes)).get() min(comparator) Reducing a Stream12345Optional&lt;Integer&gt; sum = movies.stream() .map(m-&gt;m.getLikes()) //[10,20,30] .reduce((a+b)-&gt;a+b); // [30,30] -&gt; [60] // .reduce(Integer::sum)sum.orElse(0); //60 Collectorscollect the result of a stream into data structure 1234567List&lt;Movie&gt; result = movies.stream() .filter(m-&gt;m.getLikes(&gt;10)) .collect(Collectors.toList()); //.toSet() //.toMap(Movie::getTitle, Movie::getLikes) &#123;b=20,c=30&#125; //.toMap(Movie::getTitle, Function.identity( )) //.summingInt(Movie::getLikes) //.summarizingInt(Movie::getLikes ) statistics 123movies.stream() .map(Movie::getTitle) .collect(Collectors.joining(&quot;,&quot;)); // a,b,c Grouping Elements123456789101112131415public enum Genre &#123; COMEDY, ACTION, THRILLER&#125;List&lt;Movie&gt; movies = Arrays.asList( new Movie(&quot;a&quot;,1, Genre.THRILLER ), new Movie(&quot;b&quot;,2, Genre.ACTION), new Movie(&quot;c&quot;,3, Genre.ACTION));Map&lt;Genre,List&lt;Movie&gt;&gt; result = movies.stream(). collect(Collectors.groupingBy(Movie::getGenre)); // (, Collectors.counting()) &#123;THRILLER=1, ACTION=2&#125;System.out.println(result);// &#123;ACTION=[com.company.streams.Movie@5b480cf9, com.company.streams.Movie@6f496d9f], THRILLER=[com.company.streams.Movie@723279cf]&#125; Partitioning Elements分区 12345Map&lt;Boolean, String&gt; result = movies.stream() .collect(Collectors.partitioningBy( movie -&gt; movie.getLikes()&gt;20, Collectors.mapping(Movie::getTitle, Collectors.joining(&quot;,&quot;)) )); // &#123;false=a, b, true=c&#125; Primitive Type Streams IntStream .rangeClosed(1,5) 1,2,3,4,5 .range(1,5) 1,2,3,4 LongStream DoubleStream Concurrency and Muti-threadingProcesses and Threads进程和线程 A process is an instance of a program or an applocation. When you launch an application like your code editor or music player, your operating system loads that application inside a process, so a process contains an image of the application code. It has some memory and a bunch of other resources. A thread is a sequence of instructions, actually that thing that executes your code Each process has at least one thread called the main thread. 1234System.out.println(Thread.activeCount()); // 2 One is the mian thread running the main method, the other is a background thread that runs the garbage collectorSystem.out.println(Runtime.getRuntime().availableProcessors());// 8 4核8线程 Starting a Thread123456public class DownloadFileTask implements Runnable&#123; @Override public void run() &#123; System.out.println(&quot;Downloading a file: &quot;+Thread.currentThread().getName()); &#125;&#125; 1234567public static void show()&#123; System.out.println(Thread.currentThread().getName()); Thread thread = new Thread(new DownloadFileTask()); thread.start();&#125;// main// Downloading a file: Thread-0 1234for(int i=0; i&lt;10;i++) &#123; Thread thread = new Thread(new DownloadFileTask()); thread.start();&#125; Downloading a file: Thread-2Downloading a file: Thread-3Downloading a file: Thread-0Downloading a file: Thread-1Downloading a file: Thread-4Downloading a file: Thread-5Downloading a file: Thread-6Downloading a file: Thread-7Downloading a file: Thread-9Downloading a file: Thread-8 at same time parallel Pausing a Thread123456789101112public class DownloadFileTask implements Runnable&#123; @Override public void run() &#123; System.out.println(&quot;Downloading a file: &quot;+Thread.currentThread().getName()); try &#123; Thread.sleep(5000); //暂停5秒 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;Download complete: &quot; + Thread.currentThread().getName()); &#125;&#125; Joining Threads下载完文件后，启动另一个线程来扫描下载文件的病毒。 123456789101112public static void show()&#123; System.out.println(Thread.currentThread().getName()); Thread thread = new Thread(new DownloadFileTask()); thread.start(); try &#123; thread.join(); //使用join tell the current thread to wait for the complection for another thread. &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;File is ready to be scanned.&quot;);&#125; Interrupting a Thread取消功能 1234567891011thread.interrupt();// 发送中断请求，不会强制中断public void run() &#123; System.out.println(&quot;Downloading a file: &quot;+Thread.currentThread().getName()); for(int i=0;i&lt;Integer.MAX_VALUE;i++)&#123; // 判断是否被中断 if(Thread.currentThread().isInterrupted()) return; System.out.println(&quot;Downloading byte &quot;+i); &#125; System.out.println(&quot;Download complete: &quot; + Thread.currentThread().getName());&#125; Concurrency IssuesIf multiple threads try to change the same data If changes are not visibe to other threads Thread-safe Code Race Conditions12345678910public class DownloadStatus &#123; private int totalBytes; public int getTotalBytes() &#123; return totalBytes; &#125; public void incrementTotalBytes()&#123; totalBytes++; // non-atomic operation &#125;&#125; 12345678910111213141516171819public static void show()&#123; DownloadStatus status = new DownloadStatus(); List&lt;Thread&gt; threads = new ArrayList&lt;&gt;(); // 十个下载任务 一个下载一万byte -&gt; 100_000 for(int i = 0; i&lt;10; i++)&#123; Thread thread = new Thread(new DownloadFileTask(status)); thread.start(); threads.add(thread); &#125; for (Thread thread : threads) &#123; try &#123; thread.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(status.getTotalBytes()); // but just 89384 会change &#125; Strategies for Thread Safety Confinement 约束 Immutability 不变 Synchronization 同步 lock wait for each other: deadlock Atomic objects 原子类 Partitioning Confinement每条Thread都有Status not modify a shared object 1234private DownloadStatus status;public DownloadFileTask() &#123; this.status = new DownloadStatus();&#125; 12345678910111213141516171819202122public static void show()&#123; List&lt;Thread&gt; threads = new ArrayList&lt;&gt;(); List&lt;DownloadFileTask&gt; tasks = new ArrayList&lt;&gt;(); for(int i = 0; i&lt;10; i++)&#123; DownloadFileTask task = new DownloadFileTask(); tasks.add(task); Thread thread = new Thread(task); thread.start(); threads.add(thread); &#125; for (Thread thread : threads) &#123; try &#123; thread.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; Optional&lt;Integer&gt; result = tasks.stream().map(t -&gt; t.getStatus().getTotalBytes()) .reduce(Integer::sum); System.out.println(result); //100_000 &#125; Locks12345678910111213141516public class DownloadStatus &#123; private int totalBytes; private Lock lock = new ReentrantLock(); public int getTotalBytes() &#123; return totalBytes; &#125; public void incrementTotalBytes()&#123; lock.lock(); //上锁 try&#123; totalBytes++; &#125;finally &#123; lock.unlock(); //解锁 &#125; &#125;&#125; The Synchronished Keyword1234567891011121314151617public class DownloadStatus &#123; private int totalBytes; private int totalFiles; private Object totalBytesLock = new Object(); private Object totalFilesLock = new Object(); public void incrementTotalBytes()&#123; synchronized (totalBytesLock) &#123; totalBytes++; &#125; &#125; public void incrementTotalFiles()&#123; // 也可以使用 synchronized modifier 但不建议 synchronized (totalFilesLock)&#123; // 也可以使用 this 但不建议 totalFiles++; &#125; &#125;&#125; The Volatile Keyword 1private volatile boolean isDone; //unstable read it form the main memory change will be immediately written to the main memory change is visible across threads Thread Signalling12345678910111213// while loopsynchronized(status)&#123; try&#123; status.wait(); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125;&#125;status.done();synchronized(status)&#123; status.notifyAll();&#125; Atomic Objects123456789private AtomicInteger totalBytes = new AtomicInteger();public int getTotalBytes() &#123; return totalBytes.get();&#125;public void incrementTotalBytes()&#123; synchronized (totalBytesLock) &#123; totalBytes.incrementAndGet(); //a++ &#125;&#125; compare and swap Adders123456789private LongAdder totalBytes = new LongAdder();public int getTotalBytes() &#123; return totalBytes.intValue(); // sum()&#125;public void incrementTotalBytes()&#123; synchronized (totalBytesLock) &#123; totalBytes.increment(); //a++ &#125;&#125; Synchronized Collections12345678910111213141516171819public static void shoe()&#123; Collection&lt;Integer&gt; collection = Collections.synchronizedCollection(new ArrayList&lt;&gt;()); Thread thread1 = new Thread(()-&gt;&#123; collection.addAll(Arrays.asList(1,2,3)); &#125;); Thread thread2 = new Thread(()-&gt;&#123; collection.addAll(Arrays.asList(4,5,6)); &#125;); thread1.start(); thread2.start(); // 存在竞争 try &#123; thread1.join(); thread2.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(collection);//[4,5,6,1,2,3]&#125; Concurrent Collections1Map&lt;Integer, String&gt; map = new ConcurrentHashMap&lt;&gt;(); The Executive FrameworkThread Manipulation Availability limited Cost Thread Pool -&gt; reuse Executors123456789101112public static void show()&#123; ExecutorService executor = Executors.newFixedThreadPool(2); // try for (int i = 0; i &lt; 10; i++ )&#123; executor.submit(() -&gt;&#123; System.out.println(Thread.currentThread().getName()); // pool-1-thread-2 pool-1-thread-1 ... &#125;); &#125; // finally executor.shutdown();&#125; Callables and Futures123456789public class LongTask &#123; public static void simulate()&#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 12345678910111213141516171819public static void show()&#123; ExecutorService executor = Executors.newFixedThreadPool(2); try &#123; Future&lt;Integer&gt; future = executor.submit(() -&gt; &#123; LongTask.simulate(); return 1; &#125;); System.out.println(&quot;Do more work&quot;); // immediately try &#123; Integer result = future.get(); System.out.println(result); // 3 sec later &#125; catch (InterruptedException | ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; finally &#123; executor.shutdown(); &#125;&#125; Asynchronous ProgrammingAsynchronous = Non-blocking Creating a Completable Futures12345678910public static void show()&#123; Supplier&lt;Integer&gt; task = ()-&gt; 1; CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(task); try &#123; Integer result = future.get(); System.out.println(result); // 1 &#125; catch (InterruptedException | ExecutionException e) &#123; e.printStackTrace(); &#125;&#125; Implementing an Asynchronous API1234567891011121314151617public class MailService &#123; public void send()&#123; LongTask.simulate(); System.out.println(&quot;Mail was sent.&quot;); // &#125; public CompletableFuture&lt;Void&gt; sendAsync()&#123; return CompletableFuture.runAsync(() -&gt; send()); &#125;&#125;MailService.send();print(&quot;Hello World&quot;);// 3秒后 &quot;Mail was sent.&quot; then &quot;Hello World&quot;MailService.send();print(&quot;Hello World&quot;);Thread.sleep(5000);// Immediately &quot;Hello World&quot; 3秒后 &quot;Mail was sent.&quot; Running Code on Completion12345678910111213public static void show()&#123; CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(()-&gt;1); future.thenRunAsync(() -&gt; &#123; System.out.println(Thread.currentThread().getName()); // ForkJoinPool.commonPool-worker-1 .theRun -&gt; main System.out.println(&quot;Done&quot;); &#125;); future.thenAccept(result -&gt; &#123; System.out.println(Thread.currentThread().getName()); System.out.println(result); &#125;);&#125; Handing Exceptions1234567891011public static void show()&#123; CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(()-&gt;&#123; System.out.println(&quot;Getting the current weather&quot;); throw new IllegalStateException(); &#125;); try &#123; future.exceptionally(ex -&gt; 1).get(); &#125; catch (InterruptedException | ExecutionException e) &#123; e.printStackTrace(); &#125;&#125; Transforming Results12345public static void show()&#123; CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(()-&gt;20); future.thenApply(celsius -&gt; (celsius * 1.8) +32) .thenAccept(f -&gt; System.out.println(f));&#125; Composing Complete Futures12345public static void show()&#123; CompletableFuture.supplyAsync(() -&gt; &quot;email&quot;) .thenCompose(email -&gt; CompletableFuture.supplyAsync(() -&gt; &quot;playlist&quot;)) .thenAccept(playlist -&gt; System.out.println(playlist));&#125; Combining Completable Futures12345678910public static void show()&#123; CompletableFuture&lt;Integer&gt; first = CompletableFuture.supplyAsync(() -&gt; &quot;20USD&quot;) .thenApply(str-&gt;&#123; String price = str.replace(&quot;USD&quot;, &quot;&quot;); return Integer.parseInt(price); &#125;); CompletableFuture&lt;Double&gt; second = CompletableFuture.supplyAsync(() -&gt; 0.9); first.thenCombine(second, (price, exchangeRate) -&gt; price* exchangeRate) .thenAccept(result -&gt; System.out.println(result));&#125; Waiting for Many Tasks123456789101112131415161718public static void show()&#123; CompletableFuture&lt;Integer&gt; first = CompletableFuture.supplyAsync(() -&gt; 1 ); CompletableFuture&lt;Integer&gt; second = CompletableFuture.supplyAsync(() -&gt; 2); CompletableFuture&lt;Integer&gt; third = CompletableFuture.supplyAsync(() -&gt; 3); CompletableFuture&lt;Void&gt; all = CompletableFuture.allOf(first,second,third); all.thenRun(() -&gt; &#123; try &#123; Integer firstResult = first.get(); System.out.println(firstResult); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;All tasks completed successfully&quot;); &#125;);&#125; Waiting for the First Task123456789public static void show()&#123; CompletableFuture&lt;Integer&gt; first = CompletableFuture.supplyAsync(() -&gt;&#123; LongTask.simulate(); return 20; &#125;); CompletableFuture&lt;Integer&gt; second = CompletableFuture.supplyAsync(() -&gt; 20); CompletableFuture.anyOf(first,second) .thenAccept(temp -&gt; System.out.println(temp));&#125; Handing Timeoutsfuture.completeOnTimeout(1,1,TimeUnit.SECONDS) Project。。。 完结撒花，但是还远远没有结束。。。","categories":[{"name":"Java SE","slug":"Java-SE","permalink":"https://vanessayaoyao.github.io/categories/Java-SE/"}],"tags":[{"name":"java","slug":"java","permalink":"https://vanessayaoyao.github.io/tags/java/"}]},{"title":"git 入门","slug":"learn-git","date":"2022-01-07T08:35:36.000Z","updated":"2022-03-24T12:28:16.937Z","comments":true,"path":"2022/01/07/learn-git/","link":"","permalink":"https://vanessayaoyao.github.io/2022/01/07/learn-git/","excerpt":"","text":"虽然之前在GitHub传过几个项目，但那都是用Pycharm的插件传的，我对git可以说是只见其声不见其人，根本不会用。 Git is officially defined as a distributed version control system (VCS). 版本控制系统 Learn GitInitializing a repository12$ git initInitialized empty Git repository in D:/helloworld/OtherProjects/Snake/.git/ 我这里有一个用原生JavaScript写的贪吃蛇小游戏（比着人家的视频写的） Checking the status1234567891011$ git statusOn branch masterNo commits yetUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) game.js index.htmlnothing added to commit but untracked files present (use &quot;git add&quot; to track) Staging files1$ git add game.js index.html 或者 1$ git add . 再次查看状态 123456789$ git statusOn branch masterNo commits yetChanges to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) new file: game.js new file: index.html Making commits12345$ git commit -m &quot;this is my first commit&quot;[master (root-commit) 1637404] this is my first commit 2 files changed, 196 insertions(+) create mode 100644 game.js create mode 100644 index.html 123$ git statusOn branch masternothing to commit, working tree clean Commit history1234567$ git logcommit 1637404a766dad9bb1bc5c7995261131c688f747 (HEAD -&gt; master)Author: VanessaYaoyao &lt;929228571@qq.com&gt;Date: Fri Jan 7 17:00:11 2022 +0800 this is my first commit go back to a previous state of your project code that you committed, you can use the following command: 1$ git checkout &lt;commit-hash&gt; go back to the latest commit (the newest version of our project code), you can type this command: 1$ git checkout master Creating a new branch1$ git branch &lt;new-branch-name&gt; Changing branches1$ git checkout &lt;branch-name&gt; Learn GitHubCreating a new GitHub repository点击左上角头像旁边的加号 Pushing our code to the GitHub repository1234567891011$ git remote add origin https://github.com/VanessaYaoyao/JavaScript-Snake.git$ git push -u origin masterEnumerating objects: 4, done.Counting objects: 100% (4/4), done.Delta compression using up to 8 threadsCompressing objects: 100% (4/4), done.Writing objects: 100% (4/4), 2.15 KiB | 735.00 KiB/s, done.Total 4 (delta 0), reused 0 (delta 0), pack-reused 0To https://github.com/VanessaYaoyao/JavaScript-Snake.git * [new branch] master -&gt; masterBranch &#x27;master&#x27; set up to track remote branch &#x27;master&#x27; from &#x27;origin&#x27;. Making changes to the GitHub repository1$ git push origin master Cloning an existing GitHub repository1$ git clone &lt;github-repo-link&gt; 现在估计就够我用的了。其他的用法以后用到的时候在学。 附：GitHub Quick setup","categories":[{"name":"Web相关","slug":"Web相关","permalink":"https://vanessayaoyao.github.io/categories/Web%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"git","slug":"git","permalink":"https://vanessayaoyao.github.io/tags/git/"}]},{"title":"Java Part 2 - OOP","slug":"learning-java-2","date":"2021-12-28T04:54:53.000Z","updated":"2022-03-24T12:23:57.495Z","comments":true,"path":"2021/12/28/learning-java-2/","link":"","permalink":"https://vanessayaoyao.github.io/2021/12/28/learning-java-2/","excerpt":"","text":"Object-oriented ProgrammingUltimate Java Part 2 - Object-oriented Programming | Code with Mosh The four principles of object-oriented programming are: Encapsulation : bundling the data and operations on the data inside a single unit (class). Abstraction : reducing complexity by hiding unnecessary details (metaphor: the implementation detail of a remote control is hidden from us. We only work with its public interface.) Inheritance : a mechanism for reusing code. Polymorphism : a mechanism that allows an object to take many forms and behave differently. This will help us build extensible applications. Getting StartedProgramming Paradigms ways or styles of writing code 编程范式 Precedural Functional Object-oriented Event-driven Logic Aspect-oriented Problem Solving Process of defining a problem, identifying and comparing different solutions, and picking the one that best solves that problem with respect to the context and constraints. Depends on the problem, context and budget. Benefits of OOP Reduced Complexity Easier Maintenance Code Reuse Faster Development ClassesClass and ObjectClass: A blueprint for creating objects Object: An instance of a class. UML: unified modeling language 123456789101112package com.company;public class TextBox &#123; //设置初始值，不设置则为null, very dangerous public String text = &quot;&quot;; //Field public void setText(String text)&#123; this.text = text; &#125; public void clear()&#123; text = &quot;&quot;; &#125;&#125; 1234567public class Main &#123; public static void main(String[] args) &#123; TextBox textBox1 = new TextBox(); //jdk10以上可用var, like js textBox1.setText(&quot;Box 1&quot;); System.out.println(textBox1.text);//Box 1 &#125;&#125; Memory Allocation内存分配 heap:堆 stack:栈 1234TextBox textBox1 = new TextBox();TextBOx textBox2 = textBox1;textBox2.setText(&quot;Hello World&quot;);System.out.println(textBox1.text);//Hello World What is the difference between stack and heap memory? How are they managed? Stack is used for storing primitive types (numbers, boolean and character) and variables that store references to objects in the heap. Variables stored in the stack are immediately cleared when they go out of scope (eg when a method finishes execution). Objects stored in the heap get removed later on when they’re no longer references. This is done by Java’s garbage collector. Garbage collection: automatically remove unused objects on the heap. Encapsulation Bundle the data and methods that operate on the data in a single unit.封装 Procedural Programming过程化编程 spaghetti code What are the problems of procedural code? How does object-oriented programming help solve these problems? Big classes with several unrelated methods focusing on different concerns and responsibilities. These methods often have several parameters. You often see the same group of parameters repeated across these methods. All you see is procedures calling each other passing arguments around. By applying object-oriented programming techniques, we extract these repetitive parameters and declare them as fields in our classes. Our classes will then encapsulate both the data and the operations on the data (methods). As a result, our methods will have fewer parameters and our code will be cleaner and more reusable. 1234567public class Employee &#123; public int baseSalary; public int hourlyRate; public int calculateWage(int extraHours)&#123; return baseSalary + (hourlyRate*extraHours); &#125;&#125; 12345678910public class Main &#123; public static void main(String[] args) &#123; Employee employee = new Employee(); employee.baseSalary = 50_000; //如果输入一个负数呢? 可以在主函数里写if else,but it&#x27;s not good. employee.hourlyRate = 20; int wage = employee.calculateWage(10); System.out.println(wage); &#125;&#125; Getters and Setters Why should we declare fields as private? How we store data in an object is considered an implementation detail. We may change how we store the data internally. Plus, we don’t want our objects to go into a bad state (hold bad data). That’s why we should declare fields as private and provide getters and or setters only if required. These setters can ensure our objects don’t go into a bad state by validating the values that are passed to them. 1234567891011public class Employee &#123; private int baseSalary; public void setBaseSalary(int baseSalary)&#123; if (baseSalary&lt;=0) throw new IllegalArgumentException(&quot;can&#x27;t be 0 or less.&quot;); this.baseSalary = baseSalary; &#125; public int getBaseSalary()&#123; return baseSalary; &#125;&#125; A trick: ask intellij to do it for us. press Alt+Enter apply Abstraction Reduce complexity by hiding unnecessary details. 抽象 给你一个遥控器，我们只需要知道如何换台，不需要知道按钮之下的电路如何运作。 As a metaphor, think of the remote control of your TV. All the complexity inside the remote control is hidden from you. It’s abstracted away. You just work with a simple interface to control your TV. We want our objects to be like our remote controls. Coupling The level of dependency between classes. 耦合 The more our classes are dependent on each other, the harder it is to change them. Changing one class may result in several cascading and breaking changes. Reducing coupling 123456789101112131415public class Browser &#123; //其他类只调用navigate这个函数 public void navigate(String address)&#123; String ip = findIpAddress(address); String html = sendHttpRequest(ip); System.out.println(html); &#125; //其他函数隐藏，即private private String sendHttpRequest(String ip) &#123; return &quot;&lt;html&gt;&lt;/html&gt;&quot;; &#125; private String findIpAddress(String address) &#123; return &quot;127.0.0.1&quot;; &#125;&#125; How does the abstraction principle help reduce coupling? By hiding the implementation details, we prevent other classes from getting affected when we change these details. For example, if the logic board and transistors inside a remote control change from one model to another, we’re not affected. We still use the same interface to work with our TV. Also, reducing these details and exposing fewer methods makes our classes easier to use. For example, remote controls with fewer buttons are easier to use. Constructors Constructors are called when we instantiate our class. We use them to initialize our objects. Initialization means putting an object into an early or initial state (eg giving it initial values). 12345678910public class Employee &#123; private int baseSalary; private int hourlyRate; //构造器，没有返回类型，名字与类名一致 public Employee(int baseSalary, int hourlyRate)&#123; setBaseSalary(baseSalary); setHourlyRate(hourlyRate); &#125; ...&#125; if we don’t create a constructor, the java compiler will automatically create one for us(the default constructor). Method Overloading Method overloading means declaring a method with the same name but with different signatures. The number, type and order of its parameters will be different. creating different implementations of it with different parameters. trick: ctrl+D to duplicate 123456public int calculateWage(int extraHours)&#123; return baseSalary + (getHourlyRate() *extraHours);&#125;public int calculateWage()&#123; return calculateWage(0) ;&#125; be aware of it, but don’t overuse it. Constructor Overloading1234567public Employee(int baseSalary)&#123; this(baseSalary,0);&#125;public Employee(int baseSalary, int hourlyRate)&#123; setBaseSalary(baseSalary); setHourlyRate(hourlyRate);&#125; Static Members Static methods are accessible via classes, not objects. 1234567891011public class Employee()&#123; public static int numberOfEmployees; public static void printNumberOfEmployees&#123; //在里面调用其他函数，必须先创建实例 ... &#125; ...&#125;Employee.numberOfEmployees;//不用创实例，直接调用类System.out.print();//这就是调用的 static methodInteger.parseInt();//这也是 Refactoring to an Object-oriented Design重构代码 trick 1: ask intellij to refactor for us 鼠标点击函数名后，选择上方工具栏的Refactor→Refactor this→Move trick 2: ask intellij to generate something for us, such as a constructor 选择上方工具栏的Code→Genreate→Constructor 右击类名，find usages Inheritance 123456public class UIControl&#123; ...&#125;public class TextBox extends UIControl &#123; ...&#125; The Object Class12345TextBox box1 = new TextBox();TextBox box2 = new TextBox();System.out.println(box1.hashCode()); //356573597 relted to address//box1.equal(box2) false hashcode differentSystem.out.println(box1.toString()); //com,codewithmosh.TextBox@1540e19d package@hashcode(hexodecimal十六进制) Constructors and Inheritance12345678910111213//父类public UIcontrol(boolean isEnabled) &#123; this.isEnabled = isEnabled; System.out.println(&quot;UIControl&quot;);&#125;//子类public TextBox() &#123; super(true);//需要放在第一条 System.out.println(&quot;TextBox&quot;);&#125;TextBox box1 = new TextBox();//先输出UIControl后输出TextBox The super keyword is a reference to the base or parent class. We can use it to access the members (fields and methods) or call the constructors of the base class. In contrast, the this keyword returns a reference to the current object. Access Modifiers访问修饰符 public private protected How accessible is a field or method if it’s declared without an access modifier? If we omit the access modifier, the member will have the defaultaccess modifier which makes that member public in package. In otherwords, that member will be public in the package but private outside ofthe package. private fields and methods are not inherited by subclasses and they are not accessible outside of a class. protected: public in package and accessible by child classes in different packages hard to maintain the application Overriding MethodsMethod overriding means changing the implementation of an inherited method in a subclass. For example, we can override the equals() or hashCode() methods of the Object class. Method overloading means declaring a method with different signatures (different number, type and order of parameters). 1234@Override //an annotation telling java compilerpublic String toString()&#123; return text;&#125; What is the benefit of applying the @Override annotation when overriding a method? It signals the Java compiler that we’re overriding a method in the base class and this helps the compiler check our code for correctness. It will ensure the signature of the method in the subclass matches the on declared in the base class. Also, if we remove this method from the base class, the compiler will let us know and we can remove the method in the subclass as well. Upcasting and Downcasting123TextBox box = new TextBox();UIcontrol control = new UIcontrol(true);show(box1); //upcasting empty downcasting helloworld 12345678910public static void show(UIcontrol control)&#123; System.out.println(control);&#125;public static void show(UIcontrol control)&#123; if (control instanceof TextBox)&#123; var textBox = (TextBox)control; textBox.setText(&quot;Hello World&quot;); &#125; System.out.println(control);&#125; Comparing Objects1234var point1 = new Point(1,2);var point2 = new Point(1,2);point1 == point2 //falsepoint1.euqal(point2) //false 123456789@Overridepublic boolean equals(Object obj) &#123; if(this == obj) return true; if( !(obj instanceof Point)) return false; Point other = (Point)obj; return other.x == x &amp;&amp; other.y == y;&#125; trick: ask intellij to do it for us. PolymorphismEncapsulation Abstraction Inheritance Polymorphism 123456789101112//UIcontrolpublic void render()&#123;&#125; //empty//CheckBox@Overridepublic void render() &#123; System.out.println(&quot;render checkbox&quot;);&#125;//TextBox@Overridepublic void render() &#123; System.out.println(&quot;render textbox&quot;);&#125; 1234UIcontrol[] controls = &#123; new TextBox(), new CheckBox()&#125;;for( UIcontrol control:controls)&#123; control.render();&#125; Abstract Classes and Methods When do we use abstract classes? An abstract class is a partially-implemented (half-cooked) class. We cannot instantiate them. But we use them to share some common code across their subclasses. we cannot instantiate abstract class but only extend it. 123public abstract class UIcontrol &#123; public abstract void render();&#125; Class ‘CheckBox’ must either be declared abstract or implement abstract method ‘render()’ in ‘UIcontrol’. Can we have an abstract class without any abstract methods? Yes! An abstract class does not need abstract methods. But if we mark a method as abstract, we should mark the class as abstract as well. Final Classes and Methods When do we use final classes? Final classes cannot be inherited. We use them when we’ve made certain assumptions about a class and we want to prevent other classes extending our class and break those assumptions. we cannot extend final classes and we cannot override final methods. Deep Inheritance and HierarchiesDon’t create deep inheritance hierarchies. What is the diamond problem? The diamond problem happens in languages that support multiple inheritance. If two classes (B, C) derive from A and are also the parents of another class (D), we see a diamond. If the top class (A) declares a method (eg toString) and its children (B and C) override this method, it’s not clear which implementation will be inherited by D. Multiple Inheritancea class can have multiple parents Java does not support this feature. simple and robust. Interfaces We use interfaces to build loosely-coupled, extensible and testable applications. What is tightly-coupled code? Tightly-coupled code is code that is hard to change because there is a strong dependency between the entities (eg classes) in the code. Changing one class may result in several cascading, breaking changes in the code. Creating an Interface123public interface TaxCalculator &#123; double calculateTax();&#125; 123456789101112public class TaxCalculator2022 implements TaxCalculator&#123; private double taxableIncome; public TaxCalculator2022(double taxableIncome) &#123; this.taxableIncome = taxableIncome; &#125; @Override public double calculateTax()&#123; return taxableIncome * 0.3; &#125;&#125; Dependency Injection Dependency injection refers to passing or injecting dependencies of a class. Our classes should not instantiate their dependencies. 依赖注入 The separation of concerns: We need to separate creating an object and using it. Constructor Injection Setter Injection Method Injection Constructor Injection1234567public class TaxReport &#123; private TaxCalculator calculator; public TaxReport(TaxCalculator calculator)&#123; //only working with an interface this.calculator = calculator; &#125;&#125; progromming against interfaces 123456public class Main &#123; public static void main(String[] args) &#123; TaxCalculator2022 calculator2022 = new TaxCalculator2022(100_000); TaxReport report = new TaxReport(calculator2022); //pass or inject this calculator object &#125;&#125; dependency injection framework: pass these dependencies to our classes. Spring is one of the popular ones. Setter Injection123456public class TaxReport &#123; private TaxCalculator calculator; public void setCalculator(TaxCalculator calculator) &#123; this.calculator = calculator; &#125;&#125; 12345678910public class Main &#123; public static void main(String[] args) &#123; TaxCalculator2022 calculator2022 = new TaxCalculator2022(100_000); TaxReport report = new TaxReport(calculator2022); report.show(); //30000.0 report.setCalculator(new TaxCalculator2023()); report.show(); //0.0 &#125;&#125; Method Injection123456public class TaxReport &#123; public void show(TaxCalculator calculator)&#123; double tax = calculator.calculateTax(); System.out.println(tax); &#125;&#125; 1234TaxCalculator2022 calculator2022 = new TaxCalculator2022(100_000);TaxReport report = new TaxReport();report.show(calculator2022);report.show(new TaxCalculator2023()); Interface Segregation Principle The Interface Segregation Principle (ISP) suggests that we should segregate or divide big, fat interfaces into smaller ones, each focusing on a single responsibility or capability. Smaller interfaces are less likely to change. Changes to one capability, will only affect a single interface and fewer classes that depend on that interface. divide big interfaces into smaller ones UIWidget Deaggable Resizable A interface can have multiple parents Why shouldn’t we declare fields, static or private methods in interfaces? Fields, static and private methods are all about implementation. Interfaces are contracts and should not have any implementation. Interface and Abstract Classes What are the similarities and differences between interfaces and abstract classes? Both are abstract concepts and we cannot instantiate them. Interfaces are contracts and should only have method declarations. Abstract classes are partially-implemented classes. We use them to share some common code across their derivates. The new features in Java allow writing code and logic in interfaces but this is a bad practice and should be avoided. When to use Interfaces Should we extract an interface from every class? Why? Blindly extracting interfaces doesn’t solve any problems nor is it considered a best practice. If you extract an interface from every single class, you’ll end up with an explosion of interfaces that don’t necessarily add any values. You should use interfaces in situations where you want to decouple a class from its dependencies so you can swap these dependencies. This allows building applications that are extensible and testable","categories":[{"name":"Java SE","slug":"Java-SE","permalink":"https://vanessayaoyao.github.io/categories/Java-SE/"}],"tags":[{"name":"java","slug":"java","permalink":"https://vanessayaoyao.github.io/tags/java/"}]},{"title":"Java Part 1 - Fundamentals","slug":"learning-java","date":"2021-12-25T06:44:55.000Z","updated":"2022-03-24T12:23:47.939Z","comments":true,"path":"2021/12/25/learning-java/","link":"","permalink":"https://vanessayaoyao.github.io/2021/12/25/learning-java/","excerpt":"","text":"Java还是要学的。找工作就靠它了吧。 Fundamentals视频链接：Learning Java with Mosh Part One Anatomy of java program function 1234567891011ReturnType Name()&#123; ...&#125;void sendEmail()&#123; ...&#125;public class Main&#123; public void main()&#123; ... &#125;&#125; class: A container for related functions PascalNamingConvention→Classes camelNamingConvention→Methods How Java Code Gets Executed compilation→javac Main.class excution→java Mian Intellij hides that for us. TypesVariables primitive for storing simple values reference for storing complex objects 1234long viewsCount = 3_123_456_789L;float price = 10.99F;char letter = &#x27;A&#x27;;boolean isEligible = false; 1234567 byte x = 1; byte y = x;//改变x值y值不变Point point1 = new Point(1,1);Point point2 = point1;point1.x = 2;//point2的值也改变 Strings1234String message = &quot;Hello world&quot; + &quot;!!&quot;;message.length();//.出后看方法message.replace(&quot;target&quot;,&quot;replacement&quot;)message.trim()//去除前后空白（就像Python里的strip? In Java, Strings are immutable. return a new string Escape Sequences12345// Hello &quot;world&quot;String message = &quot;Hello \\&quot;world\\&quot;&quot;;// c:\\Windows\\..String message = &quot;c:\\\\windows\\\\..&quot;;//常用的还有\\n 和\\t Arrays1234567891011int[] numbers = new int[5];numbers[0] = 1;numbers[1] = 2;System.out.println(Arrays.toString(numbers));//[1,2,0,0,0]int[] numbers = &#123;2,3,4,1,4&#125;;System.out.println(numbers.length);//5Arrays.sort(numbers);System.out.println(Arrays.toString(numbers));//[1,2,3,4,4] In Java, arrays have a fixed size. Muti-dimensional Arrays123456int[][] numbers = new int[2][3];numbers[0][0]=1;System.out.println(Arrays.deepToString(numbers));//[[1, 0, 0], [0, 0, 0]]int[][] numbers = &#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;;//[[1, 2, 3], [4, 5, 6]] Constants1final float PI = 3.14F; Arithmetic Expressions1234567891011int result = 10/3;//3double result = (double)10/(double)3;//3.333333int x = 1;int y = x++;//x=2;y=1int x = 1;int y = ++x;//x=2,y=2x +=2; Casting1234567891011// Implicit casting// byte &gt; short &gt; int &gt; long &gt; float &gt; doubleshort x = 1;int y = x + 2;double x = 1.1;double y = x + 2;//2.0 // Explicit castingint y = (int)x + 2;String x = &quot;1&quot;;int y = Integer.parseInt(x) + 2; //3//Short.parseShort() Float.parseFloat()... The Math Class12345int result = Math.round(1.1F) //1int result = (int)Math.ceil(1.1F) //2int result = (int)Math.floor(1.1F) //1int result = Math.max(1,2) //2int result = (int)Math.round(Math.random()*100);//0-100随机数 Formatting Numbers123456NumberFormat currency = NumberFormat.getCurrencyInstance();String result = currency.format(1234567.891);//￥1,234,567.89NumberFormat percent = NumberFormat.getPercentInstance();String result = percent.format(0.1);//10% Reading Input123456789Scanner scanner = new Scanner(System.in);System.out.print(&quot;Age: &quot;);byte age = scanner.nextByte();//.nextFloat() .nextDouble()System.out.println(&quot;You are &quot;+age);String name = scanner.next();//Name: Vanessa Yao//You are Vanessa (空格后的词被丢失)String name = scanner.nextLine().trim();//You are Vanessa Yao Control FlowLogical Operators123456Scanner scanner = new Scanner(System.in);byte temperature = scanner.nextByte();boolean isWarm = (temperature &gt; 20) &amp;&amp; (temperature &lt; 30);// and(&amp;&amp;)第一个表达式为false时，java will ignore others.// or(||)第一个表达式为true时, java will ignore others.// not(!) If Statements12345678int temp &#x3D; 32;if(temp&gt;30)&#123; System.out.println(&quot;It&#39;s a hot day&quot;);&#125;else if(temp&gt;20)&#123;&#125;else&#123;&#125; simplifying if statement 12int income = 120_000;boolean hasHighIncome = (income &gt; 100_000); The Ternary Operator12int income = 120_000;String className = income &gt; 100_000 ? &quot;First&quot; : &quot;Economy&quot; Switch Statements1234567891011String role = &quot;admin&quot;;switch(role)&#123; case &quot;admin&quot;: System.out.println(&quot;You are an admin&quot;); break; case &quot;moderator&quot;: System.out.println(&quot;You are a moderator&quot;); break; default: System.out.println(&quot;You are a guest&quot;);&#125; For Loops123for(int i = 0; i&lt;5; i++)&#123; System.out.println(&quot;Hello world&quot;);&#125; While Loopsdon’t know how many times 1234567String input = &quot;&quot;;Scanner = scanner = new Scanner(System.in)while(!input.equals(&quot;quit&quot;))&#123; //不能用==，比较的是地址 System.out.print(&quot;Input: &quot;); input = scanner.next().toLowerCase(); System.out.println(input);&#125; Do…While Loopsat least once Break and Continue1234while(true)&#123; if(input.equals(&quot;quit&quot;)) break;&#125; For-Each Loop12345String[] fruits = &#123;&quot;Apple&quot;,&quot;Mango&quot;,&quot;Orange&quot;&#125;;for(String fruit : fruits)&#123; System.out.println(fruit);&#125;//只能从头到尾，not index 第一部分在油管上免费，讲的确实不错。第二部分和第三部分要收钱了。 哦吼，B站有人搬运，白嫖使我快乐。https://www.bilibili.com/video/BV19J411t7dD Object-oriented ProgrammingUltimate Java Part 2 - Object-oriented Programming | Code with Mosh Classes Refactoring Towards an Object-oriented Design Inheritance Interfaces Advanced TopicsUltimate Java Part 3: Advanced Topics | Code with Mosh Exceptions Generics泛型 Collections Lambda Expressions and Functional Interfaces Streams Concurrency and Multi-threading The Executive Framework","categories":[{"name":"Java SE","slug":"Java-SE","permalink":"https://vanessayaoyao.github.io/categories/Java-SE/"}],"tags":[{"name":"java","slug":"java","permalink":"https://vanessayaoyao.github.io/tags/java/"}]},{"title":"Ajax初识","slug":"ajax","date":"2021-12-23T04:33:25.000Z","updated":"2022-03-24T12:37:10.758Z","comments":true,"path":"2021/12/23/ajax/","link":"","permalink":"https://vanessayaoyao.github.io/2021/12/23/ajax/","excerpt":"","text":"是啥AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML） AJAX 是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 我理解的就是前端用AJAX来请求接口 实例 一个小例子，点击按钮获得3条动物信息。 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JSON and AJAX&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;header&gt; &lt;h1&gt;JSON and AJAX&lt;/h1&gt; &lt;button id=&#x27;btn&#x27;&gt;Fetch Info for 3 New Animals&lt;/button&gt; &lt;/header&gt; &lt;div id=&#x27;animal-info&#x27;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&#x27;main.js&#x27;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031var pageCounter = 1;var animalContainer = document.getElementById(&quot;animal-info&quot;)var btn = document.getElementById(&quot;btn&quot;);//监听事件，当btn被点击时调用该匿名函数btn.addEventListener(&quot;click&quot;, function()&#123; //新建对象 var ourRequest = new XMLHttpRequest(); //用GET请求URL ourRequest.open(&quot;GET&quot;,&quot;https://learnwebcode.github.io/json-example/animals-&quot;+pageCounter+&quot;.json&quot;) //onload意为全部加载完后 ourRequest.onload = function()&#123; //转为JSON对象 var ourData = JSON.parse(ourRequest.responseText) renderHTML(ourData); &#125;; ourRequest.send() pageCounter++; if (pageCounter&gt;3) &#123; btn.classList.add(&quot;hide-me&quot;);//这里是点击三次后隐藏按钮，但我这好像不太管用 &#125;&#125;)function renderHTML(data)&#123; var htmlString = &#x27;&#x27;; for(var i=0;i&lt;data.length;i++)&#123; //数据展示 htmlString += &quot;&lt;p&gt;&quot;+data[i].name+&quot; is a &quot;+data[i].species +&quot;.&lt;/p&gt;&quot; &#125; animalContainer.insertAdjacentHTML(&quot;beforeend&quot;,htmlString)&#125; 到这里还和我看到别人用的ajax不太一样。我看的用法好像是$ajax(…)什么什么的，这好像是jquary的用法？ 未完待续。 2021/12/29 更新 VanillaJS是史上最轻量跨平台前端框架 ，我们能够使用它构建强大的JS应用。从过去到以后他都是最轻量的框架。因为vanillaJS的广受欢迎，所有的浏览器都已经内置这个框架了！ jQuery也是一个框架。 Vanilla JS 1234567var r = new XMLHttpRequest();r.open(&quot;POST&quot;, &quot;path/to/api&quot;, true);r.onreadystatechange = function () &#123; if (r.readyState != 4 || r.status != 200) return; alert(&quot;Success: &quot; + r.responseText);&#125;;r.send(&quot;banana=yellow&quot;); jQuery 1234567891011&lt;script src=&quot;//ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;$.ajax(&#123; type: &#x27;POST&#x27;, url: &quot;path/to/api&quot;, data: &quot;banana=yellow&quot;, success: function (data) &#123; alert(&quot;Success: &quot; + data); &#125;,&#125;);&lt;/script&gt;","categories":[{"name":"Web相关","slug":"Web相关","permalink":"https://vanessayaoyao.github.io/categories/Web%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"https://vanessayaoyao.github.io/tags/Ajax/"}]},{"title":"Redis初识","slug":"meet-redis","date":"2021-12-18T05:30:10.000Z","updated":"2022-03-24T12:28:32.140Z","comments":true,"path":"2021/12/18/meet-redis/","link":"","permalink":"https://vanessayaoyao.github.io/2021/12/18/meet-redis/","excerpt":"","text":"程序部有一回课是讲缓存的，但那天我睡过头了没上成。就对redis不怎么了解，也没具体应用过。此事警醒我们不要睡过头！ 什么是Redis？Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 MySQL VS RedisMySQL是关系型数据库,主要用于存放持久化数据,将数据存储在硬盘中,读取速度较慢. Redis是NOSQL,即非关系型数据库,也是缓存数据库,即将数据存储在缓存中,缓存的读取速度快,能够大大的提高运行效率,但是保存时间有限. 缓存的必要网站访问的特点和现实世界的财富分配一样遵循二八定律：80% 的业务访问集中在20% 的数据上。既然大部分业务访问集中在一小部分数据上，那么如果把这一小部分数据缓存在内存中，就可以减少数据库的访问压力，提高整个网站的数据访问速度，改善数据库的写入性能了。 Redis 在django的使用下载首先要先下载Redis, 参考步骤：click this 1pip install django-redis redis 和 django-redis的区别，就像mysql和mysqlclient的区别。 我以前还以为下载django-redis就完事了呢，😓 settings.py里的配置复制一下github上官方文档的配置 123456789CACHES = &#123; &quot;default&quot;: &#123; &quot;BACKEND&quot;: &quot;django_redis.cache.RedisCache&quot;, &quot;LOCATION&quot;: &quot;redis://127.0.0.1:6379/1&quot;, &quot;OPTIONS&quot;: &#123; &quot;CLIENT_CLASS&quot;: &quot;django_redis.client.DefaultClient&quot;, &#125; &#125;&#125; 简单使用我有这么简简单单一张表 12345# models.pyclass Blog(models.Model): title = models.CharField(max_length=128) author = models.CharField(max_length=128) content = models.TextField() 我想实现：当用户访问一篇博客时，第一次访问从数据库里拿出来，放在缓存里。当用户再次访问时，不再进行数据库查询，使用缓存数据。 123456789101112131415161718192021#views.pyfrom django.core.cache import cachedef blog(request,id): dic = &#123;&#125; if request.method == &quot;GET&quot;: if cache.get(id): dic[&#x27;code&#x27;] = 200 dic[&#x27;msg&#x27;] = &quot;hit the cache&quot; dic[&#x27;data&#x27;] = BlogSerializer(cache.get(id)).data # cache.delete(id) else: dic[&#x27;code&#x27;] = 201 dic[&#x27;msg&#x27;] = &quot;hit the database&quot; blog = Blog.objects.get(id=id) cache.set(id, blog) #id为键，blog为值 dic[&#x27;data&#x27;] = BlogSerializer(blog).data else: dic[&#x27;code&#x27;] = 400 dic[&#x27;msg&#x27;] = &quot;wrong method&quot; return JsonResponse(dic) 第一次访问 再次访问 更多操作（如设置过期时间）可参考：django-redis","categories":[{"name":"Web相关","slug":"Web相关","permalink":"https://vanessayaoyao.github.io/categories/Web%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://vanessayaoyao.github.io/tags/redis/"}]},{"title":"英语、计算机与我","slug":"about-me","date":"2021-12-12T04:59:55.000Z","updated":"2022-03-24T12:35:53.628Z","comments":true,"path":"2021/12/12/about-me/","link":"","permalink":"https://vanessayaoyao.github.io/2021/12/12/about-me/","excerpt":"","text":"Thanks for your watching. Early Years我来自一个十八线小县城，上初中前没接触过英语，上大学前没接触过编程。 小学就在我们村里上的，上午上数学，下午上语文，体育课就是老师领着我们去操场上转两圈。没有英语课，更别说什么音乐课手工课的。对于小时候的我来说，日子过得平淡又快乐，没有什么糟心事，没有什么成绩排名，放学了就背着书包走着回家。这时还不知道能用双脚丈量的距离有多珍贵。可能偶尔烦恼就是，和我家在一个胡同的发小，她有好多好看的发卡，常常戴满了头发，而我没有，有时会嫉妒她哈哈。 上了初中就开始每周回一次家了，发小她之后对我说上了初中之后，她的童年就结束了，其实想想我也是。上小学的时候从来没有什么成绩排名，脑海里根本没有这个意识。上了初中就开始排名排名排名，但日子还算轻松。初一的时候认识的很多朋友，现在平时虽然不怎么联络，但在我心里她们已经是家人般的存在。下课的时候看看言情小说，和朋友打打闹闹，偶尔关心一下成绩排名，还早恋过，时间过得很快。有时会突然地恍惚，不知道现在是哪年哪月哪天，已经过去好久的事情仿佛就是昨天。 上了高中，曾经要好的朋友散落各地，也没有精力去结交新的朋友，我逐渐适应了一个人生活。一个人跑着去吃饭，很多时候都沉默寡言，没有话说，也没有什么表情。其实也没有什么很大的变化，我一直如此，懒得很，一个人的时间反而让我很自在。高中几乎都是学习了，学习学习学习，考上一个好大学。两周回家一次到最后一个月回家一次，一次在家的时间不超过二十四小时，一切照搬衡水中学的模式。 Why English忘记上高中的时候还是上初中的时候了，我有一段时间特别喜欢去校门口的书摊那买书，周一就把所有的零花钱就花光了。书摊上有许多三毛的书，我买来读过后，很是羡慕她。感觉三毛洒脱又自由，我也想这样。于是我就把北京十月出版社的三毛系列全买来读了一遍。三毛会好几种语言，西班牙语经常出现在她的书里，估计这就是我想读语言的由来吧，那时候一直给同学说我上大学要读西班牙语。现在这股读书的劲头早已消散，书买来也就是摆着。 恰巧高中的时候我英语的成绩还不错，一般考试成绩都在一百三以上，有次还上了一百四，不自觉便飘飘然，认为自己有学语言的天赋，自己就是学语言的天选之女，现在想想也是挺好笑的。那时候我还想着自己将来会去外交部，会穿着优雅知性的西装套裙站在国家领导人的背后，为他们翻译。谁还没有点梦想呢。哦不，是空想。在所有的课里，我最喜欢上的就是英语，感觉上的最轻松的也是英语，哪一次英语没有考好还会暗自神伤。但其实想想，我其实是被自己所营造的假象所欺骗了，我一直暗示自己，我的英语很好，我的英语很好，如此这般。 高考完后选专业，可想而知，我把所有学校的语言专业选了个遍，非语言专业不读。现在的我知道选语言专业不是一个好的决定，你所有的热情会被消磨殆尽，你会甚至讨厌英语，会不断怀疑自己。但对于当时的我来说，我也没有什么其他的选择，父母学识有限，给不了我很好的建议。所有的选择权都在我自己，其实完全是瞎选的，去知乎看了几篇帖子，草草地就结束了。我现在只能庆幸当时没有把北京第二外国语学院放在第一志愿，冲着海大985的名头选了海大。人呐，有时候还是要追名逐利一点的好（doge。 当时在知乎看了很多关于英语专业的问题，在B站也看了很多关于英语专业的视频分享，幻想着自己也能像他们这样，一口流利英语，结交各国好友，从此走上人生巅峰。但有个东西叫，幸存者偏差。我不自觉地忽视了一切不同的声音，只想看到自己看到的东西。哦对了，当时我还认为语言专业大三的时候都能出国交换的。那些出来分享的当然是过得还不错的，还有他们是北外或者上外的，沉默的大多数是没有话语权的。 进入大学，我给自己营造出的“我英语很好”的假象开始一点点瓦解。老师在专业课上指出我读音有问题；词汇量差的一批还不喜欢背单词；进入英表班，被非英语专业的同学吊打。人和人的差距真大呀。而且学英语的话还是要家境殷实一点的好，没有家庭支撑你想出去留学的话那等于胡闹。有钱啥时候都好啊，至少有选择的余地，有从头再来的底气。 英语当作兴趣那是极好的，但选英语专业我只能说是完全不必要的。英语这种专业啥样的大学都有，我不理解，除了北外上外的语言专业，其他学校的语言专业能不能不要开了。语言只是工具。没有其他技能的加持，真的很慌，真的没有底气。我一直很抵触说自己是英语专业的，感觉很难受或者说难为情。英语专业的英语不好哈哈。如果抱着当老师的想法那另当别论。至于我，我不想当老师，我当不好。 For Computer Science我和编程的起源，是我在大一下的时候选了一门课叫Python程序设计。那时候也不知道天高地厚，完全不知道Python是个什么东西，从来没接触过编程，但就是选了这门课。可以说这门课真的影响我很大吧。那时候还是疫情在家上网课，我就从什么都不会，不知道在哪输入字符。到慢慢有点思路，一耗两三个小时就是为了把一个练习题做出来。甚至还在班级群里回答其他同学的问题，虽然是用匿名。每成功一步都让我欣喜若狂、欢呼雀跃。这种心情是我上英语专业以来从未体会过的，真的从未体会到过。上了英语专业我就自动把自己归了底层一类，就忘记了自己也曾想当一个闪闪发光的人。 在大一下学期快结束的时候，我好像就在突然之间萌生了转到计算机专业的想法，这种想法只一瞬，但就像一粒种子，在我心中生了根发了芽，没过多久就长成了参天大树，无法动摇。想来人生也真是挺奇妙的，这样的事情最近又在我的人生中上演。人人都考研，但不考研的想法就不知何时飘进了我的脑中，这种想法愈演愈烈，让我做出了自己的决定。我不知道像这样的想法会将我的人生带向何处，但我知道它们已经改变了我的人生，我也期待着前方的路。 大二前的那个小学期我就没有选英语专业的课了，大二上学期的课完全照着计算机专业培养方案选的，兴高采烈等着加课。那天应该是一个星期一，我在院办值班，看到群里有人说加课结果出来了，我就打开看看自己的结果，结果为未通过。开始慌了。我早早下班了。出了外院门，我就给信院的教秘打电话。下午的课也直接翘掉了，直接去信院找教秘，教秘不管，又给系主任打电话。说是不给大二才转的加课。其实从看到结果的时候，我就知道再去找谁也不会改变什么了。现在想起来那天的经历还会觉得鼻头酸酸。在一个下午的时间里，我挣扎过，又很快接受了我不能改变的现状，马上去教务处加上了英语专业的课。只想毕业就好。 可能不能系统地学习计算机课程会有一点遗憾。有遗憾。但我现在也想开了。转过去的话，要补一年的课，每次选课都提心吊胆，还要面临延毕的焦虑，没有认识的朋友，估计也会很难熬。有时候会感觉老天在指引我的人生。之前的时候都能加课的，现在好像也能加课，就好巧没给我加课。我并没有“被安排”的感觉，要质问什么的，我只是觉得很奇妙。来到海大，大一下学了Python，就此产生转专业的想法，大二上凭着Python进了爱特程序部，到现在决定不考研毕业直接去找工作。一环扣一环，时间错开一点，我的人生估计又会有很大的不同。 Sophomore Year and Later转专业失败后，就回去继续上英语专业的课。上课就是等着下课，数着时间一点点过去。很长一段时间，我感觉我像被绑在一根绳上，两端都被紧紧拉着，没办法左移也没法右移，我也没法喘气。我想在课余时间里从“英语专业”里抽离出来去学点计算机相关的东西，但那些作业和数不清的展示又把我绑了回去。我又怂得很，不敢翘课，不敢不交作业，没有摆烂的勇气。躺平这个词还可以，我就任凭别人卷我，再卷我也不为所动，对很多事情也不太关心了。 比较幸运的事就是进入了爱特工作室，爱特是我唯一可以接触代码的地方。虽然我一直觉得自己像这个社团的“局外人”，我不是信院的，不爱玩游戏没什么共同话题，对技术的热爱也谈不上，但我一直很留恋在社团的时间，也从来没想过退出。爱特给了我一个平台，让我看到真正优秀的计算机大佬是什么样子的。写项目的过程，从什么都不会一个简单的东西查半天，到现在回望自己之前写的代码感觉像shit，我没学到了很多，但也确实是学到了很多。 爱特给了我成长，也给了我很多伤感emo的瞬间。我不记得我有多少个星期日的晚上，是垂头丧气回宿舍的。在看到别人的优秀后，我不知道我要怎么样才能追赶他们的脚步，我太垃圾了，太菜了。要学的东西太多了，会的东西太少了，和别人的差距太大了。现在我也时时会焦虑，但我已经学会和自己和解，不要和别人比，要和昨天的自己比。”无论人生上到哪一层台阶，阶下有人在仰望你，阶上亦有人在俯视你。你抬头自卑，低头自得。唯有平视，才能看见真正的自己。” 现在大三上学期即将结束，还有好几篇论文没写完，明天就是新的一年。下学期有更多自己可以支配的时间了，多学点，大四可能去实习。毕业后就去北京找工作了。不知道还会经历多少社会的毒打，就期待自己能获得自由吧。人生有什么意义呢？越去想人生有什么意义，我越觉得人生无意义。专注当下吧，想太多都是闲得，赶快去学习，反而能得到快乐和满足。 to be continued…","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://vanessayaoyao.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"life","slug":"life","permalink":"https://vanessayaoyao.github.io/tags/life/"}]},{"title":"JWT在Django中的具体实现","slug":"JWT在Django中的具体实现","date":"2021-12-03T09:10:25.000Z","updated":"2022-03-01T04:52:52.412Z","comments":true,"path":"2021/12/03/JWT在Django中的具体实现/","link":"","permalink":"https://vanessayaoyao.github.io/2021/12/03/JWT%E5%9C%A8Django%E4%B8%AD%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"记录一下，加深自己的理解。 什么是JWT？JWT是Json Web Token的缩写，可去官网查看更多。 简单说来，它和session干着一样的活，即身份认证。它保存在客户端，本质是一长串字符串，由header, payload和signature组成。 Why JWT not session? 使用session 存在CSRF攻击 session存在服务器端，无法适用分布式站点。 在Django中使用首先安装PyJWT 1pip install PyJWT models.py里建一张用户表，有用户名、密码等字段。 in views.py 1234567891011121314151617181920212223242526from .models import Userimport jwt, datetime, simplejson #导入def login(request): if request.method == &quot;POST&quot;: #接收json数据 username = simplejson.loads(request.body)[&#x27;username&#x27;] password = simplejson.loads(request.body)[&#x27;password&#x27;] #这里验证密码是否正确什么的我就先不写了 user = User.objects.filter(username=username).first() payload = &#123; #将该用户的id或username加入payload中 &quot;id&quot;: user.id, #过期时间，我这里写的是60分钟后过期 &quot;exp&quot;: datetime.datetime.utcnow() + datetime.timedelta(minutes=60), #生效时间，我这里写的是即刻生效 &quot;iat&quot;: datetime.datetime.utcnow() &#125; #将payload加密，我的密钥是&quot;secret&quot;(可以随便写) token = jwt.encode(payload, &quot;secret&quot;, algorithm=&#x27;HS256&#x27;).decode(&#x27;utf-8&#x27;) #将token返回 return JsonResponse(&#123;&#x27;jwt&#x27;: token, &#x27;msg&#x27;:&#x27;success&#x27;&#125;) else: return JsonResponse(&#123;&#x27;msg&#x27;: &#x27;wrong http method&#x27;&#125;) 123456789101112131415161718192021def user_info(request): if request.method == &quot;GET&quot;: #接收前端小伙伴放在HTTP头部的token #这样也避免了CSRF攻击 token = request.META.get(&#x27;HTTP_AUTHORIZATION&#x27;) if not token: msg = &#x27;not get token&#x27; try: #使用相同的密钥解密 payload = jwt.decode(token, &#x27;secret&#x27;, algorithms=[&#x27;HS256&#x27;]) #拿到用户id，从而完成用户认证 user = User.objects.get(id=payload[&#x27;id&#x27;]) msg = &#x27;get token, and I know you are &#x27; + user.username #也会存在异常 except jwt.ExpiredSignatureError: #如这里是token过期 msg = &#x27;token expired&#x27; except Exception as e: #还有其他过期类型，就不展开写了 msg = &quot;token invalid&quot; return JsonResponse(&#123;&#x27;token&#x27;: token, &#x27;msg&#x27;: msg&#125;) else: return JsonResponse(&#123;&#x27;msg&#x27;: &#x27;wrong http method&#x27;&#125;) 接口测试可用Postman， apifox等。 这只是一个小demo，实际运用中不可能每个需要身份认证的地方都写一遍（这么干也不是不行），所以考虑封装成装饰器。 这里我自我检讨一下，其实我装饰器并没有学会，只会照抄别人的代码。 改天再写一篇关于装饰器的博客。（立flag了） See you.","categories":[{"name":"Web相关","slug":"Web相关","permalink":"https://vanessayaoyao.github.io/categories/Web%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"JWT","slug":"JWT","permalink":"https://vanessayaoyao.github.io/tags/JWT/"}]},{"title":"怎么说呢，说就是不想考研了","slug":"怎么说呢，说就是不想考研了","date":"2021-10-11T00:23:28.000Z","updated":"2022-03-24T12:36:31.517Z","comments":true,"path":"2021/10/11/怎么说呢，说就是不想考研了/","link":"","permalink":"https://vanessayaoyao.github.io/2021/10/11/%E6%80%8E%E4%B9%88%E8%AF%B4%E5%91%A2%EF%BC%8C%E8%AF%B4%E5%B0%B1%E6%98%AF%E4%B8%8D%E6%83%B3%E8%80%83%E7%A0%94%E4%BA%86/","excerpt":"","text":"我虽无意逐鹿，却知苍生苦楚。 我头铁，要去撞南墙了。 2022/2/24更新之父母安心版 告诉了父母不考研的决定，他们虽然还是想让我继续学业，家里也不是供不起，但也是不强求，让我自己作主。三个多月前的有点像一时起意的想法，已经在我心底坐实，现在也是时候捋顺一下，算是一个交代吧。 摆在眼前有这么几条可以走的路吧，老师或者考公体制内算一种，考研算一种，互联网算一种。体制内可以直接pass了，教资我也考过，兼职的老师我也当过，我当老师和我当学生的心态完全一样，当学生想着如何撑到下课，当老师想的也是如何能苟到下课。考研其实不算一条真正的路吧，算是延期，倒时候还是要做选择。互联网挑战多机遇也多吧。 我发现我已经逐渐丧失了坐在课堂里听老师讲课学习的能力，可能是因为我上的课大多是水课，好久没有“学到知识”的体会了，我已经习惯了在课堂上玩手机。英语专业大多课都如此，平时水过去，全靠期末突击，得个还过得去的成绩，分高了还沾沾自喜一下。也有需要平时努力的课，当你作业认真完成，课堂展示和结课论文想得头秃，最后得的分数还不如随便水水的一门课时，你就应该知道分数根本代表不了什么。 最近考研成绩也陆续出来了，不免听到什么考了380，390分没学上的消息，我不知道是不是我又陷入了信息茧房中，但考研人数每年都是再创新高，越来越卷是事实。可能是我害怕我努力不够达不到目标，我卷不过，但选择另一条路也可以算是勇敢吧。考研的话，肯定是考计算机，英一数一408再加上政治，跨考难度飞起了吧。 考研的目的对我来说就是一个学历上的提升，而学历的提升也就是方便找工作。我对研究生的生活没什么向往，我也打听过研究生的生活是什么样的，基本就是要发文章，上课基本不怎么上，每周开会说说自己看了什么文献。可能如果我没参加过SRDP的话，还不会对看文献产生这么大的抵触心理。看文献发文章就算了，不是那块料，力不从心硬着头皮看，那真是煎熬。 工作的话，就算是本科，海大985的牌子还是有点用处的，我也不是非大厂不去，能去大厂当然很好，去不了就慢慢来嘛。我对技术也谈不上热爱吧，反正是不讨厌。我也不打算给自己一个具体的职业规划，我也规划不出来，三年前高三的我肯定没有想到现在的我在做什么打算，现在的我也预测不到未来的我。会遇到什么机遇吗？会惨兮兮地在出租房掉眼泪吗？会一直坚持做技术吗？会35岁失业吗哈哈哈哈。趁着年轻多去闯闯吧。 而且我已经期待完全的独立好久了。 Ps. 这学期选了游泳课，一定要学会游泳！","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://vanessayaoyao.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"life","slug":"life","permalink":"https://vanessayaoyao.github.io/tags/life/"}]},{"title":"寒假日常","slug":"寒假日常","date":"2021-02-07T16:23:46.000Z","updated":"2022-03-01T04:52:09.947Z","comments":true,"path":"2021/02/08/寒假日常/","link":"","permalink":"https://vanessayaoyao.github.io/2021/02/08/%E5%AF%92%E5%81%87%E6%97%A5%E5%B8%B8/","excerpt":"","text":"第一天 刷手机 第二天 刷手机 第三天 刷手机 第四天 刷手机 第五天 刷手机 第六天 tmd, 烦死了。老子要学习！ 第七天 刷手机。。。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://vanessayaoyao.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[]},{"title":"hello world!","slug":"hello-world-1","date":"2021-01-31T07:17:39.000Z","updated":"2022-03-01T04:51:50.385Z","comments":true,"path":"2021/01/31/hello-world-1/","link":"","permalink":"https://vanessayaoyao.github.io/2021/01/31/hello-world-1/","excerpt":"","text":"Hi. This is my first blog. I’m very excited.","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://vanessayaoyao.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"hello world","slug":"hello-world","permalink":"https://vanessayaoyao.github.io/tags/hello-world/"}]}],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://vanessayaoyao.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Bug调试","slug":"Bug调试","permalink":"https://vanessayaoyao.github.io/categories/Bug%E8%B0%83%E8%AF%95/"},{"name":"Web相关","slug":"Web相关","permalink":"https://vanessayaoyao.github.io/categories/Web%E7%9B%B8%E5%85%B3/"},{"name":"杂谈","slug":"杂谈","permalink":"https://vanessayaoyao.github.io/categories/%E6%9D%82%E8%B0%88/"},{"name":"Java SE","slug":"Java-SE","permalink":"https://vanessayaoyao.github.io/categories/Java-SE/"}],"tags":[{"name":"git","slug":"git","permalink":"https://vanessayaoyao.github.io/tags/git/"},{"name":"intern","slug":"intern","permalink":"https://vanessayaoyao.github.io/tags/intern/"},{"name":"nginx","slug":"nginx","permalink":"https://vanessayaoyao.github.io/tags/nginx/"},{"name":"mybatis-plus","slug":"mybatis-plus","permalink":"https://vanessayaoyao.github.io/tags/mybatis-plus/"},{"name":"springmvc","slug":"springmvc","permalink":"https://vanessayaoyao.github.io/tags/springmvc/"},{"name":"springboot","slug":"springboot","permalink":"https://vanessayaoyao.github.io/tags/springboot/"},{"name":"杂谈","slug":"杂谈","permalink":"https://vanessayaoyao.github.io/tags/%E6%9D%82%E8%B0%88/"},{"name":"AOP Ioc","slug":"AOP-Ioc","permalink":"https://vanessayaoyao.github.io/tags/AOP-Ioc/"},{"name":"reflection","slug":"reflection","permalink":"https://vanessayaoyao.github.io/tags/reflection/"},{"name":"tree","slug":"tree","permalink":"https://vanessayaoyao.github.io/tags/tree/"},{"name":"data structures","slug":"data-structures","permalink":"https://vanessayaoyao.github.io/tags/data-structures/"},{"name":"decorator","slug":"decorator","permalink":"https://vanessayaoyao.github.io/tags/decorator/"},{"name":"CROS","slug":"CROS","permalink":"https://vanessayaoyao.github.io/tags/CROS/"},{"name":"java","slug":"java","permalink":"https://vanessayaoyao.github.io/tags/java/"},{"name":"Ajax","slug":"Ajax","permalink":"https://vanessayaoyao.github.io/tags/Ajax/"},{"name":"redis","slug":"redis","permalink":"https://vanessayaoyao.github.io/tags/redis/"},{"name":"life","slug":"life","permalink":"https://vanessayaoyao.github.io/tags/life/"},{"name":"JWT","slug":"JWT","permalink":"https://vanessayaoyao.github.io/tags/JWT/"},{"name":"hello world","slug":"hello-world","permalink":"https://vanessayaoyao.github.io/tags/hello-world/"}]}